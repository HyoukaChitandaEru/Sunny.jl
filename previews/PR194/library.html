<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library API · Sunny documentation</title><meta name="title" content="Library API · Sunny documentation"/><meta property="og:title" content="Library API · Sunny documentation"/><meta property="twitter:title" content="Library API · Sunny documentation"/><meta name="description" content="Documentation for Sunny documentation."/><meta property="og:description" content="Documentation for Sunny documentation."/><meta property="twitter:description" content="Documentation for Sunny documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Sunny documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/01_LSWT_SU3_FeI2.html">1. Multi-flavor spin wave simulations of FeI₂ (Showcase)</a></li><li><a class="tocitem" href="examples/02_LSWT_CoRh2O4.html">2. Spin wave simulations of CoRh₂O₄</a></li><li><a class="tocitem" href="examples/03_LLD_CoRh2O4.html">3. Landau-Lifshitz dynamics of CoRh₂O₄ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/04_GSD_FeI2.html">4. Generalized spin dynamics of FeI₂ at finite <em>T</em></a></li><li><a class="tocitem" href="examples/05_MC_Ising.html">5. Monte Carlo sampling of the Ising model</a></li><li><a class="tocitem" href="examples/06_CP2_Skyrmions.html">6. Dynamical quench into CP² skyrmion liquid</a></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">SpinW tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/spinw/SW08_Kagome_AFM.html">SW8 - Kagome Antiferromagnet</a></li><li><a class="tocitem" href="examples/spinw/SW15_Ba3NbFe3Si2O14.html">SW15 - Ba₃NbFe₃Si₂O₁₄</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Contributed</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/contributed/MgCr2O4-tutorial.html">MgCr2O4 at Finite Temperature</a></li><li><a class="tocitem" href="examples/contributed/kappa_tutorial.html">Enforcing the quantum sum rule with moment renormalization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="parallelism.html">Parallelizing Calculations</a></li><li><a class="tocitem" href="writevtk.html">ParaView Rendering</a></li></ul></li></ul></li><li><span class="tocitem">Modeling Guides</span><ul><li><a class="tocitem" href="structure-factor.html">Structure Factor Calculations</a></li><li><a class="tocitem" href="renormalization.html">Interaction Strength Renormalization</a></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library API</a><ul class="internal"><li><a class="tocitem" href="#Optional-Makie-extensions"><span>Optional Makie extensions</span></a></li><li><a class="tocitem" href="#Optional-WriteVTK-extensions"><span>Optional WriteVTK extensions</span></a></li></ul></li><li><a class="tocitem" href="versions.html">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><ul><li><a href="library.html#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="library.html#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a></li><li><a href="library.html#Sunny.BinningParameters"><code>Sunny.BinningParameters</code></a></li><li><a href="library.html#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="library.html#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="library.html#Sunny.FormFactor-Tuple{String}"><code>Sunny.FormFactor</code></a></li><li><a href="library.html#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="library.html#Sunny.Langevin"><code>Sunny.Langevin</code></a></li><li><a href="library.html#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a></li><li><a href="library.html#Sunny.SampledCorrelations"><code>Sunny.SampledCorrelations</code></a></li><li><a href="library.html#Sunny.Site"><code>Sunny.Site</code></a></li><li><a href="library.html#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a></li><li><a href="library.html#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a></li><li><a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a></li><li><a href="library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>Sunny.add_sample!</code></a></li><li><a href="library.html#Sunny.available_energies-Tuple{SampledCorrelations}"><code>Sunny.available_energies</code></a></li><li><a href="library.html#Sunny.available_wave_vectors-Tuple{SampledCorrelations}"><code>Sunny.available_wave_vectors</code></a></li><li><a href="library.html#Sunny.axes_bincenters-Tuple{Any, Any, Any}"><code>Sunny.axes_bincenters</code></a></li><li><a href="library.html#Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}"><code>Sunny.broaden_energy</code></a></li><li><a href="library.html#Sunny.count_bins-Tuple{Any, Any, Any}"><code>Sunny.count_bins</code></a></li><li><a href="library.html#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>Sunny.dispersion</code></a></li><li><a href="library.html#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a></li><li><a href="library.html#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>Sunny.dssf</code></a></li><li><a href="library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.dynamical_correlations</code></a></li><li><a href="library.html#Sunny.eachsite-Tuple{System}"><code>Sunny.eachsite</code></a></li><li><a href="library.html#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="library.html#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a></li><li><a href="library.html#Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy_per_site</code></a></li><li><a href="library.html#Sunny.export_vtk"><code>Sunny.export_vtk</code></a></li><li><a href="library.html#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}"><code>Sunny.generate_mantid_script_from_binning_parameters</code></a></li><li><a href="library.html#Sunny.global_position-Tuple{System, Any}"><code>Sunny.global_position</code></a></li><li><a href="library.html#Sunny.instant_correlations-Tuple{System}"><code>Sunny.instant_correlations</code></a></li><li><a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>Sunny.instant_intensities_interpolated</code></a></li><li><a href="library.html#Sunny.integrate_axes!-Tuple{BinningParameters}"><code>Sunny.integrate_axes!</code></a></li><li><a href="library.html#Sunny.integrated_lorentzian-Tuple{Float64}"><code>Sunny.integrated_lorentzian</code></a></li><li><a href="library.html#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}"><code>Sunny.intensities_bands</code></a></li><li><a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_binned</code></a></li><li><a href="library.html#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}"><code>Sunny.intensities_broadened</code></a></li><li><a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_interpolated</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a></li><li><a href="library.html#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a></li><li><a href="library.html#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a></li><li><a href="library.html#Sunny.load_nxs-Tuple{Any}"><code>Sunny.load_nxs</code></a></li><li><a href="library.html#Sunny.lorentzian-Tuple{Any, Any}"><code>Sunny.lorentzian</code></a></li><li><a href="library.html#Sunny.magnetic_moment-Tuple{System, Any}"><code>Sunny.magnetic_moment</code></a></li><li><a href="library.html#Sunny.merge_correlations-Union{Tuple{Array{SampledCorrelations{N}, 1}}, Tuple{N}} where N"><code>Sunny.merge_correlations</code></a></li><li><a href="library.html#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.minimize_energy!</code></a></li><li><a href="library.html#Sunny.plot_spins"><code>Sunny.plot_spins</code></a></li><li><a href="library.html#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.polarize_spins!</code></a></li><li><a href="library.html#Sunny.position_to_site-Tuple{System, Any}"><code>Sunny.position_to_site</code></a></li><li><a href="library.html#Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.powder_average_binned</code></a></li><li><a href="library.html#Sunny.primitive_cell_shape-Tuple{Crystal}"><code>Sunny.primitive_cell_shape</code></a></li><li><a href="library.html#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a></li><li><a href="library.html#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a></li><li><a href="library.html#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>Sunny.print_stevens_expansion</code></a></li><li><a href="library.html#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a></li><li><a href="library.html#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a></li><li><a href="library.html#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_wrapped_intensities</code></a></li><li><a href="library.html#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a></li><li><a href="library.html#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a></li><li><a href="library.html#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a></li><li><a href="library.html#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.randomize_spins!</code></a></li><li><a href="library.html#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_path</code></a></li><li><a href="library.html#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}"><code>Sunny.reciprocal_space_path_bins</code></a></li><li><a href="library.html#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_shell</code></a></li><li><a href="library.html#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a></li><li><a href="library.html#Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.remove_periodicity!</code></a></li><li><a href="library.html#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a></li><li><a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_supercell</code></a></li><li><a href="library.html#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_supercell</code></a></li><li><a href="library.html#Sunny.rotate_operator-Tuple{LinearAlgebra.Hermitian{ComplexF64, Matrix{ComplexF64}}, Any}"><code>Sunny.rotate_operator</code></a></li><li><a href="library.html#Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}"><code>Sunny.rotation_in_rlu</code></a></li><li><a href="library.html#Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_coherent!</code></a></li><li><a href="library.html#Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_dipole!</code></a></li><li><a href="library.html#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a></li><li><a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_exchange_at!</code></a></li><li><a href="library.html#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a></li><li><a href="library.html#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a></li><li><a href="library.html#Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}"><code>Sunny.set_onsite_coupling!</code></a></li><li><a href="library.html#Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}"><code>Sunny.set_onsite_coupling_at!</code></a></li><li><a href="library.html#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>Sunny.set_pair_coupling!</code></a></li><li><a href="library.html#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_pair_coupling_at!</code></a></li><li><a href="library.html#Sunny.set_spin_rescaling!-Tuple{System{0}, Any}"><code>Sunny.set_spin_rescaling!</code></a></li><li><a href="library.html#Sunny.set_spiral_order!-Tuple{Any}"><code>Sunny.set_spiral_order!</code></a></li><li><a href="library.html#Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}"><code>Sunny.set_spiral_order_on_sublattice!</code></a></li><li><a href="library.html#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a></li><li><a href="library.html#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}"><code>Sunny.slice_2D_binning_parameters</code></a></li><li><a href="library.html#Sunny.spin_label-Tuple{System, Int64}"><code>Sunny.spin_label</code></a></li><li><a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>Sunny.spin_matrices</code></a></li><li><a href="library.html#Sunny.step!"><code>Sunny.step!</code></a></li><li><a href="library.html#Sunny.stevens_matrices-Tuple{Any}"><code>Sunny.stevens_matrices</code></a></li><li><a href="library.html#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a></li><li><a href="library.html#Sunny.suggest_magnetic_supercell-Tuple{Any}"><code>Sunny.suggest_magnetic_supercell</code></a></li><li><a href="library.html#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>Sunny.symmetry_equivalent_bonds</code></a></li><li><a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a></li><li><a href="library.html#Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.to_product_space</code></a></li><li><a href="library.html#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.unit_resolution_binning_parameters</code></a></li><li><a href="library.html#Sunny.view_crystal"><code>Sunny.view_crystal</code></a></li><li><a href="library.html#Sunny.@mix_proposals-Tuple"><code>Sunny.@mix_proposals</code></a></li></ul><ul><li><a href="library.html#Sunny.plot_spins"><code>Sunny.plot_spins</code></a></li><li><a href="library.html#Sunny.view_crystal"><code>Sunny.view_crystal</code></a></li><li><a href="library.html#Sunny.export_vtk"><code>Sunny.export_vtk</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Site" href="#Sunny.Site"><code>Sunny.Site</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(cell1, cell2, cell3, i) :: Site</code></pre><p>Four indices identifying a single site in a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The first three indices select the lattice cell and the last selects the sublattice (i.e., the atom within the unit cell).</p><p>This object can be used to index <code>dipoles</code> and <code>coherents</code> fields of a <code>System</code>. A <code>Site</code> is also required to specify inhomogeneous interactions via functions such as <a href="library.html#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>set_external_field_at!</code></a> or <a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_exchange_at!</code></a>.</p><p>Note that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the <code>Site</code> using <a href="library.html#Sunny.position_to_site-Tuple{System, Any}"><code>position_to_site</code></a>, which always takes a position in fractional coordinates of the original lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Units.meV
Units.theory</code></pre><p>The unit system is implicitly determined by the definition of two physical constants: the vacuum permeability <span>$μ₀$</span> and the Bohr magneton <span>$μ_B$</span>. Temperatures are effectively measured in units of energy (<span>$k_B = 1$</span>) and time is effectively measured in units of inverse energy (<span>$ħ = 1$</span>). The default unit system, <code>Units.meV</code>, employs (meV, Å, tesla). Select alternatively <code>Units.theory</code> for a units system defined so that <span>$μ₀ = μ_B = 1$</span>.</p><p>See also <a href="library.html#Sunny.meV_per_K"><code>meV_per_K</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Units.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.meV_per_K" href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meV_per_K = 0.086173332621451774</code></pre><p>A physical constant. Useful for converting kelvin into the default energy units, meV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Units.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.BinningParameters" href="#Sunny.BinningParameters"><code>Sunny.BinningParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinningParameters(binstart,binend,binwidth;covectors = I(4))
BinningParameters(binstart,binend;numbins,covectors = I(4))</code></pre><p>Describes a 4D parallelepided histogram in a format compatible with experimental Inelasitic Neutron Scattering data. See <a href="library.html#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}"><code>generate_mantid_script_from_binning_parameters</code></a> to convert <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> to a format understandable by the <a href="https://www.mantidproject.org/">Mantid software</a>, or <a href="library.html#Sunny.load_nxs-Tuple{Any}"><code>load_nxs</code></a> to load <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> from a Mantid <code>.nxs</code> file.</p><p>The coordinates of the histogram axes are specified by multiplication  of <code>(q,ω)</code> with each row of the <code>covectors</code> matrix, with <code>q</code> given in [R.L.U.]. Since the default <code>covectors</code> matrix is the identity matrix, the default axes are <code>(qx,qy,qz,ω)</code> in absolute units.</p><p>The convention for the binning scheme is that:</p><ul><li>The left edge of the first bin starts at <code>binstart</code></li><li>The bin width is <code>binwidth</code></li><li>The last bin contains <code>binend</code></li><li>There are no &quot;partial bins;&quot; the last bin may contain values greater than <code>binend</code>. C.f. <a href="library.html#Sunny.count_bins-Tuple{Any, Any, Any}"><code>count_bins</code></a>.</li></ul><p>A <code>value</code> can be binned by computing its bin index:</p><pre><code class="nohighlight hljs">coords = covectors * value
bin_ix = 1 .+ floor.(Int64,(coords .- binstart) ./ binwidth)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L2-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; symprec=1e-5)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>.  The optional parameter <code>symprec</code> controls the precision tolerance for spacegroup symmetries.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>latvecs</code>. Spacegroup symmetry information is automatically inferred. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)</code></pre><p>Builds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional <code>setting</code> string will disambiguate between unit cell conventions.</p><p>Currently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a <code>.cif</code> file or from the full specification of the unit cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build an FCC crystal using the primitive unit cell. The spacegroup number
# 225 is inferred.
latvecs = [1 1 0;
            1 0 1;
            0 1 1] / 2
positions = [[0, 0, 0]]
Crystal(latvecs, positions)

# Build a CsCl crystal (two cubic sublattices). By providing distinct type
# strings, the spacegroup number 221 is inferred.
latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0,0,0], [0.5,0.5,0.5]]
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(latvecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227. This
# spacegroup has two possible settings (&quot;1&quot; or &quot;2&quot;), which determine an
# overall unit cell translation.
latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[1, 1, 1] / 4]
cryst = Crystal(latvecs, positions, 227; setting=&quot;1&quot;)</code></pre><p>See also <a href="library.html#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Crystal.jl#L8-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.FormFactor-Tuple{String}" href="#Sunny.FormFactor-Tuple{String}"><code>Sunny.FormFactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FormFactor(ion::String; g_lande=2)</code></pre><p>The magnetic form factor for a given magnetic ion and charge state. When passed to an <a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>, determines a <span>$|𝐪|$</span>-dependent scaling of the structure factor.</p><p>The parameter <code>ion</code> must be one of the following strings:</p><pre><code class="nohighlight hljs">Am2, Am3, Am4, Am5, Am6, Am7, Au1, Au2, Au3, Au4, Au5, Ce2, Co0, Co1, Co2, Co3,
Co4, Cr0, Cr1, Cr2, Cr3, Cr4, Cu0, Cu1, Cu2, Cu3, Cu4, Dy2, Dy3, Er2, Er3, Eu2,
Eu3, Fe0, Fe1, Fe2, Fe3, Fe4, Gd2, Gd3, Hf2, Hf3, Ho2, Ho3, Ir0a, Ir0b, Ir0c,
Ir1a, Ir1b, Ir2, Ir3, Ir4, Ir5, Ir6, Mn0, Mn1, Mn2, Mn3, Mn4, Mo0, Mo1, Nb0,
Nb1, Nd2, Nd3, Ni0, Ni1, Ni2, Ni3, Ni4, Np3, Np4, Np5, Np6, Os0a, Os0b, Os0c,
Os1a, Os1b, Os2, Os3, Os4, Os5, Os6, Os7, Pd0, Pd1, Pr3, Pt1, Pt2, Pt3, Pt4,
Pt5, Pt6, Pu3, Pu4, Pu5, Pu6, Re0a, Re0b, Re0c, Re1a, Re1b, Re2, Re3, Re4, Re5,
Re6, Rh0, Rh1, Ru0, Ru1, Sc0, Sc1, Sc2, Sm2, Sm3, Ta2, Ta3, Ta4, Tb2, Tb3, Tc0,
Tc1, Ti0, Ti1, Ti2, Ti3, Tm2, Tm3, U3, U4, U5, V0, V1, V2, V3, V4, W0a, W0b,
W0c, W1a, W1b, W2c, W3, W4, W5, Y0, Yb2, Yb3, Zr0, Zr1</code></pre><p>The trailing number denotes ionization state. For example, <code>&quot;Fe0&quot;</code> denotes a neutral iron atom, while <code>&quot;Fe2&quot;</code> denotes <code>Fe²⁺</code>. If multiple electronic configurations are possible, they will be distinguished by a trailing letter (<code>a</code>, <code>b</code>, ...). Omitting this letter will print an informative error,</p><pre><code class="nohighlight hljs">FormFactor(&quot;Ir0&quot;)

ERROR: Disambiguate form factor according to electronic configuration:
    &quot;Ir0a&quot; -- 6s⁰5d⁹
    &quot;Ir0b&quot; -- 6s¹5d⁸
    &quot;Ir0c&quot; -- 6s²5d⁷</code></pre><p>The form factor is approximated as</p><p><span>$F(s) = ⟨j_0(s)⟩ + \frac{2-g}{g} ⟨j_2(s)⟩ s^2$</span>,</p><p>involving the Landé <span>$g$</span>-factor. The <span>$⟨j_l(s)⟩$</span> are radial integrals associated with the <span>$l$</span>th Bessel function of the magnetic dipole, where <span>$s = |k|/4π$</span>, and <span>$|k|$</span> is the magnitude of momentum transfer. </p><p>The radial integrals have been calculated using Hartree-Fock for transition metals, or Dirac-Fock for the rare earths and actinide series [1–3]. Sunny uses approximate fits as a sum of Gaussians,</p><p class="math-container">\[⟨j_0(s)⟩ = A e^{-as^2} + B e^{-bs^2} + C e^{-cs^2} + D e^{-ds^2} + E \
⟨j_l(s)⟩ = (A e^{-as^2} + B e^{-bs^2} + C e^{-cs^2} + D e^{-ds^2} + E) s^2\]</p><p>References:</p><ol><li>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</li><li>J. Brown, The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors (2003)</li><li>K. Kobayashi, T. Nagao, M. Ito, Acta Cryst. A, 67 pp 473–480 (2011)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/FormFactor.jl#L29-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(Δt::Float64; atol=1e-12) where N</code></pre><p>Energy-conserving spin dynamics. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will advance a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> by <code>Δt</code> units of time.</p><p>Uses the spherical midpoint integration scheme for dipole systems and the Schrödinger midpoint integration scheme for SU(<em>N</em>) spin systems. Both integration schemes are symplectic, and therefore avoid energy drift over long periods of simulation time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Integrators.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.Langevin" href="#Sunny.Langevin"><code>Sunny.Langevin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Langevin(Δt::Float64; λ::Float64, kT::Float64)</code></pre><p>Spin dynamics with coupling to a Langevin thermostat, which includes damping and noise terms. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will advance a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> by <code>Δt</code> units of time.</p><p>Assuming ergodicity, the Langevin dynamics will sample from thermal equilibrium for the target temperature <code>kT</code>. The empirical parameter <code>λ</code> determines the strength of the coupling to the thermal bath. In other words, <code>1/λ</code> is the decorrelation time-scale. If <span>$λ = 0$</span>, then the spin dynamics coincides with <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>.</p><p>An alternative approach to sampling is <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>, which may be preferred when the allowed spin values become effective discrete (e.g. Ising spins).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Integrators.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.LocalSampler" href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)</code></pre><p>Monte Carlo simulation involving Metropolis updates to individual spins. One call to the <a href="library.html#Sunny.step!"><code>step!</code></a> function will perform <code>nsweeps</code> of MCMC sampling for a provided <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The default value of <code>1.0</code> means that <code>step!</code> performs, on average, one trial update per spin.</p><p>Assuming ergodicity, the <code>LocalSampler</code> will sample from thermal equilibrium for the target temperature <code>kT</code>. </p><p>The trial spin updates are sampled using the <code>propose</code> function. Built-in options include <a href="library.html#Sunny.propose_uniform"><code>propose_uniform</code></a>, <a href="library.html#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>propose_flip</code></a>, and <a href="library.html#Sunny.propose_delta-Tuple{Any}"><code>propose_delta</code></a>. Multiple proposals can be mixed with the macro <a href="library.html#Sunny.@mix_proposals-Tuple"><code>@mix_proposals</code></a>.</p><p>The returned object stores fields <code>ΔE</code> and <code>Δs</code>, which represent the cumulative change to the net energy and dipole, respectively.</p><p>An alternative approach to sampling is <a href="library.html#Sunny.Langevin"><code>Langevin</code></a>, which may be preferred for simulating continuous spins, especially in the presence of long-range dipole-dipole interactions (cf. <a href="library.html#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>enable_dipole_dipole!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MonteCarlo/Samplers.jl#L98-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SampledCorrelations" href="#Sunny.SampledCorrelations"><code>Sunny.SampledCorrelations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampledCorrelations</code></pre><p>Basic data type for storing sampled correlation data. A <code>SampleCorrelations</code> is initialized by calling either <a href="library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> or <a href="library.html#Sunny.instant_correlations-Tuple{System}"><code>instant_correlations</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/SampledCorrelations.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinInfo" href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinInfo(atom::Int; S, g=2)</code></pre><p>Characterizes the spin at a given <code>atom</code> index within the crystal unit cell. <code>S</code> is an integer multiple of 1/2 and gives the spin angular momentum in units of ħ. <code>g</code> is the g-factor or tensor, such that an angular momentum dipole <span>$s$</span> produces a magnetic moment <span>$g s$</span> in units of the Bohr magneton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/SpinInfo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.SpinWaveTheory" href="#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinWaveTheory(sys, energy_ϵ::Float64=1e-8)</code></pre><p>Constructs an object to perform linear spin wave theory. Use it with <a href="library.html#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>dispersion</code></a> and <a href="library.html#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>dssf</code></a> functions.</p><p>The optional parameter <code>energy_ϵ</code> adds a small positive shift to the diagonal of the dynamical matrix <span>$D$</span> to avoid numerical issues with zero-energy quasi-particle modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SpinWaveTheory/SpinWaveTheory.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}" href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)</code></pre><p>Construct a <code>System</code> of spins for a given <a href="library.html#Sunny.Crystal"><code>Crystal</code></a> symmetry. The <code>latsize</code> parameter determines the number of unit cells in each lattice vector direction. The <code>infos</code> parameter is a list of <a href="library.html#Sunny.SpinInfo"><code>SpinInfo</code></a> objects, which determine the magnitude <span>$S$</span> and <span>$g$</span>-tensor of each spin.</p><p>The two primary options for <code>mode</code> are <code>:SUN</code> and <code>:dipole</code>. In the former, each spin-<span>$S$</span> degree of freedom is described as an SU(<em>N</em>) coherent state, i.e. a quantum superposition of <span>$N = 2S + 1$</span> levels. This formalism can be useful to capture multipolar spin fluctuations or local entanglement effects. </p><p>Mode <code>:dipole</code> projects the SU(<em>N</em>) dynamics onto the restricted space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but single-ion anisotropy and biquadratic exchange interactions will be renormalized to improve accuracy. To disable this renormalization, use the mode <code>:dipole_large_S</code> which applies the <span>$S → ∞$</span> classical limit. For details, see the documentation page: <a href="renormalization.html#Interaction-Strength-Renormalization">Interaction Strength Renormalization</a>.</p><p>The default units system of (meV, Å, tesla) can be overridden by with the <code>units</code> parameter; see <a href="library.html#Sunny.Units"><code>Units</code></a>. </p><p>An optional <code>seed</code> may be provided to achieve reproducible random number generation.</p><p>All spins are initially polarized in the <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.add_sample!-Tuple{SampledCorrelations, System}" href="#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>Sunny.add_sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_sample!(sc::SampledCorrelations, sys::System)</code></pre><p><code>add_trajectory</code> uses the spin configuration contained in the <code>System</code> to generate a correlation data and accumulate it into <code>sc</code>. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculating in time and accumulated into <code>sc</code>. </p><p>This function will change the state of <code>sys</code> when calculating dynamical structure factor data. To preserve the initial state of <code>sys</code>, it must be saved separately prior to calling <code>add_sample!</code>. Alternatively, the initial spin configuration may be copied into a new <code>System</code> and this new <code>System</code> can be passed to <code>add_sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/CorrelationSampling.jl#L134-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.available_energies-Tuple{SampledCorrelations}" href="#Sunny.available_energies-Tuple{SampledCorrelations}"><code>Sunny.available_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available_energies(sc::SampledCorrelations; negative_energies=false)</code></pre><p>Return the ω values for the energy index of a <code>SampledCorrelations</code>. By default, only returns values for non-negative energies, which corresponds to the default output of <code>intensities</code>. Set <code>negative_energies</code> to true to retrieve all ω values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/CorrelationUtils.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.available_wave_vectors-Tuple{SampledCorrelations}" href="#Sunny.available_wave_vectors-Tuple{SampledCorrelations}"><code>Sunny.available_wave_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">available_wave_vectors(sc::SampledCorrelations; bzsize=(1,1,1))</code></pre><p>Returns all wave vectors for which <code>sc</code> contains exact values. <code>bsize</code> specifies the number of Brillouin zones to be included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/CorrelationUtils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.axes_bincenters-Tuple{Any, Any, Any}" href="#Sunny.axes_bincenters-Tuple{Any, Any, Any}"><code>Sunny.axes_bincenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axes_bincenters(params::BinningParameters)</code></pre><p>Returns tick marks which label the bins of the histogram described by <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> by their bin centers.</p><p>The following alternative syntax can be used to compute bin centers for a single axis:</p><pre><code class="nohighlight hljs">axes_bincenters(binstart,binend,binwidth)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L288-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}" href="#Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}"><code>Sunny.broaden_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broaden_energy(sc::SampledCorrelations, vals, kernel::Function; negative_energies=false)</code></pre><p>Performs a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. <code>kernel</code> must be a function that takes two numbers: <code>kernel(ω, ω₀)</code>, where <code>ω</code> is a frequency, and <code>ω₀</code> is the center frequency of the kernel. Sunny provides <a href="library.html#Sunny.lorentzian-Tuple{Any, Any}"><code>lorentzian</code></a> for the most common use case:</p><pre><code class="nohighlight hljs">newvals = broaden_energy(sc, vals, (ω, ω₀) -&gt; lorentzian(ω-ω₀, 0.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/DataRetrieval.jl#L155-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.count_bins-Tuple{Any, Any, Any}" href="#Sunny.count_bins-Tuple{Any, Any, Any}"><code>Sunny.count_bins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_bins(binstart,binend,binwidth)</code></pre><p>Returns the number of bins in the binning scheme implied by <code>binstart</code>, <code>binend</code>, and <code>binwidth</code>. To count the bins in a <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a>, use <code>params.numbins</code>.</p><p>This function defines how partial bins are handled, so it should be used preferentially over computing the number of bins manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L77-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dispersion-Tuple{SpinWaveTheory, Any}" href="#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>Sunny.dispersion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispersion(swt::SpinWaveTheory, qs)</code></pre><p>Computes the spin excitation energy dispersion relations given a <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a> and an array of wave vectors <code>qs</code>. Each element <span>$q$</span> of <code>qs</code> must be a 3-vector in units of reciprocal lattice units. I.e., <span>$qᵢ$</span> is given in <span>$2π/|aᵢ|$</span> with <span>$|aᵢ|$</span> the lattice constant of the original chemical lattice.</p><p>The first indices of the returned array correspond to those of <code>qs</code>. A final index, corresponding to mode, is added to these. Each entry of the array is an energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SpinWaveTheory/DispersionAndIntensities.jl#L84-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dmvec-Tuple{Any}" href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Antisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,</p><pre><code class="nohighlight hljs">  [  0    D[3] -D[2]
   -D[3]   0    D[1]
    D[2] -D[1]   0  ]</code></pre><p>Useful in the context of <a href="library.html#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/PairExchange.jl#L475-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dssf-Tuple{SpinWaveTheory, Any}" href="#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>Sunny.dssf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dssf(swt::SpinWaveTheory, qs)</code></pre><p>Given a <a href="library.html#Sunny.SpinWaveTheory"><code>SpinWaveTheory</code></a> object, computes the dynamical spin structure factor,</p><p class="math-container">\[    𝒮^{αβ}(𝐤, ω) = 1/(2πN)∫dt ∑_𝐫 \exp[i(ωt - 𝐤⋅𝐫)] ⟨S^α(𝐫, t)S^β(0, 0)⟩,\]</p><p>using the result from linear spin-wave theory,</p><p class="math-container">\[    𝒮^{αβ}(𝐤, ω) = ∑_n |A_n^{αβ}(𝐤)|^2 δ[ω-ω_n(𝐤)].\]</p><p><code>qs</code> is an array of wave vectors of arbitrary dimension. Each element <span>$q$</span> of <code>qs</code> must be a 3-vector in reciprocal lattice units (RLU), i.e., in the basis of reciprocal lattice vectors.</p><p>The first indices of the returned array correspond to those of <code>qs</code>. A final index, corresponding to mode, is added to these. Each entry of this array is a tensor (3×3 matrix) corresponding to the indices <span>$α$</span> and <span>$β$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SpinWaveTheory/DispersionAndIntensities.jl#L128-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.dynamical_correlations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dynamical_correlations(sys::System; Δt, nω, ωmax, 
    process_trajectory=:none, observables=nothing, correlations=nothing)</code></pre><p>Creates an empty <code>SampledCorrelations</code> object for calculating and storing dynamical structure factor intensities <span>$𝒮(𝐪,ω)$</span>. Call <a href="library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>add_sample!</code></a> to accumulate data for the given configuration of a spin system. Internally, this will run a dynamical trajectory and measure time correlations. The <span>$𝒮(𝐪,ω)$</span> data can be retrieved by calling <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. Alternatively, <a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a> will integrate out <span>$ω$</span> to obtain <span>$𝒮(𝐪)$</span>, optionally applying classical-to-quantum correction factors.</p><p>Three keywords are required to specify the dynamics used for the trajectory calculation.</p><ul><li><code>Δt</code>: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a> integrator.</li><li><code>ωmax</code>: The maximum energy, <span>$ω$</span>, that will be resolved.</li><li><code>nω</code>: The number of energy bins to calculated between 0 and <code>ωmax</code>.</li></ul><p>Additional keyword options are the following:</p><ul><li><code>observables</code>: Allows the user to specify custom observables. The   <code>observables</code> must be given as a list of complex <code>N×N</code> matrices or   <code>LinearMap</code>s. It&#39;s recommended to name each observable, for example:   <code>observables = [:A =&gt; a_observable_matrix, :B =&gt; b_map, ...]</code>. By default,   Sunny uses the 3 components of the dipole, <code>:Sx</code>, <code>:Sy</code> and <code>:Sz</code>.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$αβ$</span> of <span>$𝒮^{αβ}(q,ω)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all <code>observables</code>. To retain only the xx and   xy correlations, one would set <code>correlations=[(:Sx,:Sx), (:Sx,:Sy)]</code> or   <code>correlations=[(1,1),(1,2)]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/SampledCorrelations.jl#L88-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.eachsite-Tuple{System}" href="#Sunny.eachsite-Tuple{System}"><code>Sunny.eachsite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachsite(sys::System)</code></pre><p>An iterator over all <a href="library.html#Sunny.Site"><code>Site</code></a>s in the system. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System)</code></pre><p>Enables long-range dipole-dipole interactions,</p><p class="math-container">\[    -(μ_0/4π) ∑_{⟨ij⟩}  (3 (𝐌_j⋅𝐫̂_{ij})(𝐌_i⋅𝐫̂_{ij}) - 𝐌_i⋅𝐌_j) / |𝐫_{ij}|^3\]</p><p>where the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are <span>$𝐌_i = μ_B g 𝐒_i$</span> where <span>$g$</span> is the g-factor or g-tensor, and <span>$𝐒_i$</span> is the spin angular momentum dipole in units of ħ. The Bohr magneton <span>$μ_B$</span> and vacuum permeability <span>$μ_0$</span> are physical constants, with numerical values determined by the unit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>The total system energy. See also <a href="library.html#Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N"><code>energy_per_site</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy_per_site-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy_per_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_per_site(sys::System)</code></pre><p>The total system <a href="library.html#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>energy</code></a> divided by the number of sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}" href="#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}"><code>Sunny.generate_mantid_script_from_binning_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_mantid_script_from_binning_parameters(params::BinningParameters)</code></pre><p>Generate a Mantid script which bins data according to the  given <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Units</header><div class="admonition-body"><p>Take care to ensure the units are correct (R.L.U. or absolute). You may want to call <code>Sunny.bin_rlu_as_absolute_units!</code> or <code>Sunny.bin_absolute_units_as_rlu!</code> first.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/ExperimentData.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.global_position-Tuple{System, Any}" href="#Sunny.global_position-Tuple{System, Any}"><code>Sunny.global_position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_position(sys::System, site::Site)</code></pre><p>Position of a <a href="library.html#Sunny.Site"><code>Site</code></a> in global coordinates.</p><p>To precompute a full list of positions, one can use <a href="library.html#Sunny.eachsite-Tuple{System}"><code>eachsite</code></a> as below:</p><pre><code class="language-julia hljs">pos = [global_position(sys, site) for site in eachsite(sys)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L207-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.instant_correlations-Tuple{System}" href="#Sunny.instant_correlations-Tuple{System}"><code>Sunny.instant_correlations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_correlations(sys::System; process_trajectory=:none, observables=nothing, correlations=nothing)</code></pre><p>Creates an empty <code>SampledCorrelations</code> object for calculating and storing instantaneous structure factor intensities <span>$𝒮(𝐪)$</span>. Call <a href="library.html#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>add_sample!</code></a> to accumulate data for the given configuration of a spin system. Call <a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a> to retrieve averaged <span>$𝒮(𝐪)$</span> data.</p><p><em>Important note</em>: When dealing with continuous (non-Ising) spins, consider creating using <a href="library.html#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> instead of <code>instant_correlations</code>. The former will provide full <span>$𝒮(𝐪,ω)$</span> data, from which <span>$𝒮(𝐪)$</span> can be obtained by integrating out <span>$ω$</span>. During this integration step, Sunny can incorporate temperature- and <span>$ω$</span>-dependent classical-to-quantum correction factors to produce more accurate <span>$𝒮(𝐪)$</span> estimates. See <a href="library.html#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a> for more information.</p><p>The following optional keywords are available:</p><ul><li><code>observables</code>: Allows the user to specify custom observables. The   <code>observables</code> must be given as a list of complex <code>N×N</code> matrices or   <code>LinearMap</code>s. It&#39;s recommended to name each observable, for example:   <code>observables = [:A =&gt; a_observable_matrix, :B =&gt; b_map, ...]</code>. By default,   Sunny uses the 3 components of the dipole, <code>:Sx</code>, <code>:Sy</code> and <code>:Sz</code>.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$αβ$</span> of <span>$𝒮^{αβ}(q,ω)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all <code>observables</code>. To retain only the xx and   xy correlations, one would set <code>correlations=[(:Sx,:Sx), (:Sx,:Sy)]</code> or   <code>correlations=[(1,1),(1,2)]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/SampledCorrelations.jl#L174-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}" href="#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>Sunny.instant_intensities_interpolated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_intensities_interpolated(sc::SampledCorrelations, qs; kwargs...)</code></pre><p>Return <span>$𝒮(𝐪)$</span> intensities at wave vectors <code>qs</code>. The functionality is very similar to <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>, except the returned array has dimensions identical to <code>qs</code>. If called on a <code>SampledCorrelations</code> with dynamical information, i.e., <span>$𝒮(𝐪,ω)$</span>, the <span>$ω$</span> information is integrated out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Interpolation.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.integrate_axes!-Tuple{BinningParameters}" href="#Sunny.integrate_axes!-Tuple{BinningParameters}"><code>Sunny.integrate_axes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate_axes!(params::BinningParameters; axes)</code></pre><p>Integrate over one or more axes of the histogram by setting the number of bins in that axis to 1. Examples:</p><pre><code class="nohighlight hljs">integrate_axes!(params; axes = [2,3])
integrate_axes!(params; axes = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L98-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.integrated_lorentzian-Tuple{Float64}" href="#Sunny.integrated_lorentzian-Tuple{Float64}"><code>Sunny.integrated_lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrated_lorentzian(η)</code></pre><p>Returns <span>$x \mapsto atan(x/η)/π$</span> for use with <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/DataRetrieval.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}" href="#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}"><code>Sunny.intensities_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispersion, intensities = intensities_bands(swt::SpinWaveTheory, ks, formula::SpinWaveIntensityFormula)</code></pre><p>Computes the scattering intensities at each energy band for each momentum transfer <code>k</code> in <code>ks</code>, according to Linear Spin Wave Theory and the given intensity <code>formula</code>. The <code>formula</code> must have a delta-function kernel, e.g.:</p><pre><code class="nohighlight hljs">formula = intensity_formula(swt, :perp, formula; kernel = delta_function_kernel)</code></pre><p>or else the bands will be broadened, and their intensity can not be computed.</p><p>The outputs will be arrays with indices identical to <code>ks</code>, with the last index giving the band index. <code>dispersions</code> reports the energy of each band, while <code>intensities</code> reports the scattering intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/LinearSpinWaveIntensities.jl#L40-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}" href="#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_binned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity, counts = intensities_binned(sc::SampledCorrelations, params::BinningParameters, formula; integrated_kernel)</code></pre><p>Given correlation data contained in a <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> and <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> describing the shape of a histogram, compute the intensity and normalization for each histogram bin using a given <a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>.</p><p>The <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> are expected to accept <code>(q,ω)</code> in R.L.U. for the (possibly reshaped) crystal associated with <code>sc</code>.</p><p>This is an alternative to <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> which bins the scattering intensities into a histogram instead of interpolating between them at specified <code>qs</code> values. See <a href="library.html#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>unit_resolution_binning_parameters</code></a> for a reasonable default choice of <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> which roughly emulates <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> with <code>interpolation = :round</code>.</p><p>If a function <code>integrated_kernel(Δω)</code> is passed, it will be used as the CDF of a kernel function for energy broadening. For example, <code>integrated_kernel = Δω -&gt; atan(Δω/η)/pi</code> (c.f. <a href="library.html#Sunny.integrated_lorentzian-Tuple{Float64}"><code>integrated_lorentzian</code></a> implements Lorentzian broadening with parameter <code>η</code>. Energy-dependent energy broadening can be achieved by providing an <code>integrated_kernel(ω,Δω)</code> whose first argument is the energy transfer <code>ω</code>.</p><p>Currently, energy broadening is only supported if the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> are such that the first three axes are purely spatial and the last (energy) axis is <code>[0,0,0,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L359-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}" href="#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}"><code>Sunny.intensities_broadened</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities_broadened(swt::SpinWaveTheory, ks, ωvals, formula)</code></pre><p>Computes the scattering intensities at each <code>(Q,ω)</code> according to Linear Spin Wave Theory and the given intensity <code>formula</code>. The required <code>formula</code> must have a non-delta-function kernel, e.g.:</p><pre><code class="nohighlight hljs">formula = intensity_formula(swt, :perp; kernel = lorentzian(0.05))</code></pre><p>or else the intensity at <code>ωvals</code> which are not exactly on the dispersion curve can not be calculated.</p><p>The intensity is computed at each wave vector in <code>ks</code> and each energy in <code>ωvals</code>. The output will be an array with indices identical to <code>ks</code>, with the last index matching <code>ωvals</code>.</p><p>Note that <code>ks</code> is an array of wave vectors of arbitrary dimension. Each element <span>$k$</span> of <code>ks</code> must be a 3-wavevector in absolute units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/LinearSpinWaveIntensities.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}" href="#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.intensities_interpolated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities_interpolated(sc::SampledCorrelations, qs, formula:ClassicalIntensityFormula; interpolation=nothing, negative_energies=false)</code></pre><p>The basic function for retrieving <span>$𝒮(𝐪,ω)$</span> information from a <code>SampledCorrelations</code>. Maps an array of wave vectors <code>qs</code> to an array of structure factor intensities, including an additional energy index. The values of <span>$ω$</span> associated with the energy index can be retrieved by calling <a href="library.html#Sunny.available_energies-Tuple{SampledCorrelations}"><code>available_energies</code></a>. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.</p><ul><li><code>interpolation</code>: Since <span>$𝒮(𝐪, ω)$</span> is calculated on a finite lattice, data   is only available at discrete wave vectors. By default, Sunny will round a   requested <code>q</code> to the nearest available wave vector. Linear interpolation can   be applied by setting <code>interpolation=:linear</code>.</li><li><code>negative_energies</code>: If set to <code>true</code>, Sunny will return the periodic   extension of the energy axis. Most users will not want this.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Interpolation.jl#L100-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{Function, Any, Any}" href="#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A custom intensity formula can be specifed by providing a function <code>intensity = f(q,ω,correlations)</code> and specifying which correlations it requires:</p><pre><code class="nohighlight hljs">intensity_formula(f,sc::SampledCorrelations, required_correlations; kwargs...)</code></pre><p>The function is intended to be specified using <code>do</code> notation. For example, this custom formula sums the off-diagonal correlations:</p><pre><code class="nohighlight hljs">required = [(:Sx,:Sy),(:Sy,:Sz),(:Sx,:Sz)]
intensity_formula(sc,required,return_type = ComplexF64) do k, ω, off_diagonal_correlations
    sum(off_diagonal_correlations)
end</code></pre><p>If your custom formula returns a type other than <code>Float64</code>, use the <code>return_type</code> keyword argument to flag this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/DataRetrieval.jl#L104-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}" href="#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formula = intensity_formula(sc::SampledCorrelations)</code></pre><p>Establish a formula for computing the intensity of the discrete scattering modes <code>(q,ω)</code> using the correlation data <span>$𝒮^{αβ}(q,ω)$</span> stored in the <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a>. The <code>formula</code> returned from <code>intensity_formula</code> can be passed to <a href="library.html#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> or <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>.</p><pre><code class="nohighlight hljs">intensity_formula(sc,...; kT = Inf, formfactors = ...)</code></pre><p>There are keyword arguments providing temperature and form factor corrections:</p><ul><li><code>kT</code>: If a temperature is provided, the intensities will be rescaled by a   temperature- and ω-dependent classical-to-quantum factor. <code>kT</code> should be   specified when making comparisons with spin wave calculations or   experimental data. If <code>kT</code> is not specified, infinite temperature (no   correction) is assumed.</li><li><code>formfactors</code>: To apply form factor corrections, provide this keyword with a   list of <code>FormFactor</code>s, one for each symmetry-distinct site in the crystal.   The order of <code>FormFactor</code>s must correspond to the order of site symmetry   classes, e.g., as they appear when printed in <code>display(crystal)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/DataRetrieval.jl#L43-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}" href="#Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formula = intensity_formula(swt::SpinWaveTheory; kernel = ...)</code></pre><p>Establish a formula for computing the scattering intensity by diagonalizing the hamiltonian <span>$H(q)$</span> using Linear Spin Wave Theory.</p><p>If <code>kernel = delta_function_kernel</code>, then the resulting formula can be used with <a href="library.html#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}"><code>intensities_bands</code></a>.</p><p>If <code>kernel</code> is an energy broadening kernel function, then the resulting formula can be used with <a href="library.html#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}"><code>intensities_broadened</code></a>. Energy broadening kernel functions can either be a function of <code>Δω</code> only, e.g.:</p><pre><code class="nohighlight hljs">kernel = Δω -&gt; ...</code></pre><p>or a function of both the energy transfer <code>ω</code> and of <code>Δω</code>, e.g.:</p><pre><code class="nohighlight hljs">kernel = (ω,Δω) -&gt; ...</code></pre><p>The integral of a properly normalized kernel function over all <code>Δω</code> is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SpinWaveTheory/DispersionAndIntensities.jl#L216-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}" href="#Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}"><code>Sunny.intensity_formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_formula([swt or sc], contraction_mode::Symbol)</code></pre><p>Sunny has several built-in formulas that can be selected by setting <code>contraction_mode</code> to one of these values:</p><ul><li><code>:trace</code> (default), which yields <span>$\operatorname{tr} 𝒮(q,ω) = ∑_α 𝒮^{αα}(q,ω)$</span></li><li><code>:perp</code>, which contracts <span>$𝒮^{αβ}(q,ω)$</span> with the dipole factor <span>$δ_{αβ} - q_{α}q_{β}$</span>, returning the unpolarized intensity.</li><li><code>:full</code>, which will return all elements <span>$𝒮^{αβ}(𝐪,ω)$</span> without contraction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/ElementContraction.jl#L155-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}" href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_params(latvecs::Mat3)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, α, β, γ)$</span> for the three lattice vectors provided as columns of <code>latvecs</code>. The inverse mapping is <a href="library.html#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lattice_vectors-NTuple{6, Any}" href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, α, β, γ)</code></pre><p>Return the lattice vectors, as columns of the <span>$3×3$</span> output matrix, that correspond to the conventional unit cell defined by the lattice constants <span>$(a, b, c)$</span> and the angles <span>$(α, β, γ)$</span> in degrees. The inverse mapping is <a href="library.html#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>lattice_params</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/LatticeUtils.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.load_nxs-Tuple{Any}" href="#Sunny.load_nxs-Tuple{Any}"><code>Sunny.load_nxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">params, signal = load_nxs(filename)</code></pre><p>Given the name of a Mantid-exported <code>MDHistoWorkspace</code> file, load the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> and the signal from that file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/ExperimentData.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.lorentzian-Tuple{Any, Any}" href="#Sunny.lorentzian-Tuple{Any, Any}"><code>Sunny.lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lorentzian(x, η)</code></pre><p>Returns <span>$η/(π(x^2 + η^2))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/DataRetrieval.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.magnetic_moment-Tuple{System, Any}" href="#Sunny.magnetic_moment-Tuple{System, Any}"><code>Sunny.magnetic_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetic_moment(sys::System, site::Site)</code></pre><p>Get the magnetic moment for a <a href="library.html#Sunny.Site"><code>Site</code></a>. This is the spin dipole multiplied by the Bohr magneton and the local g-tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L224-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.merge_correlations-Union{Tuple{Array{SampledCorrelations{N}, 1}}, Tuple{N}} where N" href="#Sunny.merge_correlations-Union{Tuple{Array{SampledCorrelations{N}, 1}}, Tuple{N}} where N"><code>Sunny.merge_correlations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_correlations(scs::Vector{SampledCorrelations)</code></pre><p>Accumulate a list of <code>SampledCorrelations</code> into a single, summary <code>SampledCorrelations</code>. Useful for reducing the results of parallel computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/SampledCorrelations/SampledCorrelations.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.minimize_energy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimize_energy!(sys::System{N}; maxiters=100, subiters=20,
                 method=Optim.ConjugateGradient(), kwargs...) where N</code></pre><p>Optimizes the spin configuration in <code>sys</code> to minimize energy. A total of <code>maxiters</code> iterations will be attempted, with restarts after every <code>subiters</code> iterations. The remaining <code>kwargs</code> will be forwarded to the <code>optimize</code> method of the Optim.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Optimization.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.polarize_spins!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarize_spins!(sys::System, dir)</code></pre><p>Polarize all spins in the system along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L452-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.position_to_site-Tuple{System, Any}" href="#Sunny.position_to_site-Tuple{System, Any}"><code>Sunny.position_to_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position_to_site(sys::System, r)</code></pre><p>Converts a position <code>r</code> to four indices of a <a href="library.html#Sunny.Site"><code>Site</code></a>. The coordinates of <code>r</code> are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find the `site` at the center of a unit cell which is displaced by four
# multiples of the first lattice vector
site = position_to_site(sys, [4.5, 0.5, 0.5])

# Print the dipole at this site
println(sys.dipoles[site])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L245-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}" href="#Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>Sunny.powder_average_binned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">powder_average_binned(sc::SampledCorrelations, radial_binning_parameters; formula
                     ω_binning_parameters, integrated_kernel = nothing, bzsize = nothing)</code></pre><p>This function emulates the experimental situation of &quot;powder averaging,&quot; where only the magnitude (and not the direction) of the momentum transfer is resolvable. The intensities are binned similarly to <a href="library.html#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a>, but the histogram x-axis is <code>|k|</code> in absolute units, which is a nonlinear function of <code>kx</code>,<code>ky</code>,<code>kz</code>. The y-axis is energy.</p><p>Radial binning parameters are specified as tuples <code>(start,end,bin_width)</code>, e.g. <code>radial_binning_parameters = (0,6π,6π/55)</code>.</p><p>Energy broadening is supported in the same way as <code>intensities_binned</code>, and this function accepts the same kind of <a href="library.html#Sunny.intensity_formula-Tuple{Function, Any, Any}"><code>intensity_formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/PowderAveraging.jl#L49-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.primitive_cell_shape-Tuple{Crystal}" href="#Sunny.primitive_cell_shape-Tuple{Crystal}"><code>Sunny.primitive_cell_shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitive_cell_shape(cryst::Crystal)</code></pre><p>Returns the shape of the primitive cell as a 3×3 matrix, in fractional coordinates of the conventional lattice vectors. May be useful for constructing inputs to <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Valid if `cryst` has not been reshaped
@assert cryst.prim_latvecs ≈ cryst.latvecs * primitive_cell_shape(cryst)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Crystal.jl#L397-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_bond-Tuple{Crystal, Bond}" href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Printing.jl#L125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_site-Tuple{Any, Any}" href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_site(cryst, i; R=I)</code></pre><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Printing.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_stevens_expansion-Tuple{AbstractMatrix}" href="#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>Sunny.print_stevens_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_stevens_expansion(op)</code></pre><p>Prints a local Hermitian operator as a linear combination of Stevens operators. The operator <code>op</code> may be a finite-dimensional matrix or an abstract spin polynomial in the large-<span>$S$</span> limit.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">S = spin_matrices(2)
print_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)
# Prints: (1/20)𝒪₄₀ + (1/4)𝒪₄₄ + 102/5

S = spin_matrices(Inf)
print_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)
# Prints: (1/20)𝒪₄₀ + (1/4)𝒪₄₄ + (3/5)𝒮⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Operators/Stevens.jl#L177-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_suggested_frame-Tuple{Crystal, Int64}" href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_suggested_frame(cryst, i; digits=4)</code></pre><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. The purpose is to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Printing.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_symmetry_table-Tuple{Crystal, Any}" href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Printing.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_wrapped_intensities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_wrapped_intensities(sys::System; nmax=10)</code></pre><p>For Bravais lattices: Prints up to <code>nmax</code> wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are naïvely averaged over sublattices, without incorporating phase shift information. This procedure therefore wraps all wavevectors into the first Brillouin zone. Each wavevector coordinate is given between <span>$-1/2$</span> and <span>$1/2$</span> in reciprocal lattice units (RLU).  The output from this function will typically be used as input to <a href="library.html#Sunny.suggest_magnetic_supercell-Tuple{Any}"><code>suggest_magnetic_supercell</code></a>.</p><p>Because this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use <a href="library.html#Sunny.instant_correlations-Tuple{System}"><code>instant_correlations</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MagneticOrdering.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_delta-Tuple{Any}" href="#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_delta(magnitude)</code></pre><p>Generate a proposal function that adds a Gaussian perturbation to the existing spin state. In <code>:dipole</code> mode, the procedure is to first introduce a random three-vector perturbation <span>$𝐬′ = 𝐬 + |𝐬| ξ$</span> and then return the properly normalized spin <span>$|𝐬| (𝐬′/|𝐬′|)$</span>. Each component of the random vector <span>$ξ$</span> is Gaussian distributed with a standard deviation of <code>magnitude</code>; the latter is dimensionless and typically smaller than one. </p><p>In <code>:SUN</code> mode, the procedure is analogous, but now involving Gaussian perturbations to each of the <span>$N$</span> complex components of an SU(<em>N</em>) coherent state.</p><p>In the limit of very large <code>magnitude</code>, this function coincides with <a href="library.html#Sunny.propose_uniform"><code>propose_uniform</code></a>.</p><p>For use with <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MonteCarlo/Samplers.jl#L20-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_flip</code></pre><p>Function to propose pure spin flip updates in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. Dipoles are flipped as <span>$𝐬 → -𝐬$</span>. SU(<em>N</em>) coherent states are flipped using the time-reversal operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MonteCarlo/Samplers.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.propose_uniform" href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propose_uniform</code></pre><p>Function to propose a uniformly random spin update in the context of a <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>. In <code>:dipole</code> mode, the result is a random three-vector with appropriate normalization. In <code>:SUN</code> mode, the result is a random SU(<em>N</em>) coherent state with appropriate normalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MonteCarlo/Samplers.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.randomize_spins!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomize_spins!(sys::System)</code></pre><p>Randomizes all spins under appropriate the uniform distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L411-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}" href="#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocal_space_path(cryst::Crystal, qs, density)</code></pre><p>Returns a pair <code>(path, xticks)</code>. The <code>path</code> return value is a list of wavevectors that samples linearly between the provided wavevectors <code>qs</code>. The <code>xticks</code> return value can be used to label the special <span>$𝐪$</span> values on the x-axis of a plot.</p><p>Special note about units: the wavevectors <code>qs</code> must be provided in reciprocal lattice units (RLU) for the given crystal, but the sampling density must be specified in the global frame. Specifically, the density is given as number of sample points per unit of radian inverse length, where the unit of length is the same as that used to specify the lattice vectors of the Crystal. The <code>path</code> will therefore include more samples between <code>q</code>-points that are further apart in absolute Fourier distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Interpolation.jl#L212-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}" href="#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}"><code>Sunny.reciprocal_space_path_bins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocal_space_path_bins(sc,qs,density,args...;kwargs...)</code></pre><p>Takes a list of wave vectors, <code>qs</code> in R.L.U., and builds a series of histogram <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> whose first axis traces a path through the provided points. The second and third axes are integrated over according to the <code>args</code> and <code>kwargs</code>, which are passed through to <a href="library.html#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}"><code>slice_2D_binning_parameters</code></a>.</p><p>Also returned is a list of marker indices corresponding to the input points, and a list of ranges giving the indices of each histogram <code>x</code>-axis within a concatenated histogram. The <code>density</code> parameter is given in samples per reciprocal lattice unit (R.L.U.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L320-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}" href="#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}"><code>Sunny.reciprocal_space_shell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocal_space_shell(cryst::Crystal, radius, n)</code></pre><p>Sample <code>n</code> points on the reciprocal space sphere with a given <code>radius</code> (units of inverse length).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Sample wavevectors on the sphere at fixed density
reciprocal_space_shell(cryst, r, 4π*r^2*density)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/PowderAveraging.jl#L15-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reference_bonds-Tuple{Crystal, Float64}" href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/SymmetryAnalysis.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.remove_periodicity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_periodicity!(sys::System, dims)</code></pre><p>Remove periodic interactions along the dimensions where <code>dims</code> is <code>true</code>. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Remove periodic boundaries along the 1st and 3rd dimensions
remove_periodicity!(sys::System, (true, false, true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/PairExchange.jl#L446-L458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat_periodically(sys::System{N}, counts::NTuple{3,Int}) where N</code></pre><p>Creates a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> identical to <code>sys</code> but repeated a given number of times in each dimension, specified by the tuple <code>counts</code>.</p><p>See also <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Reshaping.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reshape_supercell(sys::System, shape)</code></pre><p>Maps an existing <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> to a new one that has the shape and periodicity of a requested supercell. The columns of the <span>$3×3$</span> integer matrix <code>shape</code> represent the supercell lattice vectors measured in units of the original crystal lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Reshaping.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_supercell(sys::System{N}, latsize::NTuple{3,Int}) where N</code></pre><p>Creates a <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> with a given number of conventional unit cells in each lattice vector direction. Interactions and other settings will be inherited from <code>sys</code>.</p><p>Convenience function for:</p><pre><code class="language-julia hljs">reshape_supercell(sys, [latsize[1] 0 0; 0 latsize[2] 0; 0 0 latsize[3]])</code></pre><p>See also <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Reshaping.jl#L119-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.rotate_operator-Tuple{LinearAlgebra.Hermitian{ComplexF64, Matrix{ComplexF64}}, Any}" href="#Sunny.rotate_operator-Tuple{LinearAlgebra.Hermitian{ComplexF64, Matrix{ComplexF64}}, Any}"><code>Sunny.rotate_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_operator(A, R)</code></pre><p>Rotates the local quantum operator <code>A</code> according to the <span>$3×3$</span> rotation matrix <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Operators/Rotation.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}" href="#Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}"><code>Sunny.rotation_in_rlu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation_in_rlu(cryst::Crystal, axis, angle)</code></pre><p>Returns a <span>$3×3$</span> matrix that rotates wavevectors in reciprocal lattice units (RLU). The axis vector is a real-space direction in absolute units (but arbitrary magnitude), and the angle is in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Interpolation.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N" href="#Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_coherent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_coherent!(sys::System, Z, site::Site)</code></pre><p>Set a coherent spin state at a <a href="library.html#Sunny.Site"><code>Site</code></a> using the <span>$N$</span> complex amplitudes in <code>Z</code>.</p><p>For a standard <a href="library.html#Sunny.SpinInfo"><code>SpinInfo</code></a>, these amplitudes will be interpreted in the eigenbasis of <span>$𝒮̂ᶻ$</span>. That is, <code>Z[1]</code> represents the amplitude for the basis state fully polarized along the <span>$ẑ$</span>-direction, and subsequent components represent states with decreasing angular momentum along this axis (<span>$m = S, S-1, …, -S$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L423-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N" href="#Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.set_dipole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_dipole!(sys::System, dir, site::Site)</code></pre><p>Polarize the spin at a <a href="library.html#Sunny.Site"><code>Site</code></a> along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L442-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond)</code></pre><p>Sets a 3×3 spin-exchange matrix <code>J</code> along <code>bond</code>, yielding a pairwise interaction energy <span>$𝐒_i⋅J 𝐒_j$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>The parameter <code>J</code> may be scalar or matrix-valued. As a convenience, <code>dmvec(D)</code> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$𝐃⋅(𝐒_i×𝐒_j)$</span>.</p><p>For more general interactions, such as biquadratic, use <a href="library.html#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>set_pair_coupling!</code></a> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An explicit exchange matrix
J1 = [2 3 0;
     -3 2 0;
      0 0 2]
set_exchange!(sys, J1, bond)

# An equivalent Heisenberg + DM exchange 
J2 = 2*I + dmvec([0,0,3])
set_exchange!(sys, J2, bond)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/PairExchange.jl#L260-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N" href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_exchange_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange_at!(sys::System, J, site1::Site, site2::Site; offset=nothing)</code></pre><p>Sets an exchange interaction `<code>𝐒_i⋅J 𝐒_j</code> along the single bond connecting two <a href="library.html#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>If the system is relatively small, the direction of the bond can be ambiguous due to possible periodic wrapping. Resolve this ambiguity by passing an explicit <code>offset</code> vector, in multiples of unit cells.</p><p>For more general interactions, such as biquadratic, use <a href="library.html#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_pair_coupling_at!</code></a> instead.</p><p>See also <a href="library.html#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/PairExchange.jl#L374-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_external_field!-Tuple{System, Any}" href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field!(sys::System, B::Vec3)</code></pre><p>Sets the external field <code>B</code> that couples to all spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_external_field_at!-Tuple{System, Any, Any}" href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field_at!(sys::System, B::Vec3, site::Site)</code></pre><p>Sets a Zeeman coupling between a field <code>B</code> and a single spin. <a href="library.html#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}" href="#Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}"><code>Sunny.set_onsite_coupling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_onsite_coupling!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The operator <code>op</code> may be provided as an abstract function of the local spin operators, as a polynomial of <a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>spin_matrices</code></a>, or as a linear combination of <a href="library.html#Sunny.stevens_matrices-Tuple{Any}"><code>stevens_matrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An easy axis anisotropy in the z-direction
set_onsite_coupling!(sys, S -&gt; -D*S[3]^3, i)

# The unique quartic single-ion anisotropy for a site with cubic point group
# symmetry
set_onsite_coupling!(sys, S -&gt; 20*(S[1]^4 + S[2]^4 + S[3]^4), i)

# An equivalent expression of this quartic anisotropy, up to a constant shift
O = stevens_matrices(spin_label(sys, i))
set_onsite_coupling!(sys, O[4,0] + 5*O[4,4], i)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/OnsiteCoupling.jl#L91-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}" href="#Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}"><code>Sunny.set_onsite_coupling_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_onsite_coupling_at!(sys::System, op, site::Site)</code></pre><p>Sets the single-ion anisotropy operator <code>op</code> for a single <a href="library.html#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry.  The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="library.html#Sunny.set_onsite_coupling!-Tuple{System, Any, Int64}"><code>set_onsite_coupling!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/OnsiteCoupling.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N" href="#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>Sunny.set_pair_coupling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_pair_coupling!(sys::System, op, bond)</code></pre><p>Sets an arbitrary coupling <code>op</code> along <code>bond</code>. This coupling will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells. The operator <code>op</code> may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Bilinear+biquadratic exchange involving 3×3 matrices J1 and J2
set_pair_coupling!(sys, (Si, Sj) -&gt; Si&#39;*J1*Sj + (Si&#39;*J2*Sj)^2, bond)

# Equivalent expression using an appropriate fixed matrix representation
S = spin_matrices(1/2)
Si, Sj = to_product_space(S, S)
set_pair_coupling!(sys, Si&#39;*J1*Sj + (Si&#39;*J2*Sj)^2, bond)</code></pre><p>See also <a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>spin_matrices</code></a>, <a href="library.html#Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}"><code>to_product_space</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/PairExchange.jl#L208-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N" href="#Sunny.set_pair_coupling_at!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>Sunny.set_pair_coupling_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_pair_coupling_at!(sys::System, op, bond)</code></pre><p>Sets an arbitrary coupling along the single bond connecting two <a href="library.html#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. Any previous coupling on this bond will be overwritten. The operator <code>op</code> may be provided as an anonymous function that accepts two spin dipole operators, or as a matrix that acts in the tensor product space of the two sites. The documentation for <a href="library.html#Sunny.set_pair_coupling!-Union{Tuple{N}, Tuple{System{N}, AbstractMatrix, Any}} where N"><code>set_pair_coupling!</code></a> provides examples constructing <code>op</code>.</p><p>The system must support inhomogeneous interactions via <a href="library.html#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>If the system is relatively small, the direction of the bond can be ambiguous due to possible periodic wrapping. Resolve this ambiguity by passing an explicit <code>offset</code> vector, in multiples of unit cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/PairExchange.jl#L403-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spin_rescaling!-Tuple{System{0}, Any}" href="#Sunny.set_spin_rescaling!-Tuple{System{0}, Any}"><code>Sunny.set_spin_rescaling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_spin_rescaling!(sys, κ)</code></pre><p>Renormalize all expected magnetic moments (e.g., dipoles) by <code>κ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L463-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spiral_order!-Tuple{Any}" href="#Sunny.set_spiral_order!-Tuple{Any}"><code>Sunny.set_spiral_order!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_spiral_order!(sys; q, axis, S0)</code></pre><p>Initializes the system with a spiral order described by the wavevector <code>q</code>, an axis of rotation <code>axis</code>, and an initial dipole direction <code>S0</code> at the real-space origin. The wavevector is expected in repicrocal lattice units (RLU), while the direction vectors <code>axis</code> and <code>S0</code> are expected in global Cartesian coordinates.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Spiral order for a wavevector propagating in the direction of the first
# reciprocal lattice vector (i.e., orthogonal to the lattice vectors ``𝐚_2``
# and ``𝐚_3``), repeating with a period of 10 lattice constants, and spiraling
# about the ``ẑ``-axis. The spin at the origin will point in the direction
# ``𝐒_0 = ŷ + ẑ``.  Here, ``(x̂, ŷ, ẑ)`` are the axes of Cartesian coordinate
# system in the global frame.
set_spiral_order!(sys; q=[1/10, 0, 0], axis=[0, 0, 1], S0=[0, 1, 1])</code></pre><p>See also <a href="library.html#Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}"><code>set_spiral_order_on_sublattice!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MagneticOrdering.jl#L243-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}" href="#Sunny.set_spiral_order_on_sublattice!-Tuple{Any, Any}"><code>Sunny.set_spiral_order_on_sublattice!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_spiral_order_on_sublattice!(sys, i; q, axis, S0)</code></pre><p>Initializes sublattice <code>i</code> with a spiral order described by the wavevector <code>q</code>, an axis of rotation <code>axis</code>, and an initial dipole direction <code>S0</code>. The phase is selected such that the spin at <code>sys.dipole[1,1,1,i]</code> will point in the direction of <code>S0</code>. The wavevector is expected in repicrocal lattice units (RLU), while the direction vectors <code>axis</code> and <code>S0</code> are expected in global Cartesian coordinates.</p><p>This function is not available for systems with reshaped unit cells.</p><p>See also <a href="library.html#Sunny.set_spiral_order!-Tuple{Any}"><code>set_spiral_order!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MagneticOrdering.jl#L277-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vacancy_at!(sys::System, site::Site)</code></pre><p>Make a single site nonmagnetic. <a href="library.html#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}" href="#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}"><code>Sunny.slice_2D_binning_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_2D_binning_parameter(sc::SampledCorrelations, cut_from_q, cut_to_q, cut_bins::Int64, cut_width::Float64; plane_normal = [0,0,1],cut_height = cutwidth)</code></pre><p>Creates <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> which make a cut along one dimension of Q-space.</p><p>The x-axis of the resulting histogram consists of <code>cut_bins</code>-many bins ranging from <code>cut_from_q</code> to <code>cut_to_q</code>.  The width of the bins in the transverse direciton is controlled by <code>cut_width</code> and <code>cut_height</code>.</p><p>The binning in the transverse directions is defined in the following way, which sets their normalization and orthogonality properties:</p><pre><code class="nohighlight hljs">cut_covector = normalize(cut_to_q - cut_from_q)
transverse_covector = normalize(plane_normal × cut_covector)
cotransverse_covector = normalize(transverse_covector × cut_covector)</code></pre><p>In other words, the axes are orthonormal with respect to the Euclidean metric.</p><p>If the cut is too narrow, there will be very few scattering vectors per bin, or the number per bin will vary substantially along the cut. If the output appears under-resolved, try increasing <code>cut_width</code>.</p><p>The four axes of the resulting histogram are:</p><ol><li>Along the cut</li><li>Fist transverse Q direction</li><li>Second transverse Q direction</li><li>Energy</li></ol><p>This function can be used without reference to a <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> using this alternate syntax to manually specify the bin centers for the energy axis:</p><pre><code class="nohighlight hljs">slice_2D_binning_parameter(ω_bincenters, cut_from, cut_to,...)</code></pre><p>where <code>ω_bincenters</code> specifies the energy axis, and both <code>cut_from</code> and <code>cut_to</code> are arbitrary covectors, in any units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L227-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spin_label-Tuple{System, Int64}" href="#Sunny.spin_label-Tuple{System, Int64}"><code>Sunny.spin_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_label(sys::System, i::Int)</code></pre><p>If atom <code>i</code> carries a single spin-<span>$S$</span> moment, then returns the half-integer label <span>$S$</span>. Otherwise, throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.spin_matrices-Tuple{Any}" href="#Sunny.spin_matrices-Tuple{Any}"><code>Sunny.spin_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_matrices(S)</code></pre><p>Returns a triple of <span>$N×N$</span> spin matrices, where <span>$N = 2S+1$</span>. These are the generators of SU(2) in the spin-<code>S</code> representation.</p><p>If <code>S == Inf</code>, then the return values are abstract symbols denoting infinite-dimensional matrices that commute. These can be useful for repeating historical studies, or modeling micromagnetic systems. A technical discussion appears in the Sunny documentation page: <a href="renormalization.html#Interaction-Strength-Renormalization">Interaction Strength Renormalization</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">S = spin_matrices(3/2)
@assert S&#39;*S ≈ (3/2)*(3/2+1)*I
@assert S[1]*S[2] - S[2]*S[1] ≈ im*S[3]

S = spin_matrices(Inf)
@assert S[1]*S[2] - S[2]*S[1] == 0</code></pre><p>See also <a href="library.html#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>print_stevens_expansion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Operators/Spin.jl#L17-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.step!" href="#Sunny.step!"><code>Sunny.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, dynamics)</code></pre><p>Advance the spin configuration one dynamical time-step. The <code>dynamics</code> object may be a continuous spin dynamics, such as <a href="library.html#Sunny.Langevin"><code>Langevin</code></a> or <a href="library.html#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>, or it may be a discrete Monte Carlo sampling scheme such as <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Integrators.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.stevens_matrices-Tuple{Any}" href="#Sunny.stevens_matrices-Tuple{Any}"><code>Sunny.stevens_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stevens_matrices(S)</code></pre><p>Returns a generator of Stevens operators in the spin-<code>S</code> representation. The return value <code>O</code> can be indexed as <code>O[k,q]</code>, where <span>$0 ≤ k ≤ 6$</span> labels an irrep of SO(3) and <span>$-k ≤ q ≤ k$</span>. This will produce an <span>$N×N$</span> matrix where ``N = 2S</p><ul><li>1``. Linear combinations of Stevens operators can be used as a &quot;physical</li></ul><p>basis&quot; for decomposing local observables. To see this decomposition, use <a href="library.html#Sunny.print_stevens_expansion-Tuple{AbstractMatrix}"><code>print_stevens_expansion</code></a>.</p><p>If <code>S == Inf</code>, then symbolic operators will be returned. In this infinite dimensional limit, the Stevens operators become homogeneous polynomials of commuting spin operators.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">O = stevens_matrices(2)
S = spin_matrices(2)

A = (1/20)O[4,0] + (1/4)O[4,4] + (102/5)I
B = S[1]^4 + S[2]^4 + S[3]^4
@assert A ≈ B</code></pre><p>See also <a href="library.html#Sunny.spin_matrices-Tuple{Any}"><code>spin_matrices</code></a> and <a href="renormalization.html#Interaction-Strength-Renormalization">Interaction Strength Renormalization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Operators/Stevens.jl#L225-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N" href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Symmetry/Crystal.jl#L510-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.suggest_magnetic_supercell-Tuple{Any}" href="#Sunny.suggest_magnetic_supercell-Tuple{Any}"><code>Sunny.suggest_magnetic_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">suggest_magnetic_supercell(qs; tol=1e-12, maxsize=100)</code></pre><p>Suggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors <code>qs</code> in RLU. If the wavevectors are incommensurate (with respect to the maximum supercell size <code>maxsize</code>), one can select a larger error tolerance <code>tol</code> to find a supercell that is almost commensurate.</p><p>Prints a <span>$3×3$</span> matrix of integers that is suitable for use in <a href="library.html#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_supercell</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A magnetic supercell for a single-Q structure. Will print
q1 = [0, -1/4, 1/4]
suggest_magnetic_supercell([q1])       # [1 0 0; 0 2 1; 0 -2 1]

# A larger magnetic supercell for a double-Q structure
q2 = [1/4, 0, 1/4]
suggest_magnetic_supercell([q1, q2])   # [1 2 2; -1 2 -2; -1 2 2]

# If given incommensurate wavevectors, find an approximate supercell that
# is exactly commensurate for nearby wavevectors.
suggest_magnetic_supercell([[0, 0, 1/√5], [0, 0, 1/√7]]; tol=1e-2)

# This prints [1 0 0; 0 1 0; 0 0 16], which becomes commensurate under the
# approximations `1/√5 ≈ 7/16` and `1/√7 ≈ 3/8`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MagneticOrdering.jl#L71-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}" href="#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>Sunny.symmetry_equivalent_bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetry_equivalent_bonds(sys::System, bond::Bond)</code></pre><p>Given a <a href="library.html#Sunny.Bond"><code>Bond</code></a> for the original (unreshaped) crystal, return all symmetry equivalent bonds in the <a href="library.html#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. Each returned bond is represented as a pair of <a href="library.html#Sunny.Site"><code>Site</code></a>s, which may be used as input to <a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_exchange_at!</code></a>. Reverse bonds are not included (no double counting).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">for (site1, site2, offset) in symmetry_equivalent_bonds(sys, bond)
    @assert site1 &lt; site2
    set_exchange_at!(sys, J, site1, site2; offset)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/System.jl#L314-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_inhomogeneous(sys::System)</code></pre><p>Returns a copy of the system that allows for inhomogeneous interactions, which can be set using <a href="library.html#Sunny.set_onsite_coupling_at!-Tuple{System, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}}"><code>set_onsite_coupling_at!</code></a>, <a href="library.html#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N"><code>set_exchange_at!</code></a>, and <a href="library.html#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>set_vacancy_at!</code></a>.</p><p>Inhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/System/Interactions.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}" href="#Sunny.to_product_space-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.to_product_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_product_space(A, B, Cs...)</code></pre><p>Given lists of operators acting on local Hilbert spaces individually, return the corresponding operators that act on the tensor product space. In typical usage, the inputs will represent local physical observables and the outputs will be used to define quantum couplings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Operators/TensorOperators.jl#L100-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}" href="#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>Sunny.unit_resolution_binning_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unit_resolution_binning_parameters(sc::SampledCorrelations)</code></pre><p>Create <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> which place one histogram bin centered at each possible <code>(q,ω)</code> scattering vector of the crystal. This is the finest possible binning without creating bins with zero scattering vectors in them.</p><p>This function can be used without reference to a <a href="library.html#Sunny.SampledCorrelations"><code>SampledCorrelations</code></a> using an alternate syntax to manually specify the bin centers for the energy axis and the lattice size:</p><pre><code class="nohighlight hljs">unit_resolution_binning_parameters(ω_bincenters,latsize,[reciprocal lattice vectors])</code></pre><p>The last argument may be a 3x3 matrix specifying the reciprocal lattice vectors, or a <a href="library.html#Sunny.Crystal"><code>Crystal</code></a>.</p><p>Lastly, binning parameters for a single axis may be specifed by their bin centers:</p><pre><code class="nohighlight hljs">(binstart,binend,binwidth) = unit_resolution_binning_parameters(bincenters::Vector{Float64})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/Intensities/Binning.jl#L169-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.@mix_proposals-Tuple" href="#Sunny.@mix_proposals-Tuple"><code>Sunny.@mix_proposals</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mix_proposals weight1 propose1 weight2 propose2 ...</code></pre><p>Macro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with <a href="library.html#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># A proposal function that proposes a spin flip 40% of the time, and a
# Gaussian perturbation 60% of the time.
@mix_proposals 0.4 propose_flip 0.6 propose_delta(0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/src/MonteCarlo/Samplers.jl#L56-L69">source</a></section></article><h2 id="Optional-Makie-extensions"><a class="docs-heading-anchor" href="#Optional-Makie-extensions">Optional Makie extensions</a><a id="Optional-Makie-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Makie-extensions" title="Permalink"></a></h2><p>The following will be enabled through a package extension if either <code>GLMakie</code> or <code>WGLMakie</code> is loaded.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.plot_spins" href="#Sunny.plot_spins"><code>Sunny.plot_spins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_spins(sys::System; arrowscale=1.0, color=:red, colorfn=nothing,
           colormap=:viridis, colorrange=nothing, show_cell=true, orthographic=false,
           ghost_radius=0, dims=3</code></pre><p>Plot the spin configuration defined by <code>sys</code>. Optional parameters are:</p><ul><li><code>arrowscale</code>: Scale all arrows by dimensionless factor.</li><li><code>color</code>: Arrow colors. May be symbolic or numeric. If scalar, will be shared among all sites.</li><li><code>colorfn</code>: Function that dynamically maps from a site index to a numeric color value. Useful for animations.</li><li><code>colormap</code>, <code>colorrange</code>: Used to populate colors from numbers following Makie conventions.</li><li><code>show_cell</code>: Show original crystallographic unit cell.</li><li><code>orthographic</code>: Use camera with orthographic projection.</li><li><code>ghost_radius</code>: Show translucent periodic images up to a given distance (length units).</li><li><code>dims</code>: Spatial dimensions of system (1, 2, or 3).</li></ul><p>Calling <code>notify</code> on the return value will animate the figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/ext/PlottingExt.jl#L194-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.view_crystal" href="#Sunny.view_crystal"><code>Sunny.view_crystal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal, max_dist::Real; show_axis=true, orthographic=false)</code></pre><p>An interactive crystal viewer, with bonds up to <code>max_dist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/ext/PlottingExt.jl#L380-L384">source</a></section></article><h2 id="Optional-WriteVTK-extensions"><a class="docs-heading-anchor" href="#Optional-WriteVTK-extensions">Optional WriteVTK extensions</a><a id="Optional-WriteVTK-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-WriteVTK-extensions" title="Permalink"></a></h2><p>The following will be enabled through a package extension if <code>WriteVTK</code> is loaded.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sunny.export_vtk" href="#Sunny.export_vtk"><code>Sunny.export_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_vtk(filename,params::BinningParameters,data)</code></pre><p>Export a VTK-compatible file to <code>filename</code> (do not include file extension when specifying the file name) which contains the <code>data</code> as VTK Cell Data on a grid parameterized by <code>params</code>.</p><p>At least one axis of the <a href="library.html#Sunny.BinningParameters"><code>BinningParameters</code></a> must be integrated over, since VTK does not support 4D data. See <a href="library.html#Sunny.integrate_axes!-Tuple{BinningParameters}"><code>integrate_axes!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/4a4e8c66f15f66458dcc44a0022efd038d95e3b6/ext/ExportVTKExt.jl#L59-L68">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="renormalization.html">« Interaction Strength Renormalization</a><a class="docs-footer-nextpage" href="versions.html">Version History »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 22 November 2023 16:26">Wednesday 22 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
