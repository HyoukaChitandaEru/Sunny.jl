<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FeI‚ÇÇ at Finite Temperature ¬∑ Sunny documentation</title><meta name="title" content="FeI‚ÇÇ at Finite Temperature ¬∑ Sunny documentation"/><meta property="og:title" content="FeI‚ÇÇ at Finite Temperature ¬∑ Sunny documentation"/><meta property="twitter:title" content="FeI‚ÇÇ at Finite Temperature ¬∑ Sunny documentation"/><meta name="description" content="Documentation for Sunny documentation."/><meta property="og:description" content="Documentation for Sunny documentation."/><meta property="twitter:description" content="Documentation for Sunny documentation."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Sunny documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../fei2_tutorial/">Case Study: FeI‚ÇÇ</a></li><li><a class="tocitem" href="../out_of_equilibrium/">CP<span>$^2$</span> Skyrmion Quench</a></li><li><a class="tocitem" href="../powder_averaging/">Powder Averaged CoRh‚ÇÇO‚ÇÑ</a></li><li class="is-active"><a class="tocitem" href>FeI‚ÇÇ at Finite Temperature</a><ul class="internal"><li><a class="tocitem" href="#Finding-a-ground-state"><span>Finding a ground state</span></a></li><li><a class="tocitem" href="#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle"><span>Calculating Thermal-Averaged Correlations <span>$\langle S^{\alpha\beta}(ùê™,œâ)\rangle$</span></span></a></li><li><a class="tocitem" href="#Computing-Scattering-Intensities"><span>Computing Scattering Intensities</span></a></li><li class="toplevel"><a class="tocitem" href="#Unconventional-RLU-Systems-and-Constant-Energy-Cuts"><span>Unconventional RLU Systems and Constant Energy Cuts</span></a></li></ul></li><li><a class="tocitem" href="../ising2d/">Classical Ising model</a></li></ul></li><li><a class="tocitem" href="../../library/">Library API</a></li><li><a class="tocitem" href="../../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../../anisotropy/">Single-Ion Anisotropy</a></li><li><a class="tocitem" href="../../writevtk/">ParaView Rendering</a></li><li><a class="tocitem" href="../../parallelism/">Parallelizing Calculations</a></li><li><a class="tocitem" href="../../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>FeI‚ÇÇ at Finite Temperature</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FeI‚ÇÇ at Finite Temperature</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/examples/fei2_classical.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>Download this example as <a href="../../assets/notebooks/fei2_classical.ipynb">Jupyter notebook</a> or <a href="../../assets/scripts/fei2_classical.jl">Julia script</a>.</p><h1 id="FeI-at-Finite-Temperature"><a class="docs-heading-anchor" href="#FeI-at-Finite-Temperature">FeI‚ÇÇ at Finite Temperature</a><a id="FeI-at-Finite-Temperature-1"></a><a class="docs-heading-anchor-permalink" href="#FeI-at-Finite-Temperature" title="Permalink"></a></h1><pre><code class="language-julia hljs">using Sunny, LinearAlgebra, GLMakie</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>In our previous <a href="../fei2_tutorial/#Case-Study:-FeI">Case Study: FeI‚ÇÇ</a>, we used linear spin wave theory (LSWT) to calculate the dynamical structure factor. Here, we perform a similar calculation using classical spin dynamics. Because we are interested in the coupled dynamics of spin dipoles and quadrupoles, we employ a <a href="https://arxiv.org/abs/2209.01265">classical dynamics of SU(3) coherent states</a> that generalizes the Landau-Lifshitz equation.</p><p>Compared to LSWT, simulations using classical dynamics are much slower, and are limited in <span>$k$</span>-space resolution. However, they make it is possible to capture nonlinear effects associated with finite temperature fluctuations. Classical dynamics are also appealing for studying out-of-equilibrium systems (e.g., relaxation of spin glasses), or systems with quenched inhomogeneities that require large simulation volumes.</p><p>In this tutorial, we show how to study the finite temperature dynamics of FeI‚ÇÇ using the classical approach. It is important to stress that the estimation of <span>$S(ùê™,œâ)$</span> with classical dynamics is fundamentally a Monte Carlo calculation: sample spin configurations are drawn from thermal equilibrium and used as initial conditions for generating dissipationless trajectories. The correlations of these trajectories are then averaged and used to calculate scattering intensities. It is therefore important to ensure that the initial spin configurations are sampled appropriately and that sufficient statistics are collected. We will demonstrate one approach here.</p><p>As an overview, we will:</p><ol><li>Identify the ground state</li><li>Measure correlation data describing the excitations around that ground state</li><li>Use the correlation data to compute scattering intensities</li></ol><p>As the implementation of the FeI‚ÇÇ model is already covered in detail in the LSWT tutorial, we will not repeat it below. Instead, we will assume that you already have defined a <code>sys</code> in the same way with lattice dimensions <span>$4√ó4√ó4$</span>.</p><pre><code class="language-julia hljs">a = b = 4.05012#hide
c = 6.75214#hide
latvecs = lattice_vectors(a, b, c, 90, 90, 120)#hide
positions = [[0,0,0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]#hide
types = [&quot;Fe&quot;, &quot;I&quot;, &quot;I&quot;]#hide
FeI2 = Crystal(latvecs, positions; types)#hide
cryst = subcrystal(FeI2, &quot;Fe&quot;)#hide
sys = System(cryst, (4,4,4), [SpinInfo(1,S=1,g=2)], :SUN, seed=2)#hide
J1pm   = -0.236#hide
J1pmpm = -0.161#hide
J1zpm  = -0.261#hide
J2pm   = 0.026#hide
J3pm   = 0.166#hide
J‚Ä≤0pm  = 0.037#hide
J‚Ä≤1pm  = 0.013#hide
J‚Ä≤2apm = 0.068#hide
J1zz   = -0.236#hide
J2zz   = 0.113#hide
J3zz   = 0.211#hide
J‚Ä≤0zz  = -0.036#hide
J‚Ä≤1zz  = 0.051#hide
J‚Ä≤2azz = 0.073#hide
J1xx = J1pm + J1pmpm#hide
J1yy = J1pm - J1pmpm#hide
J1yz = J1zpm#hide
set_exchange!(sys, [J1xx 0.0 0.0; 0.0 J1yy J1yz; 0.0 J1yz J1zz], Bond(1,1,[1,0,0]))#hide
set_exchange!(sys, [J2pm 0.0 0.0; 0.0 J2pm 0.0; 0.0 0.0 J2zz], Bond(1,1,[1,2,0]))#hide
set_exchange!(sys, [J3pm 0.0 0.0; 0.0 J3pm 0.0; 0.0 0.0 J3zz], Bond(1,1,[2,0,0]))#hide
set_exchange!(sys, [J‚Ä≤0pm 0.0 0.0; 0.0 J‚Ä≤0pm 0.0; 0.0 0.0 J‚Ä≤0zz], Bond(1,1,[0,0,1]))#hide
set_exchange!(sys, [J‚Ä≤1pm 0.0 0.0; 0.0 J‚Ä≤1pm 0.0; 0.0 0.0 J‚Ä≤1zz], Bond(1,1,[1,0,1]))#hide
set_exchange!(sys, [J‚Ä≤2apm 0.0 0.0; 0.0 J‚Ä≤2apm 0.0; 0.0 0.0 J‚Ä≤2azz], Bond(1,1,[1,2,1]))#hide
D = 2.165#hide
S = spin_operators(sys, 1)#hide
set_onsite_coupling!(sys, -D*S[3]^2, 1)#hide
sys</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Finding-a-ground-state"><a class="docs-heading-anchor" href="#Finding-a-ground-state">Finding a ground state</a><a id="Finding-a-ground-state-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-ground-state" title="Permalink"></a></h2><p>Sunny uses the <a href="https://arxiv.org/abs/2209.01265">Langevin dynamics of SU(<em>N</em>) coherent states</a> to sample spin configurations from the thermal equlibrium. One first constructs a <a href="../../library/#Sunny.Langevin"><code>Langevin</code></a> integrator. This requires a time step, temperature, and a phenomenological damping parameter <span>$Œª$</span> that sets the coupling to the thermal bath.</p><pre><code class="language-julia hljs">Œît = 0.05/D    # Should be inversely proportional to the largest energy scale
               # in the system. For FeI2, this is the easy-axis anisotropy,
               # `D = 2.165` (meV). The prefactor 0.05 is relatively small,
               # and achieves high accuracy.
kT = 0.2       # Temperature of the thermal bath (meV).
Œª = 0.1        # This value is typically good for Monte Carlo sampling,
               # independent of system details.

langevin = Langevin(Œît; kT, Œª);
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Langevin dynamics can be used to search for a magnetically ordered state. For this, the temperature <code>kT</code> must be below the ordering temperature, but large enough that the dynamical sampling procedure can overcome local energy barriers and eliminate defects.</p><pre><code class="language-julia hljs">randomize_spins!(sys)
for _ in 1:20_000
    step!(sys, langevin)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Although thermal fluctuations are present, the correct antiferromagnetic order (2 up, 2 down) is apparent.</p><pre><code class="language-julia hljs">plot_spins(sys; color=[s[3] for s in sys.dipoles])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For other systems, it can be much harder to find the magnetic ordering in an unbiased way, and more complicated sampling procedures may be necessary.</p><h2 id="Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle"><a class="docs-heading-anchor" href="#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle">Calculating Thermal-Averaged Correlations <span>$\langle S^{\alpha\beta}(ùê™,œâ)\rangle$</span></a><a id="Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle" title="Permalink"></a></h2><p>Our aim is to study the classical spin dynamics for states sampled in thermal equilibrium. To minimize finite size effects, and achieve sufficient momentum space resolution, we should significantly enlarge the system volume. The function <a href="../../library/#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>resize_supercell</code></a> takes new dimensions as multiples of the unit cell lattice vectors.</p><pre><code class="language-julia hljs">sys_large = resize_supercell(sys, (16,16,4)) # 16x16x4 copies of the original unit cell
plot_spins(sys_large; color=[s[3] for s in sys_large.dipoles])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Now we will re-thermalize the system to a configuration just above the ordering temperature. Sunny expects energies in meV by default, so we use <code>meV_per_K</code> to convert from kelvin.</p><pre><code class="language-julia hljs">kT = 3.5 * meV_per_K     # 3.5K ‚âà 0.30 meV
langevin.kT = kT
for _ in 1:10_000
    step!(sys_large, langevin)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The next step is to collect correlation data <span>$S^{\alpha\beta}$</span>. This will involve sampling spin configurations from thermal equilibrium, and then integrating the <a href="https://arxiv.org/abs/2204.07563">Hamiltonian dynamics of SU(<em>N</em>) coherent states</a> to collect Fourier-space information about normal modes. Quantization of these modes yields the magnons, and the associated dynamical spin-spin correlations can be compared with neutron scattering intensities <span>$S^{\alpha\beta}(q,\omega)$</span>. Because this a real-space calculation, data is only available for discrete <span>$q$</span> modes (the resolution scales like inverse system size).</p><p>To store the correlation data, we initialize a <code>SampledCorrelations</code> object by calling <a href="../../library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a>. It requires three keyword arguments: an integration step size, a target number of œâs to retain, and a maximum energy œâ to resolve. For the time step, twice the value used for the Langevin integrator is usually a good choice.</p><pre><code class="language-julia hljs">sc = dynamical_correlations(sys_large; Œît=2Œît, nœâ=120, œâmax=7.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The function <a href="../../library/#Sunny.add_sample!-Tuple{SampledCorrelations, System}"><code>add_sample!</code></a> will collect data by running a dynamical trajectory starting from the current system configuration.</p><pre><code class="language-julia hljs">add_sample!(sc, sys_large)        # Accumulate the sample into `sc`</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>To collect additional data, it is required to re-sample the spin configuration from the thermal distribution. For efficiency, the dynamics should be run long enough that consecutive samples are uncorrelated.</p><pre><code class="language-julia hljs">for _ in 1:2
    for _ in 1:1000               # Enough steps to decorrelate spins
        step!(sys_large, langevin)
    end
    add_sample!(sc, sys_large)    # Accumulate the sample into `sc`
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Now, <code>sc</code> has more samples included:</p><pre><code class="language-julia hljs">sc</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Computing-Scattering-Intensities"><a class="docs-heading-anchor" href="#Computing-Scattering-Intensities">Computing Scattering Intensities</a><a id="Computing-Scattering-Intensities-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Scattering-Intensities" title="Permalink"></a></h2><p>With the thermally-averaged correlation data <span>$\langle S^{\alpha\beta}(q,\omega)\rangle$</span> in hand, we now need to specify how to extract a scattering intensity from this information. This is done by constructing an <a href="../../library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>intensity_formula</code></a>. By way of example, we will use a formula which computes the trace of the structure factor and applies a classical-to-quantum temperature-dependent rescaling <code>kT</code>.</p><pre><code class="language-julia hljs">formula = intensity_formula(sc, :trace; kT)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Recall that <span>$\langle S^{\alpha\beta}(q,\omega)\rangle$</span> is only available at certain discrete <span>$q$</span> values, due to the finite lattice size. There are two basic approaches to handling this discreteness. The first approach is to interpolate between the available data using <a href="../../library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. For example, we can plot single-<span>$q$</span> slices at (0,0,0) and (œÄ,œÄ,œÄ) using this method:</p><pre><code class="language-julia hljs">qs = [[0, 0, 0], [0.5, 0.5, 0.5]]
is = intensities_interpolated(sc, qs, formula; interpolation = :round)

œâs = available_energies(sc)
fig = lines(œâs, is[1,:]; axis=(xlabel=&quot;meV&quot;, ylabel=&quot;Intensity&quot;), label=&quot;(0,0,0)&quot;)
lines!(œâs, is[2,:]; label=&quot;(œÄ,œÄ,œÄ)&quot;)
axislegend()
fig</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The resolution in energy can be improved by increasing <code>nœâ</code> (and decreasing <code>Œît</code>), and the general accuracy can be improved by collecting additional samples from the thermal equilibrium.</p><p>For real calculations, one often wants to apply further corrections and more accurate formulas. Here, we apply <a href="../../library/#Sunny.FormFactor-Tuple{String}"><code>FormFactor</code></a> corrections appropriate for <code>Fe2</code> magnetic ions, and a dipole polarization correction <code>:perp</code>.</p><pre><code class="language-julia hljs">formfactors = [FormFactor(&quot;Fe2&quot;; g_lande=3/2)]
new_formula = intensity_formula(sc, :perp; kT, formfactors = formfactors)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Frequently, one wants to extract energy intensities along lines that connect special wave vectors‚Äìa so-called &quot;spaghetti plot&quot;. The function <a href="../../library/#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>reciprocal_space_path</code></a> creates an appropriate horizontal axis for this plot by linearly sampling between provided <span>$q$</span>-points with a given sample density. The number of sample points between two wavevectors <code>q1</code> and <code>q2</code> is given by <code>dist*density</code> where <code>dist = norm(cryst.recipvecs * (q1 - q2))</code> is measured in the global frame.</p><pre><code class="language-julia hljs">points = [[0,   0, 0],  # List of wave vectors that define a path
          [1,   0, 0],
          [0,   1, 0],
          [1/2, 0, 0],
          [0,   1, 0],
          [0,   0, 0]]
density = 40
path, xticks = reciprocal_space_path(cryst, points, density);
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Again using <a href="../../library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>, we can evaluate the (interpolated) intensity at each point on the <code>path</code>. Since scattering intensities are only available at a certain discrete <span>$(Q,\omega)$</span> points, the intensity on the path can be calculated by interpolating between these discrete points:</p><pre><code class="language-julia hljs">is_interpolated = intensities_interpolated(sc, path, new_formula;
    interpolation = :linear,       # Interpolate between available wave vectors
);
# Add artificial broadening
is_interpolated_broadened = broaden_energy(sc, is, (œâ, œâ‚ÇÄ)-&gt;lorentzian(œâ-œâ‚ÇÄ, 0.05));
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The second approach to handle the discreteness of the data is to bin the intensity at the discrete points into the bins of a histogram. First, the five sub-histograms are set up using <a href="../../library/#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}"><code>reciprocal_space_path_bins</code></a> in analogy to <code>reciprocal_space_path</code>.</p><pre><code class="language-julia hljs">cut_width = 0.3
density = 15
paramsList, markers, ranges = reciprocal_space_path_bins(sc,points,density,cut_width);
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Then, the intensity data is computed using <a href="../../library/#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a> for each sub-histogram:</p><pre><code class="language-julia hljs">total_bins = ranges[end][end]
energy_bins = paramsList[1].numbins[4]
is_binned = zeros(Float64,total_bins,energy_bins)
integrated_kernel = integrated_lorentzian(0.05) # Lorentzian broadening
for k in eachindex(paramsList)
    bin_data, counts = intensities_binned(sc,paramsList[k], new_formula;
        integrated_kernel = integrated_kernel
    )
    is_binned[ranges[k],:] = bin_data[:,1,1,:] ./ counts[:,1,1,:]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The graph produced by interpolating (top) is similar to the one produced by binning (bottom):</p><pre><code class="language-julia hljs">fig = Figure()
ax_top = Axis(fig[1,1],ylabel = &quot;meV&quot;,xticklabelrotation=œÄ/8,xticklabelsize=12;xticks)
ax_bottom = Axis(fig[2,1],ylabel = &quot;meV&quot;,xticks = (markers, string.(points)),xticklabelrotation=œÄ/8,xticklabelsize=12)

heatmap!(ax_top,1:size(is_interpolated,1), œâs, is_interpolated;
    colorrange=(0.0,0.07),
)

heatmap!(ax_bottom,1:size(is_binned,1), œâs, is_binned;
    colorrange=(0.0,0.05),
)

fig</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Note that we have clipped the colors in order to make the higher-energy excitations more visible.</p><h1 id="Unconventional-RLU-Systems-and-Constant-Energy-Cuts"><a class="docs-heading-anchor" href="#Unconventional-RLU-Systems-and-Constant-Energy-Cuts">Unconventional RLU Systems and Constant Energy Cuts</a><a id="Unconventional-RLU-Systems-and-Constant-Energy-Cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Unconventional-RLU-Systems-and-Constant-Energy-Cuts" title="Permalink"></a></h1><p>Often it is useful to plot cuts across multiple wave vectors but at a single energy. We&#39;ll pick an energy,</p><pre><code class="language-julia hljs">œâidx = 60
target_œâ = œâs[œâidx]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>and take a constant-energy cut at that energy. The most straightforward way is to make a plot whose axes are aligned with the conventional reciprocal lattice of the crystal. This is accomplished using <a href="../../library/#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}"><code>unit_resolution_binning_parameters</code></a>:</p><pre><code class="language-julia hljs">params = unit_resolution_binning_parameters(sc)
params.binstart[1:2] .= -1 # Expand plot range slightly

# Set energy integration range
omega_width = 0.3
params.binstart[4] = target_œâ - (omega_width/2)
params.binend[4] = target_œâ # `binend` should be inside (e.g. at the center) of the range
params.binwidth[4] = omega_width

integrate_axes!(params, axes = 3) # Integrate out z direction entirely

params</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>In each of the following plots, black dashed lines represent (direct) lattice vectors. Since these plots are in reciprocal space, direct lattice vectors are represented as covectors (i.e. coordinate grids) instead of as arrows.</p><pre><code class="language-julia hljs">is, counts = intensities_binned(sc,params,new_formula)

fig = Figure()
ax = Axis(fig[1,1];
    title=&quot;Œîœâ=0.3 meV (Binned)&quot;, aspect=true,
    xlabel = &quot;[H, 0, 0]&quot;,
    ylabel = &quot;[0, K, 0]&quot;
)
bcs = axes_bincenters(params)
hm = heatmap!(ax,bcs[1],bcs[2],is[:,:,1,1] ./ counts[:,:,1,1])
function add_lines!(ax,params)#hide
  bes = Sunny.axes_binedges(params)#hide
  hrange = range(-2,2,length=17)#hide
  linesegments!(ax,[(Point2f(params.covectors[1,1:3] ‚ãÖ [h,-10,0],params.covectors[2,1:3] ‚ãÖ [h,-10,0]),Point2f(params.covectors[1,1:3] ‚ãÖ [h,10,0],params.covectors[2,1:3] ‚ãÖ [h,10,0])) for h = hrange],linestyle=:dash,color=:black)#hide
  krange = range(-2,2,length=17)#hide
  linesegments!(ax,[(Point2f(params.covectors[1,1:3] ‚ãÖ [-10,k,0],params.covectors[2,1:3] ‚ãÖ [-10,k,0]),Point2f(params.covectors[1,1:3] ‚ãÖ [10,k,0],params.covectors[2,1:3] ‚ãÖ [10,k,0])) for k = krange],linestyle=:dash,color=:black)#hide
  xlims!(ax,bes[1][1],bes[1][end])#hide
  ylims!(ax,bes[2][1],bes[2][end])#hide
end#hide
add_lines!(ax,params)
Colorbar(fig[1,2], hm);
fig</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>In the above plot, the dashed-line (direct) lattice vectors are clearly orthogonal. However, we know that in real space, the lattice vectors <span>$a$</span> and <span>$b$</span> are <em>not</em> orthogonal, but rather point along the edges of a hexagon (see lower left corner):</p><br><img src="https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_crystal.jpg" width="400"><br><p>Thus, plotting the direct lattice vectors as orthogonal (even in reciprocal space) is somewhat misleading. Worse yet, the <code>[H,0,0]</code> by <code>[0,K,0]</code> plot apparently loses the 6-fold symmetry of the crystal! Lastly, if one works out the components of the real-space metric with respect to the axes of the plot, one finds that there are non-zero off-diagonal entries,</p><pre><code class="language-julia hljs">latvecs = sys.crystal.latvecs
metric = latvecs&#39; * I(3) * latvecs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>so real-space rotations and angles map into reciprocal space rotations angles in a complicated way.</p><p>To resolve these important issues, we want to use axes which are orthogonal (i.e. they diagonalize the metric and solve all of the problems just mentioned). The canonical choice is to use the combination <span>$\frac{1}{2}a + b$</span> of lattice vectors (equiv. <span>$a^* - \frac{1}{2}b^*$</span>), which is orthogonal to <span>$a$</span>:</p><pre><code class="language-julia hljs">(latvecs * [1/2,1,0]) ‚ãÖ (latvecs * [1,0,0]) == 0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>This new vector <span>$\frac{1}{2}a+b$</span> is visibly orthogonal to <span>$a$</span> in real space:</p><pre><code class="language-julia hljs">f = Figure()#hide
ax = Axis(f[1,1])#hide
arrows!(ax,[Point2f(0,0),Point2f(latvecs[1:2,1] ./ 2)],[Vec2f(latvecs[1:2,1] ./ 2), Vec2f(latvecs[1:2,2])],arrowcolor = :blue,arrowsize = 30.,linewidth = 5.,linecolor = :blue)#hide
arrows!(ax,[Point2f(0,0)],[Vec2f(latvecs[1:2,:] * [1/2,1,0])],arrowcolor = :red,arrowsize = 30.,linewidth = 5.,linecolor = :red, linestyle = :dash)#hide
scatter!(ax,[Point2f(latvecs[1:2,:] * [a,b,0]) for a in -1:1, b in -1:1][:],color = :black)#hide
annotations!(ax,[&quot;0&quot;,&quot;0+b&quot;,&quot;0+a&quot;, &quot;a/2&quot;, &quot;b&quot;],[Point2f(0,-0.3),Point2f(latvecs[1:2,2]) .- Vec2f(0,0.3),Point2f(latvecs[1:2,1]) .- Vec2f(0,0.3),Point2f(latvecs[1:2,1] ./ 4) .- Vec2f(0,0.3),Point2f(latvecs[1:2,1] ./ 2) .+ Vec2f(latvecs[1:2,2] ./ 2) .+ Vec2f(0.3,0.3)],color=[:black,:black,:black,:blue,:blue])#hide
f#hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>To use &quot;projection onto the new vector&quot; as a histogram axis, only a single change is needed to the binning parameters. The second covector (previously <span>$b$</span>) must be swapped out for <span>$\frac{1}{2}a + b$</span> (recall that reciprocal space covectors, such as those used in <a href="../../library/#Sunny.BinningParameters"><code>BinningParameters</code></a> correspond to direct space vectors).</p><pre><code class="language-julia hljs">params.covectors[2,1:3] = [1/2,1,0] # [1/2,1,0] times [a;b;c] is (a/2 + b)
params#hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The second axis of the histogram now agrees with what is conventionally labelled as <code>[H,-H/2,0]</code>.</p><div class="admonition is-warning"><header class="admonition-header">Length of the new vector</header><div class="admonition-body"><p>Note that, although <span>$\frac{1}{2}a+b$</span> is orthogonal to <span>$a$</span>, it is not the same length as <span>$a$</span>. Instead, it is <code>sqrt(3/4)</code> times as long. Note the unsymmetrical axes labels in the plots that follow as a direct result of this!</p></div></div><pre><code class="language-julia hljs"># Zoom out horizontal axis
params.binstart[1], params.binend[1] = -2, 2

# Adjust vertical axis bounds to account for
# length of a/2 + b
params.binstart[2], params.binend[2] = -2 * sqrt(3/4), 2 * sqrt(3/4)

# Re-compute in the new coordinate system
is, counts = intensities_binned(sc,params,new_formula)

fig = Figure(; resolution=(1200,500))#hide
ax_right = Axis(fig[1,3];#hide
    title=&quot;œâ‚âà$(round(target_œâ, digits=2)) meV with Œîœâ=0.3 meV (Binned)&quot;, aspect=true,#hide
    xlabel = &quot;[H, -1/2H, 0]&quot;#hide
)#hide
bcs = axes_bincenters(params)#hide
hm_right = heatmap!(ax_right,bcs[1],bcs[2],is[:,:,1,1] ./ counts[:,:,1,1])#hide
add_lines!(ax_right,params)
Colorbar(fig[1,4], hm_right);#hide
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For comparison purposes, we will make the same plot using <a href="../../library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a> to emulate zero-width bins. This time, it&#39;s more convenient to think in terms of reciprocal vectors <span>$a^*$</span> and <span>$b^*$</span>. Now, our coordinate transformation consists of establishing a new, orthogonal basis to specify our wave vectors: <span>$a^* - \frac{1}{2}b^*$</span>, <span>$b^*$</span> and <span>$c^*$</span>. Writing this in matrix form allows us to sample a rectilinear grid of wave vectors in this frame. Finally, we&#39;ll convert these back into the original RLU system for input into Sunny.</p><pre><code class="language-julia hljs"># New basis matrix
A = [1    0 0
     -1/2 1 0
     0    0 1]

# Define our grid of wave vectors
npoints = 60
as = range(-2, 2, npoints)
bs = range(-3/‚àö3, 3/‚àö3, npoints)
qs_ortho = [[a, b, 0] for a in as, b in bs]

# Convert to original RLU system for input to Sunny
qs = [A * q for q in qs_ortho]

# Use interpolation to get intensities
is = intensities_interpolated(sc, qs, new_formula; interpolation=:linear)

ax_left = Axis(fig[1,2];#hide
    title=&quot;œâ‚âà$(round(œâs[œâidx], digits=2)) meV (Interpolated)&quot;, aspect=true,#hide
    xlabel = &quot;[H, -1/2H, 0]&quot;, ylabel = &quot;[0, K, 0]&quot;#hide
)#hide
hm_left = heatmap!(ax_left, as, bs, is[:,:,œâidx])#hide
add_lines!(ax_left,params)
Colorbar(fig[1,1], hm_left);#hide
fig</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Now, not only are the dashed-line lattice vectors no longer misleadingly orthogonal, but the six-fold symmetry has been restored as well! Further, the metric has been diagonalized:</p><pre><code class="language-julia hljs">metric = (latvecs * inv(A&#39;))&#39; * I(3) * (latvecs * inv(A&#39;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Finally, we note that instantaneous structure factor data, <span>$ùíÆ(ùê™)$</span>, can be obtained from a dynamic structure factor with <a href="../../library/#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a>. Here we&#39;ll reuse the grid of wave vectors we generated above.</p><pre><code class="language-julia hljs">is_static = instant_intensities_interpolated(sc, qs, new_formula; interpolation = :linear)

hm = heatmap(as, bs, is_static;
    axis=(
        title=&quot;Instantaneous Structure Factor&quot;,
        xlabel = &quot;[H, -1/2H, 0]&quot;,
        ylabel = &quot;[0, K, 0]&quot;,
        aspect=true
    )
)
Colorbar(hm.figure[1,2], hm.plot)
hm</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powder_averaging/">¬´ Powder Averaged CoRh‚ÇÇO‚ÇÑ</a><a class="docs-footer-nextpage" href="../ising2d/">Classical Ising model ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Monday 25 September 2023 04:14">Monday 25 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
