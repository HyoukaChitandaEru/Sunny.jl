var documenterSearchIndex = {"docs":
[{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"EditURL = \"../../../examples/fei2_tutorial.jl\"","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"<a href=\"../../assets/notebooks/fei2_tutorial.ipynb\" download>Download as a Jupyter notebook</a>","category":"page"},{"location":"examples/fei2_tutorial/#Case-Study:-FeI_{2}","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"FeI_2 is an effective spin-1 material with strong single-ion anisotropy. Quadrupolar fluctuations give rise to a single-ion bound state that cannot be described by a dipole-only model. This tutorial illustrates how to use the linear spin wave theory of SU(3) coherent states (i.e. 2-flavor bosons) to model the magnetic behavior in FeI_2. The original study was performed in Bai et al., Nature Physics 17, 467‚Äì472 (2021).","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_crystal.jpg\" style=\"float: left;\" width=\"400\">","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The Fe atoms are arranged in stacked triangular layers. The effective spin interactions include various anisotropic exchange interactions, and a strong single-ion anisotropy:","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"mathcalH=sum_(ij) J^alphabeta_ij S^alpha_i S^beta_j - Dsum_i left(S^zright)^2","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"We will formulate this Hamiltonian in Sunny and then calculate its dynamic structure factor.","category":"page"},{"location":"examples/fei2_tutorial/#Get-Julia-and-Sunny","page":"Case Study: FeI_2","title":"Get Julia and Sunny","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Sunny is implemented in Julia. This is a relatively new programming language that allows for interactive development (like Python or Matlab) while also providing high numerical efficiency (like C++ or Fortran). New Julia users may wish to take a look at our Getting Started with Julia guide. Sunny requires Julia 1.9 or later.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"From the Julia prompt, load Sunny. For plotting, one can choose either GLMakie (a pop-up window) or WGLMakie (inline plots for a Jupyter notebook or VSCode).","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"using Sunny, GLMakie","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"If these packages are not yet installed, Julia should offer to install them using its built-in package management system. If old versions are installed, you may need to update them to run this tutorial.","category":"page"},{"location":"examples/fei2_tutorial/#Crystals","page":"Case Study: FeI_2","title":"Crystals","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A Crystal describes the crystallographic unit cell and will usually be loaded from a .cif file. Here, we instead build a crystal by listing all atoms and their types.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"a = b = 4.05012  # Lattice constants for triangular lattice\nc = 6.75214      # Spacing in the z-direction\n\nlatvecs = lattice_vectors(a, b, c, 90, 90, 120) # A 3x3 matrix of lattice vectors that\n                                                # define the conventional unit cell\npositions = [[0, 0, 0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]  # Positions of atoms in fractions\n                                                           # of lattice vectors\ntypes = [\"Fe\", \"I\", \"I\"]\nFeI2 = Crystal(latvecs, positions; types)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Observe that Sunny inferred the space group, 'P -3 m 1' (164) and labeled the atoms according to their point group symmetries.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Only the Fe atoms are magnetic, so we discard the I ions using subcrystal.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"cryst = subcrystal(FeI2, \"Fe\")","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Importantly, cryst retains the spacegroup symmetry of the full FeI_2 crystal. This information will be used, for example, to propagate exchange interactions between symmetry-equivalent bonds.","category":"page"},{"location":"examples/fei2_tutorial/#Symmetry-analysis","page":"Case Study: FeI_2","title":"Symmetry analysis","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The command print_symmetry_table provides a list of all the symmetry-allowed interactions up to a cutoff distance.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"print_symmetry_table(cryst, 8.0)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The allowed g-tensor is expressed as a 3√ó3 matrix in the free coefficients A, B, ... The allowed single-ion anisotropy is expressed as a linear combination of Stevens operators. The latter correspond to polynomials of the spin operators, as we will describe below.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The allowed exchange interactions are given as a 3√ó3 matrix for representative bonds. The notation Bond(i, j, n) indicates a bond between atom indices i and j, with cell offset n. In the general case, it will be necessary to associate atom indices with their positions in the unit cell; these can be viewed with display(cryst). Note that the order of the pair (i j) is significant if the exchange tensor contains antisymmetric Dzyaloshinskii‚ÄìMoriya (DM) interactions.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In the case of FeI_2, Bond(1, 1, [1,0,0]) is one of the 6 nearest-neighbor Fe-Fe bonds on a triangular lattice layer, and Bond(1, 1, [0,0,1]) is an Fe-Fe bond between layers.","category":"page"},{"location":"examples/fei2_tutorial/#Building-a-spin-System","page":"Case Study: FeI_2","title":"Building a spin System","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In constructing a spin System, we must provide several additional details about the spins.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys = System(cryst, (4,4,4), [SpinInfo(1, S=1, g=2)], :SUN, seed=2)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"This system includes 444 unit cells, i.e. 64 Fe atoms, each with spin S=1 and a g-factor of 2. Quantum mechanically, spin S=1 involves a superposition of 2S+1=3 distinct angular momentum states. In :SUN mode, this superposition will be modeled explicitly using the formalism of SU(3) coherent states, which captures both dipolar and quadrupolar fluctuations. For the more traditional dipole dynamics, use :dipole mode instead.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Next we will use set_exchange! to assign interaction to bonds. Sunny will automatically propagate each interaction to all symmetry-equivalent bonds in the unit cell. The FeI_2 interactions below follow Bai et al.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"J1pm   = -0.236\nJ1pmpm = -0.161\nJ1zpm  = -0.261\nJ2pm   = 0.026\nJ3pm   = 0.166\nJ‚Ä≤0pm  = 0.037\nJ‚Ä≤1pm  = 0.013\nJ‚Ä≤2apm = 0.068\n\nJ1zz   = -0.236\nJ2zz   = 0.113\nJ3zz   = 0.211\nJ‚Ä≤0zz  = -0.036\nJ‚Ä≤1zz  = 0.051\nJ‚Ä≤2azz = 0.073\n\nJ1xx = J1pm + J1pmpm\nJ1yy = J1pm - J1pmpm\nJ1yz = J1zpm\n\nset_exchange!(sys, [J1xx   0.0    0.0;\n                    0.0    J1yy   J1yz;\n                    0.0    J1yz   J1zz], Bond(1,1,[1,0,0]))\nset_exchange!(sys, [J2pm   0.0    0.0;\n                    0.0    J2pm   0.0;\n                    0.0    0.0    J2zz], Bond(1,1,[1,2,0]))\nset_exchange!(sys, [J3pm   0.0    0.0;\n                    0.0    J3pm   0.0;\n                    0.0    0.0    J3zz], Bond(1,1,[2,0,0]))\nset_exchange!(sys, [J‚Ä≤0pm  0.0    0.0;\n                    0.0    J‚Ä≤0pm  0.0;\n                    0.0    0.0    J‚Ä≤0zz], Bond(1,1,[0,0,1]))\nset_exchange!(sys, [J‚Ä≤1pm  0.0    0.0;\n                    0.0    J‚Ä≤1pm  0.0;\n                    0.0    0.0    J‚Ä≤1zz], Bond(1,1,[1,0,1]))\nset_exchange!(sys, [J‚Ä≤2apm 0.0    0.0;\n                    0.0    J‚Ä≤2apm 0.0;\n                    0.0    0.0    J‚Ä≤2azz], Bond(1,1,[1,2,1]))","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function set_onsite_coupling! assigns a single-ion anisotropy operator. It can be constructed, e.g., from the matrices given by spin_operators or stevens_operators. Here we construct an easy-axis anisotropy along the direction hatz.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"D = 2.165\nS = spin_operators(sys, 1)\nset_onsite_coupling!(sys, -D*S[3]^2, 1)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Any anisotropy operator can be converted to a linear combination of Stevens operators with print_stevens_expansion.","category":"page"},{"location":"examples/fei2_tutorial/#Calculating-structure-factor-intensities","page":"Case Study: FeI_2","title":"Calculating structure factor intensities","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In the remainder of this tutorial, we will examine Sunny's tools for calculating the dynamical structure factor using a multi-boson generalization of linear spin wave theory (LSWT). This theory describes non-interacting quasi-particle excitations that hybridize dipolar and quadrupolar modes.","category":"page"},{"location":"examples/fei2_tutorial/#Finding-the-ground-state","page":"Case Study: FeI_2","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Begin with a random configuration and use minimize_energy! to find a configuration of the SU(3) coherent states (i.e. spin dipoles and quadrupoles) that locally minimizes energy.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"randomize_spins!(sys)\nminimize_energy!(sys);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The expected ground state for FeI_2 is an antiferrogmanetic striped phase with a period of four spins (two up, two down). Visualizing the result of optimization, however, may indicate the system got stuck in a local minimum with defects.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"plot_spins(sys)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A better understanding of the magnetic ordering can often be obtained by moving to Fourier space. The 'instant' structure factor ùíÆ(ùê™) is an experimental observable. To investigate ùíÆ(ùê™) as true 3D data, Sunny provides instant_correlations and related functions. Here, however, we will use the lighter weight function print_wrapped_intensities to get a quick understanding of the periodicities present in the spin configuration.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"print_wrapped_intensities(sys)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The precise output may vary with Sunny version due to, e.g., different floating point roundoff effects. Very likely, however, the result will be approximately consistent with the known zero-field energy-minimizing magnetic structure of FeI_2, which is single-Q. Mathematically, spontaneous symmetry breaking should select one of Q = 0 -14 14, 14 0 14, or -141414, associated with the three-fold rotational symmetry of the crystal spacegroup. In practice, however, one will frequently encounter competing \"domains\" associated with the three possible orientations of the ground state.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"If the desired ground state is already known, as with FeI_2, it could be entered by hand using set_dipole!. Alternatively, in the case of FeI_2, we could repeatedly employ the above randomization and minimization procedure until a defect-free configuration is found. Some systems will have more complicated ground states, which can be much more challenging to find. For this, Sunny provides experimental support for powerful simulated annealing via parallel tempering, but that is outside the scope of this tutorial.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Here, let's break the three-fold symmetry of FeI_2 by hand. Given one or more desired Q modes, Sunny can suggest a magnetic supercell with appropriate periodicity. Let's arbitrarily select one of the three possible ordering wavevectors, Q = 0 -14 14. Sunny suggest a corresponding magnetic supercell in units of the crystal lattice vectors.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"suggest_magnetic_supercell([[0, -1/4, 1/4]], sys.latsize)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function reshape_supercell allows an arbitrary reshaping of the system's supercell. We select the supercell appropriate to the broken-symmetry ground-state, which makes optimization much easier.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys_min = reshape_supercell(sys, [1 0 0; 0 1 -2; 0 1 2])\nrandomize_spins!(sys_min)\nminimize_energy!(sys_min)\nplot_spins(sys_min; ghost_radius=3)","category":"page"},{"location":"examples/fei2_tutorial/#Linear-spin-wave-theory","page":"Case Study: FeI_2","title":"Linear spin wave theory","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Now that we have found the ground state for a magnetic supercell, we can immediately proceed to perform zero-temperature calculations using linear spin wave theory. We begin by instantiating a SpinWaveTheory type using the supercell.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"swt = SpinWaveTheory(sys_min)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Select a sequence of wavevectors that will define a piecewise linear interpolation in reciprocal lattice units (RLU).","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"q_points = [[0,0,0], [1,0,0], [0,1,0], [1/2,0,0], [0,1,0], [0,0,0]];\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function reciprocal_space_path will linearly sample a path between the provided q-points with a given density. The xticks return value provides labels for use in plotting.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"density = 50\npath, xticks = reciprocal_space_path(cryst, q_points, density);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The dispersion function defines the quasiparticle excitation energies œâ_i(ùê™) for each point ùê™ along the reciprocal space path.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"disp = dispersion(swt, path);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In addition to the band energies œâ_i(ùê™), Sunny can calculate the inelastic neutron scattering intensity I_i(ùê™) for each band i according to an intensity_formula. We choose to apply a polarization correction (1 - ùê™ùê™) by setting the mode argument to :perp. Selecting delta_function_kernel specifies that we want the energy and intensity of each band individually.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"formula = intensity_formula(swt, :perp; kernel=delta_function_kernel)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function intensities_bands uses linear spin wave theory to calculate both the dispersion and intensity data for the provided path.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"disp, intensity = intensities_bands(swt, path, formula);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"These can be plotted in GLMakie.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"fig = Figure()\nax = Axis(fig[1,1]; xlabel=\"ùê™\", ylabel=\"Energy (meV)\", xticks, xticklabelrotation=œÄ/6)\nylims!(ax, 0.0, 7.5)\nxlims!(ax, 1, size(disp, 1))\ncolorrange = extrema(intensity)\nfor i in axes(disp)[2]\n    lines!(ax, 1:length(disp[:,i]), disp[:,i]; color=intensity[:,i], colorrange)\nend\nfig","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"To make comparisons with inelastic neutron scattering (INS) data, it is helpful to employ an empirical broadening kernel, e.g., a lorentzian.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Œ≥ = 0.15 # width in meV\nbroadened_formula = intensity_formula(swt, :perp; kernel=lorentzian(Œ≥))","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The intensities_broadened function requires an energy range in addition to the ùê™-space path.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"energies = collect(0:0.01:10)  # 0 < œâ < 10 (meV).\nis1 = intensities_broadened(swt, path, energies, broadened_formula);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A real FeI_2 sample will exhibit competing magnetic domains associated with spontaneous symmetry breaking of the 6-fold rotational symmetry of the triangular lattice. Note that the wavevectors ùê™ and -ùê™ are equivalent in the structure factor, which leaves three distinct domain orientations, which are related by 120¬∞ rotations about the z-axis. Rather than rotating the spin configuration directly, on can rotate the ùê™-space path. Below, we use rotation_in_rlu to average the intensities over all three possible orientations.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"R = rotation_in_rlu(cryst, [0, 0, 1], 2œÄ/3)\nis2 = intensities_broadened(swt, [R*q for q in path], energies, broadened_formula)\nis3 = intensities_broadened(swt, [R*R*q for q in path], energies, broadened_formula)\nis_averaged = (is1 + is2 + is3) / 3\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel=\"(H,0,0)\", ylabel=\"Energy (meV)\", xticks, xticklabelrotation=œÄ/6)\nheatmap!(ax, 1:size(is_averaged, 1), energies, is_averaged)\nfig","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"This result can be directly compared to experimental neutron scattering data from Bai et al.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_intensity.jpg\">","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(The publication figure accidentally used a non-standard coordinate system to label the wave vectors.)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"To get this agreement, the use of SU(3) coherent states is essential. In other words, we needed a theory of multi-flavored bosons. The lower band has large quadrupolar character, and arises from the strong easy-axis anisotropy of FeI_2. By setting mode = :SUN, the calculation captures this coupled dipole-quadrupole dynamics.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"An interesting exercise is to repeat the same study, but using mode = :dipole instead of :SUN. That alternative choice would constrain the coherent state dynamics to the space of dipoles only.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The full dynamical spin structure factor (DSSF) can be retrieved as a 33 matrix with the dssf function, for a given path of ùê™-vectors.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"disp, is = dssf(swt, path);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The first output disp is identical to that obtained from dispersion. The second output is contains a list of 33 matrix of intensities. For example, is[q,n][2,3] yields the (yz) component of the structure factor intensity for nth mode at the qth wavevector in the path.","category":"page"},{"location":"examples/fei2_tutorial/#What's-next?","page":"Case Study: FeI_2","title":"What's next?","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The multi-boson linear spin wave theory, applied above, can be understood as the quantization of a certain generalization of the Landau-Lifshitz spin dynamics. Rather than dipoles, this dynamics takes places on the space of SU(N) coherent states.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The full SU(N) coherent state dynamics, with appropriate quantum correction factors, can be useful to model finite temperature scattering data. In particular, it captures certain anharmonic effects due to thermal fluctuations. This is the subject of our Structure Factors with Classical Dynamics tutorial.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The classical dynamics is also a good starting point to study non-equilibrium phenomena. Empirical noise and damping terms can be used to model coupling to a thermal bath. This yields a Langevin dynamics of SU(N) coherent states. Our CP^2 Skyrmion Quench tutorial shows how this dynamics gives rise to the formation of novel topological defects in a temperature quench.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Relative to LSWT calculations, it can take much more time to estimate mathcalS(ùê™œâ) intensities using classical dynamics simulation. See the SunnyTutorials notebooks for examples of \"production-scale\" simulations.","category":"page"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/#Overview","page":"Structure Factor Calculations","title":"Overview","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The dynamical structure factor is of fundamental importance for characterizing a magnetic system, and facilitates quantitative comparison between theory and experimental scattering data.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider, for example, a two-point dynamical spin correlation function, s^Œ±(ùê±+Œîùê± t+Œît) s^Œ≤(ùê± t). Here s^Œ±(ùê± t) represents the time dynamics of a spin dipole component Œ± at position ùê±, and brackets represent an average over equilibrium initial conditions and over (ùê± t). The dynamical structure factor is defined as the Fourier transform of this two-point correlation in both space and time, up to an overall scaling factor. Using the convolution theorem, the result is,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = frac1V s^Œ±(ùê™ œâ)^ast s^Œ≤(ùê™ œâ) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"with V the system volume. We will restrict attention to lattice systems with periodic boundaries.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider a crystal unit cell defined by three lattice vectors ùêö_1 ùêö_2 ùêö_3, and linear system sizes L_1 L_2 L_3 measured in unit cells. The allowed momentum vectors take on discrete values ùê™ = sum_Œ±=1^3 m_Œ± ùêõ_Œ±  L_Œ±, where m_Œ± are an integers and the reciprocal lattice vectors ùêõ_Œ± are defined to satisfy ùêö_Œ±  ùêõ_Œ≤ = 2œÄ Œ¥_Œ±Œ≤. For a Bravais lattice, ùê™ will be periodic in the first Brillouin zone, i.e., under any shift ùê™  ùê™  ùêõ_Œ±. More generally, consider a non-Bravais lattice such that each unit cell may contain multiple spins. By partitioning spins s_j(ùê±t) according to their sublattice index j, the relevant momenta ùê™ remain discretized as above, but now periodicity in the first Brillouin zone is lost. The structure factor may be written as a phase-average over the displacements between sublattices ùê´_jk,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = _jk e^i ùê´_jk  ùê™ ùíÆ^Œ±Œ≤_jk(ùê™ œâ) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"From a theoretical perspective, the quantity","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = frac1V s_j^Œ±(ùê™ œâ)^ast s_k^Œ≤(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"is fundamental. For each sublattice j, the data s_j^Œ±(ùê™ œâ) can be efficiently obtained by fast Fourier tranformation of a real space configuration s_j^Œ±(ùê± t). Internally, Sunny will calculate and store the discrete ùíÆ^Œ±Œ≤_jk(ùê™ œâ) correlation data, and use this to construct ùíÆ^Œ±Œ≤(ùê™œâ) intensities that can be compared with experiment.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Calculating this structure factor involves several steps, with various possible settings. Sunny provides a number of tools to facilitate this calculation and to extract information from the results. These tools are briefly outlined below. Please see the Examples for a \"real life\" use case. Detailed function information is available in the Library API.","category":"page"},{"location":"structure-factor/#Estimating-stucture-factors-with-classical-dynamics","page":"Structure Factor Calculations","title":"Estimating stucture factors with classical dynamics","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Classical dynamics may be used to estimate structure factor data by analyzing the spin-spin correlations of dynamical trajectories. This is fundamentally a Monte Carlo approach, as the trajectories must be started from an initial spin configuration that is sampled at thermal equilibrium. (Note that it is not possible to estimate a true T=0 dynamical structure factor using this method, but the temperature may be very low.) Samples are accumulated into a SampledCorrelations, from which intensity information may be extracted. The user does not typically build their own SampledCorrelations but instead initializes one by calling either dynamical_correlations or instant_correlations, as described below.","category":"page"},{"location":"structure-factor/#Estimating-a-dynamical-structure-factor:-ùíÆ(ùê™,œâ)","page":"Structure Factor Calculations","title":"Estimating a dynamical structure factor: ùíÆ(ùê™œâ)","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A SampledCorrelations for estimating the dynamical structure factor, ùíÆ^Œ±Œ≤(ùê™œâ), may be created by calling dynamical_correlations. This requires three keyword arguments. These will determine the dynamics used to calculate samples and, consequently, the œâ information that will be available. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Œît: Determines the step size used for simulating the dynamics. A smaller number will require proportionally more calculation time. While a smaller Œît will enable the resolution of higher energies, Œît is typically selected to ensure numerical stability rather than to maximize the largest œâ value. A safe choice is to use the smaller value of Œît = 0.1/(J* S^2) or Œît = 0.1/(D * S), where S is magnetic moment of the largest local spin (as specified in SpinInfo), J is the parameter governing the largest bilinear interaction (e.g. exchange), and D is the parameter governing the largest single-site term of the Hamiltonian (e.g., anisotropy or Zeeman term).\nœâmax: Sets the maximum resolved energy. Note that this is not independent of Œît. If œâmax too large, Sunny will throw an error and ask you to choose a smaller Œît. \nnœâ: Determines the number of energy bins to resolve. A larger number will require more calculation time.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A sample may be added by calling add_sample!(sc, sys). The input sys must be a spin configuration in good thermal equilibrium, e.g., using the continuous Langevin dynamics or using single spin flip trials with LocalSampler. The statistical quality of the ùíÆ^Œ±Œ≤(ùê™œâ) can be improved by repeatedly generating decorrelated spin configurations in sys and calling add_sample! on each configuration.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The outline of typical use case might look like this:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"# Make a `SampledCorrelations`\nsc = dynamical_correlations(sys; Œît=0.05, œâmax=10.0, nœâ=100) \n\n# Add samples\nfor _ in 1:nsamples\n   decorrelate_system(sys) # Perform some type of Monte Carlo simulation\n   add_sample!(sc, sys)    # Use spins to calculate trajectory and accumulate new sample of ùíÆ(ùê™,œâ)\nend","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The calculation may be configured in a number of ways; see the dynamical_correlations documentation for a list of all keywords.","category":"page"},{"location":"structure-factor/#Estimating-an-instantaneous-(\"static\")-structure-factor:-ùíÆ(ùê™)","page":"Structure Factor Calculations","title":"Estimating an instantaneous (\"static\") structure factor: ùíÆ(ùê™)","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Sunny provides two methods for calculating instantaneous, or static, structure factors: ùíÆ^Œ±Œ≤(ùê™). The first involves calculating spatial spin-spin correlations at single time slices. The second involves calculating a dynamic structure factor first and integrating out the œâ information. The advantage of the latter approach is that it enables application of an œâ-dependent classical-to-quantum rescaling of structure factor intensities, a method that should be preferred whenever comparing results to experimental data or spin wave calculations. A disadvantage of this approach is that it is computationally more expensive. There are also many cases when it is not straightforward to calculate a meaningful dynamics, as when working with Ising spins. In this section we will discuss how to calculate instantaneous structure factors from static spin configurations. Information about calculating instantaneous data from a dynamical correlations can be found in the following section.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic usage for the instantaneous case is very similar to the dynamic case, except one calls instant_correlations instead of dynamical_correlations to configure a SampledCorrelations. Note that there are no required keywords as there is no need to specify any dynamics. instant_correlations will return a SampledCorrelations containing no data. Samples may be added by calling add_sample!(sc, sys), where sc is the SampledCorrelations. When performing a finite-temperature calculation, it is important to ensure that the spin configuration in the sys represents a good equilibrium sample, as in the dynamical case. Note, however, that we recommend calculating instantaneous correlations at finite temperature calculations by using full dynamics (i.e., using dynamical_correlations) and then integrating out the energy axis. An approach to doing this is described in the next section.","category":"page"},{"location":"structure-factor/#Extracting-information-from-sampled-correlation-data","page":"Structure Factor Calculations","title":"Extracting information from sampled correlation data","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic function for extracting information from a SampledCorrelations at a particular wave vector, ùê™, is intensities_interpolated. It takes a SampledCorrelations, a list of wave vectors, and an intensity_formula. The intensity_formula specifies how to contract and correct correlation data to arrive at a physical intensity. A simple example is formula = intensity_formula(sc, :perp), which will instruct Sunny apply polarization corrections: sum_Œ±Œ≤(I-q_Œ± q_Œ≤) ùíÆ^Œ±Œ≤(ùê™œâ). An intensity at the wave vector ùê™ = (ùêõ_2 + ùêõ_3)2 may then be retrieved with  intensities_interpolated(sf, [[0.0, 0.5, 0.5]], formula) .  intensities_interpolated returns a list of nœâ elements at each wavevector. The corresponding œâ values can be retrieved by calling available_energies on sf.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Since Sunny only calculates the structure factor on a finite lattice when performing classical simulations, it is important to realize that exact information is only available at a discrete set of wave vectors. Specifically, for each axis index i, we will get information at q_i = fracnL_i, where n runs from (frac-L_i2+1) to fracL_i2 and L_i is the linear dimension of the lattice used for the calculation. If you request a wave vector that does not fall into this set, Sunny will automatically round to the nearest ùê™ that is available. If intensities_interpolated is given the keyword argument interpolation=:linear, Sunny will use trilinear interpolation to determine a result at the requested wave vector. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve the intensities at all wave vectors for which there is exact data, first call the function available_wave_vectors to generate a list of qs. This takes an optional keyword argument bzsize, which must be given a tuple of three integers specifying the number of Brillouin zones to calculate, e.g., bzsize=(2,2,2). The resulting list of wave vectors may then be passed to intensities_interpolated.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Alternatively, intensities_binned can be used to place the exact data into histogram bins for comparison with experiment.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The convenience function reciprocal_space_path returns a list of wavevectors sampled along a path that connects specified ùê™ points. This list can be used as an input to intensities. Another convenience method, reciprocal_space_shell will generate points on a sphere of a given radius. This is useful for powder averaging. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A number of arguments for intensity_formula are available which modify the calculation of structure factor intensity. It is generally recommended to provide a value of kT corresponding to the temperature of sampled configurations. Given kT, Sunny will include an energy- and temperature-dependent classical-to-quantum  rescaling of intensities in the formula.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve intensity data from a instantaneous structure factor, use instant_intensities_interpolated, which accepts similar arguments to intensities_interpolated. This function may also be used to calculate instantaneous information from a dynamical correlation data, i.e. from a SampledCorrelations created with dynamical_correlations. Note that it is important to supply a value to kT to reap the benefits of this approach over simply calculating a static structure factor at the outset. ","category":"page"},{"location":"writevtk/#Volumetric-Rendering-with-ParaView","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"The 4D correlation data produced by Sunny is too high-dimensional to visualize directly. This page describes how to export 3D slices of correlation data from Sunny to the Visual ToolKit (VTK) format, which is compatible with the ParaView visualization software. ParaView supports volumetric rendering:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewrender.jpg\" style=\"margin: 30px; \" width=\"400\">","category":"page"},{"location":"writevtk/#Simulation-data","page":"Volumetric Rendering with ParaView","title":"Simulation data","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"First, generate some correlation data in Sunny. We will use a 2D lattice, since the correlation data S(Q_xQ_yomega) is  3D and can be exported in its entirety. The following code sets up the system, thermalizes it, and records the correlation data in a SampledCorrelations called dsf.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"using Sunny\n\n# Single layer 12x12 periodic square lattice\nlatsize = (12,12,1);\n\nlatvecs = lattice_vectors(8.,8.,12.,90,100,90)\npositions = [[0,0,0]]\ntypes = [\"Cu\"]\nformfactors = [FormFactor(\"Cu2\")]\nxtal = Crystal(latvecs,positions;types);\n\nsys = System(xtal, latsize, [SpinInfo(1, S=1/2, g=2)], :SUN; seed=1);\n\nJ = 10.\nset_exchange!(sys,J,Bond(1,1,[1,0,0]))\nset_exchange!(sys,J,Bond(1,1,[0,1,0]))\n\nŒît = 0.01\nkT = 0.5\nlangevin = Langevin(Œît; Œª=0.5, kT=kT)\nrandomize_spins!(sys);\nfor i in 1:10_000 # Long enough to reach equilibrium\n    step!(sys, langevin)\nend \n\nœâmax=10.\n\ndsf = dynamical_correlations(sys\n                             ;Œît=Œît\n                             ,nœâ=48\n                             ,œâmax=œâmax\n                             ,process_trajectory=:symmetrize)\n\nnsamples = 10\nfor _ in 1:nsamples\n    for _ in 1:1000 \n        step!(sys, langevin)\n    end\n    add_sample!(dsf, sys)\nend","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"The default histogram BinningParameters are already integrated over the z direction because the system is 2D:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"unit_resolution_binning_parameters(dsf)","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"‚ä°    12 bins from -0.042 to +0.958 along [+1.27 dx] (Œî = 0.065)\n‚ä°    12 bins from -0.042 to +0.958 along [+1.27 dy] (Œî = 0.065)\n‚à´ Integrated from +0.000 to +0.000 along [-0.33 dx +1.88 dz] (Œî = 0.524)\n‚ä°    48 bins from -0.107 to +10.134 along [+1.00 dE] (Œî = 0.213)","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"The histogram is very oblong; it's approximately 1x1x10. To make it a nicer shape, we will rescale the energy axis to be be fractions of œâmax:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"params = unit_resolution_binning_parameters(dsf)\nscale_factor = œâmax\nparams.binend[4] /= scale_factor\nparams.binstart[4] /= scale_factor\nparams.binwidth[4] /= scale_factor\nparams.covectors[4,:] ./= scale_factor","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Doing this changes the last axis of the histogram to fit in [0,1]:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"‚ä°    49 bins from -0.011 to +1.013 along [+0.10 dE] (Œî = 0.213)","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Now that our histogram is a cube, we compute the intensity in the histogram bins using the usual intensities_binned:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"formula = intensity_formula(dsf,:trace)\nsignal, counts = intensities_binned(dsf, params; formula)\nintensity = signal ./ counts","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Now that we have our intensity data and the binning parameters, we can export to VTK format using export_vtk and move to ParaView for the visualization.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"# Importing WriteVTK enables Sunny's export-to-VTK functions\nimport WriteVTK\n\n# [1,2,4] specifies that the (x,y,z) axes in ParaView are (Qx,Qy,œâ)\nexport_vtk(\"square_lattice\", params, intensity; dims_kept = [1,2,4])\n# Writes a file square_lattice.vti in the current directory","category":"page"},{"location":"writevtk/#Loading-in-ParaView","page":"Volumetric Rendering with ParaView","title":"Loading in ParaView","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"In ParaView, use File > Open to open square_lattice.vti. This will add the file to the Pipeline Browser with a closed eye icon, indicating that the data is ready to be loaded.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"In the Properties panel, both bin_centers and data will be selected for import by default. Uncheck bin_centers because we don't need that information for the visualization. Click the green Apply button to load the data.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"By default, only the outline of the data is shown in the 3D viewport. Since we adjusted the energy axis, the outline is a 1x1x1 cube. Optionally enable the axes grid under \"View\", and customize using the adjacent edit button.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewimport.png\" style=\"margin: 30px;\" width=\"200\">","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"To enable the volumetric render:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Select \"Volume\" from the \"Representation\" drop-down menu under \"Display\".\nThe \"Coloring\" drop-down should automatically select data because it's the only data loaded.\nOpen the Color Map Editor to adjust the opacity of the fog, which may be too faint to see by default.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewvolume.png\" style=\"margin: 30px; \" width=\"400\">","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Depending on your computer and your dataset size, the volumetric rendering may be slow, but our dataset is relatively small, so the render should be fast.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"If nothing shows up at first, don't despair. Often, there are Bragg-like peaks in the correlation data which outshine everything else. To see this, enable Display Data Histogram in the Color Map Editor panel. To zoom in on the lower-intensity data, click and drag the right side handle of the opacity transfer function box to the middle a few times.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewcolormap.png\" style=\"margin: 30px; \" width=\"200\">","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"After suitable color mapping, the dispersion curve should become visible:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewrender.jpg\" style=\"margin: 30px; \" width=\"400\">","category":"page"},{"location":"writevtk/#Experiment-data","page":"Volumetric Rendering with ParaView","title":"Experiment data","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Note that since only the data and binning parameters are required for exporting to VTK, experiment data can be exported in the same way. For example, to visualize S(Q_xQ_yQ_z), do this:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"# Load 4D histogram data from Mantid\nparams, signal = load_nxs(\"experiment_data.nxs\")\n\n# Integrate out the energy axis so we are 3D\nintegrate_axes!(params; axes = 4)\nsignal = sum(signal; dims = 4)\n\n# Export to ParaView\nexport_vtk(\"experiment_data_as_vtk\", params, signal)","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"EditURL = \"../../../examples/ising2d.jl\"","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"<a href=\"../../assets/notebooks/ising2d.ipynb\" download>Download as a Jupyter notebook</a>","category":"page"},{"location":"examples/ising2d/#Classical-Ising-model","page":"Classical Ising model","title":"Classical Ising model","text":"","category":"section"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"This tutorial illustrates simulation of the classical 2D Ising model.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"using Sunny, Plots","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Sunny expects a 3D Crystal unit cell. To model a square lattice, we create an orthogonal unit cell where the z-spacing is distinct from the x and y spacing.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"a = 1\nlatvecs = lattice_vectors(a,a,10a,90,90,90)\ncrystal = Crystal(latvecs, [[0,0,0]])","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Create a System of spins with linear size L in the x and y directions, and only one layer in the z direction. The option :dipole means that the system will store Heisenberg spins, as opposed to SU(N) coherent states. Polarize the initial spin configuration using polarize_spins!. Following the Ising convention, we will restrict these spins to the z-axis and give them magnitude S=1.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"By default, Sunny uses physical units, e.g. magnetic field in tesla. Here we specify an alternative Units system, so that the Zeeman coupling between the spin dipole ùê¨ and an external field ùêÅ has the dimensionless form -ùêÅùê¨.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"L = 128\nsys = System(crystal, (L,L,1), [SpinInfo(1, S=1, g=1)], :dipole, units=Units.theory, seed=0)\npolarize_spins!(sys, (0,0,1))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Use set_exchange! to include a ferromagnetic Heisenberg interaction along nearest-neighbor bonds. The Bond below connects two spins displaced by one lattice constant in the x-direction. This interaction will be propagated to all nearest-neighbors bonds in the system, consistent with the symmetries of the square lattice.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"set_exchange!(sys, -1.0, Bond(1,1,(1,0,0)))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"If an external field is desired, it can be set using set_external_field!.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"B = 0\nset_external_field!(sys, (0,0,B))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"The critical temperature for the Ising model is known analytically.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Tc = 2/log(1+‚àö2)","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Use a LocalSampler to perform nsweeps Monte Carlo sweeps. A sweep consists of, on average, one trial update per spin in the system. Each proposed update is accepted or rejected according to the Metropolis acceptance probability. As its name suggests, the propose_flip function will only propose pure spin flips, ùê¨ rightarrow -ùê¨.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"nsweeps = 4000\nsampler = LocalSampler(kT=Tc, propose=propose_flip)\nfor i in 1:nsweeps\n    step!(sys, sampler)\nend","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Plot the Ising spins by extracting the z-component of the dipoles","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"heatmap(reshape([s.z for s in sys.dipoles], (L,L)))","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"EditURL = \"../../../examples/powder_averaging.jl\"","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"<a href=\"../../assets/notebooks/powder_averaging.ipynb\" download>Download as a Jupyter notebook</a>","category":"page"},{"location":"examples/powder_averaging/#Powder-averaged-CoRh_2O_4","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"","category":"section"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"This tutorial illustrates the calculation of the powder-averaged structure factor by performing an orientational average. We consider a simple model of the diamond-cubic crystal CoRh_2O_4, with parameters extracted from Ge et al., Phys. Rev. B 96, 064413.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"using Sunny, GLMakie","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"Construct a diamond Crystal in the conventional (non-primitive) cubic unit cell. Sunny will populate all eight symmetry-equivalent sites when given the international spacegroup number 227 (\"Fd-3m\") and the appropriate setting. For this spacegroup, there are two conventional translations of the unit cell, and it is necessary to disambiguate through the setting keyword argument. (On your own: what happens if setting is omitted?)","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"a = 8.5031 # (√Ö)\nlatvecs = lattice_vectors(a, a, a, 90, 90, 90)\ncrystal = Crystal(latvecs, [[0,0,0]], 227, setting=\"1\")","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"Construct a System with an antiferromagnetic nearest neighbor interaction J. Because the diamond crystal is bipartite, the ground state will have unfrustrated N√©el order. Selecting latsize=(1,1,1) is sufficient because the ground state is periodic over each cubic unit cell. By passing an explicit seed, the system's random number generator will give repeatable results.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"latsize = (1,1,1)\nseed = 0\nS = 3/2\nJ = 7.5413*meV_per_K # (~ 0.65 meV)\nsys = System(crystal, latsize, [SpinInfo(1; S, g=2)], :dipole; seed=0)\nset_exchange!(sys, J, Bond(1, 3, [0,0,0]))","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"The ground state is non-frustrated. Each spin should be exactly anti-aligned with its 4 nearest-neighbors, such that every bond contributes an energy of -JS^2. This gives an energy per site of -2JS^2. In this calculation, a factor of 1/2 is necessary to avoid double-counting the bonds. Given the small magnetic supercell (which includes only one unit cell), direct energy minimization is successful in finding the ground state.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"randomize_spins!(sys)\nminimize_energy!(sys)\n\nenergy_per_site = energy(sys) / length(eachsite(sys))\n@assert energy_per_site ‚âà -2J*S^2","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"Plotting the spins confirms the expected N√©el order. Note that the overall, global rotation of dipoles is arbitrary.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"plot_spins(sys; ghost_radius=2.0)","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"We can now estimate ùíÆ(ùê™œâ) with SpinWaveTheory and intensity_formula. The mode :perp contracts with a dipole factor to return the unpolarized intensity. We will also apply broadening with the lorentzian kernel, and will dampen intensities using the FormFactor for Cobalt(2+).","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"swt = SpinWaveTheory(sys)\nŒ∑ = 0.4 # (meV)\nkernel = lorentzian(Œ∑)\nformfactors = [FormFactor(\"Co2\")]\nformula = intensity_formula(swt, :perp; kernel, formfactors)","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"First, we consider the \"single crystal\" results. Use reciprocal_space_path to construct a path that connects high-symmetry points in reciprocal space. The intensities_broadened function collects intensities along this path for the given set of energy values.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"qpoints = [[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [0.5, 0.5, 0.0], [0.0, 0.0, 0.0]]\npath, xticks = reciprocal_space_path(crystal, qpoints, 50)\nenergies = collect(0:0.01:6)\nis = intensities_broadened(swt, path, energies, formula)\n\nfig = Figure()\nax = Axis(fig[1,1]; aspect=1.4, ylabel=\"œâ (meV)\", xlabel=\"ùê™ (RLU)\",\n          xticks, xticklabelrotation=œÄ/10)\nheatmap!(ax, 1:size(is, 1), energies, is, colormap=:gnuplot2)\nfig","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"A powder measurement effectively involves an average over all possible crystal orientations. We use the function reciprocal_space_shell to sample n wavevectors on a sphere of a given radius (inverse angstroms), and then calculate the spherically-averaged intensity.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"radii = 0.01:0.02:3 # (1/√Ö)\noutput = zeros(Float64, length(radii), length(energies))\nfor (i, radius) in enumerate(radii)\n    n = 300\n    qs = reciprocal_space_shell(crystal, radius, n)\n    is = intensities_broadened(swt, qs, energies, formula)\n    output[i, :] = sum(is, dims=1) / size(is, 1)\nend\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel=\"|Q| (√Ö‚Åª¬π)\", ylabel=\"œâ (meV)\")\nheatmap!(ax, radii, energies, output, colormap=:gnuplot2)\nfig","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"This result can be compared to experimental neutron scattering data from Fig. 5 of Ge et al.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder averaged CoRh_2O_4","title":"Powder averaged CoRh_2O_4","text":"<img width=\"95%\" src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/CoRh2O4_intensity.jpg\">","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"EditURL = \"../../../examples/out_of_equilibrium.jl\"","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"<a href=\"../../assets/notebooks/out_of_equilibrium.ipynb\" download>Download as a Jupyter notebook</a>","category":"page"},{"location":"examples/out_of_equilibrium/#CP2-Skyrmion-Quench","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"","category":"section"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"This example demonstrates Sunny's ability to simulate the out-of-equilibrium dynamics of generalized spin systems. We will implement the model Hamiltonian of Zhang et al., Nature Communications 14, 3626 (2023), which supports a novel type of topological defect, a CP¬≤ skyrmion, that involves both the dipolar and quadrupolar parts of a quantum spin.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"Beginning from an initial high-temperature state, a disordered gas of CP¬≤ skyrmions can be formed by rapidly quenching to low temperature. To model the coupled dynamics of dipoles and quadrupoles, Sunny uses a recently developed generalization of the Landau-Lifshitz spin dynamics, Dahlbom et al., Phys. Rev. B 106, 235154 (2022).","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"using Sunny, GLMakie","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"The Hamiltonian we will implement,","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"mathcalH = sum_langle ij rangle J_ij( hatS_i^x hatS_j^x + hatS_i^y hatS_j^y + DeltahatS_i^z hatS_j^z) - hsum_ihatS_i^z + Dsum_i(hatS_i^z)^2","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"contains competing ferromagnetic nearest-neightbor and antiferromagnetic next-nearest-neighbor exchange terms on a triangular lattice. Both exchanges exhibit anisotropy on the z-term. Additionally, there is an external magnetic field, h, and easy-plane single-ion anisotropy, D. We begin by implementing the Crystal.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"lat_vecs = Sunny.lattice_vectors(1.0, 1.0, 2.0, 90, 90, 120)\nbasis_vecs = [[0,0,0]]\ncryst = Crystal(lat_vecs, basis_vecs)","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"The crystal is then used to create a spin System. All parameters in this model system are dimensionless, so we select \"theory\" units and set the g-factor to one.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"L = 40\ndims = (L, L, 1)\nsys = System(cryst, dims, [SpinInfo(1, S=1, g=1)], :SUN; seed=101, units=Units.theory)","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"We proceed to implement each term of the Hamiltonian, selecting our parameters so that the system occupies a region of the phase diagram that supports skyrmions. The exchange interactions are set as follows.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"J1 = -1           # Nearest-neighbor ferromagnetic\nJ2 = (2.0/(1+‚àö5)) # Tune competing exchange to set skyrmion scale length\nŒî = 2.6           # Exchange anisotropy\n\nex1 = J1 * [1.0 0.0 0.0;\n            0.0 1.0 0.0;\n            0.0 0.0 Œî]\nex2 = J2 * [1.0 0.0 0.0;\n            0.0 1.0 0.0;\n            0.0 0.0 Œî]\nset_exchange!(sys, ex1, Bond(1, 1, [1, 0, 0]))\nset_exchange!(sys, ex2, Bond(1, 1, [1, 2, 0]));\nnothing #hide","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"Next we add the external field,","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"h = 15.5\nfield = set_external_field!(sys, [0.0 0.0 h]);\nnothing #hide","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"and finally the single-ion anisotropy,","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"D = 19.0\nSz = Sunny.spin_operators(sys, 1)[3]\nset_onsite_coupling!(sys, D*Sz^2, 1);\nnothing #hide","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"Initialize system to an infinite temperature (fully randomized) initial condition.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"randomize_spins!(sys)","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"We are now ready to simulate the quenching process using a generalized Langevin spin dynamics. If we were working with spin dipoles only, then Langevin dynamics would be the usual Landau-Lifshitz spin dynamics, augmented with damping and noise terms. In the present study, we are instead working with quantum spin-1 (an (N=3)-level system that includes both dipoles and quadrupoles). Here, Langevin captures the coupled dipole-quadrupole dynamics using the formalism of SU(N) coherent states.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"Selecting kT = 0 in the Langevin dynamics will effective disable the noise term. Then the parameter Œª effectively determines the damping time-scale.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"Œît = 0.2/D  # Integration time step (inverse meV). Typically this will be\n            # inversely proportional to the largest energy scale in the\n            # system. We can use a fairly large time-step here because\n            # accuracy isn't critical.\nkT = 0      # Target equilibrium temperature (meV)\nŒª = 0.1     # Magnitude of coupling to thermal bath (dimensionless)\nintegrator = Langevin(Œît; kT, Œª);\nnothing #hide","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"Finally we run the dynamics. We will record the state of the system at three different times during the quenching process by copying the coherents field of the System.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"œÑs = [4., 16, 256]  # Times to record snapshots\nframes = []         # Empty array to store snapshots\nfor i in eachindex(œÑs)\n    dur = i == 1 ? œÑs[1] : œÑs[i] - œÑs[i-1] # Determine the length of time to simulate\n    numsteps = round(Int, dur/Œît)\n    for _ in 1:numsteps                    # Perform the integration\n        step!(sys, integrator)\n    end\n    push!(frames, copy(sys.coherents))     # Save a snapshot spin configuration\nend","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"To visualize the state of the system contained in each snapshot, we will calculate and plot the skyrmion density on each plaquette of our lattice. The function plot_triangular_plaquettes is not part of the core Sunny package, but rather something you could define yourself. We are using the definition in plotting2d.jl from the Sunny examples/extra directory.","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"include(joinpath(pkgdir(Sunny), \"examples\", \"extra\", \"plotting2d.jl\"))\n\nfunction sun_berry_curvature(z‚ÇÅ, z‚ÇÇ, z‚ÇÉ)\n    z‚ÇÅ, z‚ÇÇ, z‚ÇÉ = normalize.((z‚ÇÅ, z‚ÇÇ, z‚ÇÉ))\n    n‚ÇÅ = z‚ÇÅ ‚ãÖ z‚ÇÇ\n    n‚ÇÇ = z‚ÇÇ ‚ãÖ z‚ÇÉ\n    n‚ÇÉ = z‚ÇÉ ‚ãÖ z‚ÇÅ\n    return angle(n‚ÇÅ * n‚ÇÇ * n‚ÇÉ)\nend\n\nplot_triangular_plaquettes(sun_berry_curvature, frames; resolution=(1800,600),\n    offset_spacing=10, texts = [\"\\tt = \"*string(œÑ) for œÑ in œÑs], text_offset = (0.0, 6.0)\n)","category":"page"},{"location":"examples/out_of_equilibrium/","page":"CP^2 Skyrmion Quench","title":"CP^2 Skyrmion Quench","text":"The times are given in hbarJ_1. The white background corresponds to a quantum paramagnetic state, where the local spin exhibits a strong quadrupole moment and little or no dipole moment. Observe that the process has generated a number of well-formed skyrmions of both positive (red) and negative (blue) charge in addition to a number of other metastable spin configurations. A full-sized version of this figure is available in Dahlbom et al..","category":"page"},{"location":"library/#Library-API","page":"Library API","title":"Library API","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter ? at the Julia command prompt).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Sunny.plot_spins\nSunny.export_vtk","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Modules = [Sunny]\nPrivate = false","category":"page"},{"location":"library/#Sunny.Site","page":"Library API","title":"Sunny.Site","text":"(cell1, cell2, cell3, i) :: Site\n\nFour indices identifying a single site in a System. The first three indices select the lattice cell and the last selects the sublattice (i.e., the atom within the unit cell).\n\nThis object can be used to index dipoles and coherents fields of a System. A Site is also required to specify inhomogeneous interactions via functions such as set_external_field_at! or set_exchange_at!.\n\nNote that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the Site using position_to_site, which always takes a position in fractional coordinates of the original lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Units","page":"Library API","title":"Sunny.Units","text":"Units.meV\nUnits.theory\n\nThe unit system is implicitly determined by the definition of two physical constants: the vacuum permeability Œº‚ÇÄ and the Bohr magneton Œº_B. Temperatures are effectively measured in units of energy (k_B = 1) and time is effectively measured in units of inverse energy (ƒß = 1). The default unit system, Units.meV, employs (meV, ‚Ñ´, tesla). Select alternatively Units.theory for a units system defined so that Œº‚ÇÄ = Œº_B = 1.\n\nSee also meV_per_K\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.meV_per_K","page":"Library API","title":"Sunny.meV_per_K","text":"meV_per_K = 0.086173332621451774\n\nA physical constant. Useful for converting kelvin into the default energy units, meV.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.BinningParameters","page":"Library API","title":"Sunny.BinningParameters","text":"BinningParameters(binstart,binend,binwidth;covectors = I(4))\nBinningParameters(binstart,binend;numbins,covectors = I(4))\n\nDescribes a 4D parallelepided histogram in a format compatible with experimental Inelasitic Neutron Scattering data. See generate_mantid_script_from_binning_parameters to convert BinningParameters to a format understandable by the Mantid software, or load_nxs to load BinningParameters from a Mantid .nxs file.\n\nThe coordinates of the histogram axes are specified by multiplication  of (q,œâ) with each row of the covectors matrix, with q given in [R.L.U.]. Since the default covectors matrix is the identity matrix, the default axes are (qx,qy,qz,œâ) in absolute units.\n\nThe convention for the binning scheme is that:\n\nThe left edge of the first bin starts at binstart\nThe bin width is binwidth\nThe last bin contains binend\nThere are no \"partial bins;\" the last bin may contain values greater than binend. C.f. count_bins.\n\nA value can be binned by computing its bin index:\n\ncoords = covectors * value\nbin_ix = 1 .+ floor.(Int64,(coords .- binstart) ./ binwidth)\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Bond","page":"Library API","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal","page":"Library API","title":"Sunny.Crystal","text":"An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:\n\nCrystal(filename; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.  The optional parameter symprec controls the precision tolerance for spacegroup symmetries.\n\nCrystal(latvecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, with coordinates (between 0 and 1) in units of lattice vectors latvecs. Spacegroup symmetry information is automatically inferred. The optional parameter types is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.\n\nCrystal(latvecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)\n\nBuilds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional setting string will disambiguate between unit cell conventions.\n\nCurrently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a .cif file or from the full specification of the unit cell.\n\nExamples\n\n# Read a Crystal from a .cif file\nCrystal(\"filename.cif\")\n\n# Build an FCC crystal using the primitive unit cell. The spacegroup number\n# 225 is inferred.\nlatvecs = [1 1 0;\n            1 0 1;\n            0 1 1] / 2\npositions = [[0, 0, 0]]\nCrystal(latvecs, positions)\n\n# Build a CsCl crystal (two cubic sublattices). By providing distinct type\n# strings, the spacegroup number 221 is inferred.\nlatvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[0,0,0], [0.5,0.5,0.5]]\ntypes = [\"Na\", \"Cl\"]\ncryst = Crystal(latvecs, positions; types)\n\n# Build a diamond cubic crystal from its spacegroup number 227. This\n# spacegroup has two possible settings (\"1\" or \"2\"), which determine an\n# overall unit cell translation.\nlatvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[1, 1, 1] / 4]\ncryst = Crystal(latvecs, positions, 227; setting=\"1\")\n\nSee also lattice_vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.FormFactor-Tuple{String}","page":"Library API","title":"Sunny.FormFactor","text":"FormFactor(ion::String; g_lande=2)\n\nThe magnetic form factor for a given magnetic ion and charge state. When passed to an intensity_formula, determines a ùê™-dependent scaling of the structure factor.\n\nThe parameter ion must be one of the following strings:\n\nAm2, Am3, Am4, Am5, Am6, Am7, Au1, Au2, Au3, Au4, Au5, Ce2, Co0, Co1, Co2, Co3,\nCo4, Cr0, Cr1, Cr2, Cr3, Cr4, Cu0, Cu1, Cu2, Cu3, Cu4, Dy2, Dy3, Er2, Er3, Eu2,\nEu3, Fe0, Fe1, Fe2, Fe3, Fe4, Gd2, Gd3, Hf2, Hf3, Ho2, Ho3, Ir0a, Ir0b, Ir0c,\nIr1a, Ir1b, Ir2, Ir3, Ir4, Ir5, Ir6, Mn0, Mn1, Mn2, Mn3, Mn4, Mo0, Mo1, Nb0,\nNb1, Nd2, Nd3, Ni0, Ni1, Ni2, Ni3, Ni4, Np3, Np4, Np5, Np6, Os0a, Os0b, Os0c,\nOs1a, Os1b, Os2, Os3, Os4, Os5, Os6, Os7, Pd0, Pd1, Pr3, Pt1, Pt2, Pt3, Pt4,\nPt5, Pt6, Pu3, Pu4, Pu5, Pu6, Re0a, Re0b, Re0c, Re1a, Re1b, Re2, Re3, Re4, Re5,\nRe6, Rh0, Rh1, Ru0, Ru1, Sc0, Sc1, Sc2, Sm2, Sm3, Ta2, Ta3, Ta4, Tb2, Tb3, Tc0,\nTc1, Ti0, Ti1, Ti2, Ti3, Tm2, Tm3, U3, U4, U5, V0, V1, V2, V3, V4, W0a, W0b,\nW0c, W1a, W1b, W2c, W3, W4, W5, Y0, Yb2, Yb3, Zr0, Zr1\n\nThe trailing number denotes ionization state. For example, \"Fe0\" denotes a neutral iron atom, while \"Fe2\" denotes Fe¬≤‚Å∫. If multiple electronic configurations are possible, they will be distinguished by a trailing letter (a, b, ...). Omitting this letter will print an informative error,\n\nFormFactor(\"Ir0\")\n\nERROR: Disambiguate form factor according to electronic configuration:\n    \"Ir0a\" -- 6s‚Å∞5d‚Åπ\n    \"Ir0b\" -- 6s¬π5d‚Å∏\n    \"Ir0c\" -- 6s¬≤5d‚Å∑\n\nThe form factor is approximated as\n\nF(s) = j_0(s) + frac2-gg j_2(s) s^2,\n\ninvolving the Land√© g-factor. The j_l(s) are radial integrals associated with the lth Bessel function of the magnetic dipole, where s = k4œÄ, and k is the magnitude of momentum transfer. \n\nThe radial integrals have been calculated using Hartree-Fock for transition metals, or Dirac-Fock for the rare earths and actinide series [1‚Äì3]. Sunny uses approximate fits as a sum of Gaussians,\n\nj_0(s) = A e^-as^2 + B e^-bs^2 + C e^-cs^2 + D e^-ds^2 + E\nj_l(s) = (A e^-as^2 + B e^-bs^2 + C e^-cs^2 + D e^-ds^2 + E) s^2\n\nReferences:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\nJ. Brown, The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors (2003)\nK. Kobayashi, T. Nagao, M. Ito, Acta Cryst. A, 67 pp 473‚Äì480 (2011)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.ImplicitMidpoint","page":"Library API","title":"Sunny.ImplicitMidpoint","text":"ImplicitMidpoint(Œît::Float64; atol=1e-12) where N\n\nEnergy-conserving spin dynamics. One call to the step! function will advance a System by Œît units of time.\n\nUses the spherical midpoint integration scheme for dipole systems and the Schr√∂dinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic, and therefore avoid energy drift over long periods of simulation time.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Langevin","page":"Library API","title":"Sunny.Langevin","text":"Langevin(Œît::Float64; Œª::Float64, kT::Float64)\n\nSpin dynamics with coupling to a Langevin thermostat, which includes damping and noise terms. One call to the step! function will advance a System by Œît units of time.\n\nAssuming ergodicity, the Langevin dynamics will sample from thermal equilibrium for the target temperature kT. The empirical parameter Œª determines the strength of the coupling to the thermal bath. In other words, 1/Œª is the decorrelation time-scale. If Œª = 0, then the spin dynamics coincides with ImplicitMidpoint.\n\nAn alternative approach to sampling is LocalSampler, which may be preferred when the allowed spin values become effective discrete (e.g. Ising spins).\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LocalSampler","page":"Library API","title":"Sunny.LocalSampler","text":"LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)\n\nMonte Carlo simulation involving Metropolis updates to individual spins. One call to the step! function will perform nsweeps of MCMC sampling for a provided System. The default value of 1.0 means that step! performs, on average, one trial update per spin.\n\nAssuming ergodicity, the LocalSampler will sample from thermal equilibrium for the target temperature kT. \n\nThe trial spin updates are sampled using the propose function. Built-in options include propose_uniform, propose_flip, and propose_delta. Multiple proposals can be mixed with the macro @mix_proposals.\n\nThe returned object stores fields ŒîE and Œîs, which represent the cumulative change to the net energy and dipole, respectively.\n\nAn alternative approach to sampling is Langevin, which may be preferred for simulating continuous spins, especially in the presence of long-range dipole-dipole interactions (cf. enable_dipole_dipole!).\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SampledCorrelations","page":"Library API","title":"Sunny.SampledCorrelations","text":"SampledCorrelations\n\nBasic data type for storing sampled correlation data. A SampleCorrelations is initialized by calling either dynamical_correlations or instant_correlations.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinInfo","page":"Library API","title":"Sunny.SpinInfo","text":"SpinInfo(atom::Int; S, g=2)\n\nCharacterizes the spin at a given atom index within the crystal unit cell. S is an integer multiple of 1/2 and gives the spin angular momentum in units of ƒß. g is the g-factor or tensor, such that an angular momentum dipole s produces a magnetic moment g s in units of the Bohr magneton.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinWaveTheory","page":"Library API","title":"Sunny.SpinWaveTheory","text":"SpinWaveTheory(sys, energy_œµ::Float64=1e-8, energy_tol=1e-6)\n\nConstructs an object to perform linear spin wave theory. Use it with dispersion and dssf functions.\n\nThe optional parameter energy_œµ adds a small positive shift to the diagonal of the dynamical matrix D to avoid numerical issues with zero-energy quasi-particle modes. The optional parameter energy_tol relaxes the check on the imaginary part of the eigenvalues.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}","page":"Library API","title":"Sunny.System","text":"System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)\n\nConstruct a System of spins for a given Crystal symmetry. The latsize parameter determines the number of unit cells in each lattice vector direction. The infos parameter is a list of SpinInfo objects, which determine the magnitude S and g-tensor of each spin.\n\nThe three possible options for mode are :SUN, :dipole, and :large_S. The most variationally accurate choice is :SUN, in which each spin-S degree of freedom is described as an SU(N) coherent state, where N = 2S + 1. Note that an SU(N) coherent state fully describes any local spin state; this description includes expected dipole components S·µÖ, quadrupole components S·µÖS·µù+S·µùS·µÖ, etc.\n\nThe mode :dipole projects the SU(N) dynamics onto the space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but all single-ion anisotropy and biquadratic exchange interactions will be automatically renormalized for maximum accuracy.\n\nTo disable such renormalization, e.g. to reproduce results using the historical large-S classical limit, use the experimental mode :large_S. Modes :SUN or :dipole are strongly preferred for the development of new models.\n\nThe default units system of (meV, ‚Ñ´, tesla) can be overridden by with the units parameter; see Units. \n\nAn optional seed may be provided to achieve reproducible random number generation.\n\nAll spins are initially polarized in the z-direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.add_sample!-Tuple{SampledCorrelations, System}","page":"Library API","title":"Sunny.add_sample!","text":"add_sample!(sc::SampledCorrelations, sys::System)\n\nadd_trajectory uses the spin configuration contained in the System to generate a correlation data and accumulate it into sc. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculating in time and accumulated into sc. \n\nThis function will change the state of sys when calculating dynamical structure factor data. To preserve the initial state of sys, it must be saved separately prior to calling add_sample!. Alternatively, the initial spin configuration may be copied into a new System and this new System can be passed to add_sample!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.available_energies-Tuple{SampledCorrelations}","page":"Library API","title":"Sunny.available_energies","text":"available_energies(sc::SampledCorrelations; negative_energies=false)\n\nReturn the œâ values for the energy index of a SampledCorrelations. By default, only returns values for non-negative energies, which corresponds to the default output of intensities. Set negative_energies to true to retrieve all œâ values.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.available_wave_vectors-Tuple{SampledCorrelations}","page":"Library API","title":"Sunny.available_wave_vectors","text":"available_wave_vectors(sc::SampledCorrelations; bzsize=(1,1,1))\n\nReturns all wave vectors for which sc contains exact values. bsize specifies the number of Brillouin zones to be included.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.axes_bincenters-Tuple{Any, Any, Any}","page":"Library API","title":"Sunny.axes_bincenters","text":"axes_bincenters(params::BinningParameters)\n\nReturns tick marks which label the bins of the histogram described by BinningParameters by their bin centers.\n\nThe following alternative syntax can be used to compute bin centers for a single axis:\n\naxes_bincenters(binstart,binend,binwidth)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}","page":"Library API","title":"Sunny.broaden_energy","text":"broaden_energy(sc::SampledCorrelations, vals, kernel::Function; negative_energies=false)\n\nPerforms a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by intensities_interpolated. kernel must be a function that takes two numbers: kernel(œâ, œâ‚ÇÄ), where œâ is a frequency, and œâ‚ÇÄ is the center frequency of the kernel. Sunny provides lorentzian for the most common use case:\n\nnewvals = broaden_energy(sc, vals, (œâ, œâ‚ÇÄ) -> lorentzian(œâ-œâ‚ÇÄ, 0.2))\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.browser-Tuple{String}","page":"Library API","title":"Sunny.browser","text":"browser(html_str; dir)\n\nLaunch a system browser to display the provided HTML string or SunnyViewer. If a directory dir is provided, an HTML file will be written at that location.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.count_bins-Tuple{Any, Any, Any}","page":"Library API","title":"Sunny.count_bins","text":"count_bins(binstart,binend,binwidth)\n\nReturns the number of bins in the binning scheme implied by binstart, binend, and binwidth. To count the bins in a BinningParameters, use params.numbins.\n\nThis function defines how partial bins are handled, so it should be used preferentially over computing the number of bins manually.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dispersion-Tuple{SpinWaveTheory, Any}","page":"Library API","title":"Sunny.dispersion","text":"dispersion(swt::SpinWaveTheory, qs)\n\nComputes the spin excitation energy dispersion relations given a SpinWaveTheory and an array of wave vectors qs. Each element q of qs must be a 3-vector in units of reciprocal lattice units. I.e., q·µ¢ is given in 2œÄa·µ¢ with a·µ¢ the lattice constant of the original chemical lattice.\n\nThe first indices of the returned array correspond to those of qs. A final index, corresponding to mode, is added to these. Each entry of the array is an energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dmvec-Tuple{Any}","page":"Library API","title":"Sunny.dmvec","text":"dmvec(D)\n\nAntisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,\n\n  [  0    D[3] -D[2]\n   -D[3]   0    D[1]\n    D[2] -D[1]   0  ]\n\nUseful in the context of set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dssf-Tuple{SpinWaveTheory, Any}","page":"Library API","title":"Sunny.dssf","text":"dssf(swt::SpinWaveTheory, qs)\n\nGiven a SpinWaveTheory object, computes the dynamical spin structure factor,\n\n    ùíÆ^Œ±Œ≤(ùê§ œâ) = 1(2œÄN)dt _ùê´ expi(œât - ùê§ùê´) S^Œ±(ùê´ t)S^Œ≤(0 0)\n\nusing the result from linear spin-wave theory,\n\n    ùíÆ^Œ±Œ≤(ùê§ œâ) = _n A_n^Œ±Œ≤(ùê§)^2 Œ¥œâ-œâ_n(ùê§)\n\nqs is an array of wave vectors of arbitrary dimension. Each element q of qs must be a 3-vector in reciprocal lattice units (RLU), i.e., in the basis of reciprocal lattice vectors.\n\nThe first indices of the returned array correspond to those of qs. A final index, corresponding to mode, is added to these. Each entry of this array is a tensor (3√ó3 matrix) corresponding to the indices Œ± and Œ≤.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.dynamical_correlations","text":"dynamical_correlations(sys::System; Œît, nœâ, œâmax, \n    process_trajectory=:none, observables=nothing, correlations=nothing)\n\nCreates a SampledCorrelations for calculating and storing ùíÆ(ùê™œâ) data. This information will be obtained by running dynamical spin simulations on equilibrium snapshots and measuring pair-correlations. The ùíÆ(ùê™œâ) data can be retrieved by calling intensities_interpolated. Alternatively, instant_intensities_interpolated will integrate out œâ to obtain ùíÆ(ùê™), optionally applying classical-to-quantum correction factors.\n\nThe SampleCorrelations that is returned will contain no correlation data. Samples are generated and accumulated by calling add_sample!(sc, sys) where sc is a SampleCorrelations and sys is an appropriately equilibrated System. Note that the sys should be thermalized before each call of add_sample! such that the spin configuration in the system represents a new (fully decorrelated) sample.\n\nThree keywords are required to specify the dynamics used for the trajectory calculation.\n\nŒît: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an ImplicitMidpoint integrator.\nœâmax: The maximum energy, œâ, that will be resolved.\nnœâ: The number of energy bins to calculated between 0 and œâmax.\n\nAdditional keyword options are the following:\n\nprocess_trajectory: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are :none and   :symmetrize. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.\nobservables: Allows the user to specify custom observables. The   observables must be given as a list of complex N√óN matrices or   LinearMaps. It's recommended to name each observable, for example:   observables = [:A => a_observable_matrix, :B => b_map, ...]. By default,   Sunny uses the 3 components of the dipole, :Sx, :Sy and :Sz.\ncorrelations: Specify which correlation functions are calculated, i.e. which   matrix elements Œ±Œ≤ of ùíÆ^Œ±Œ≤(qœâ) are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all observables. To retain only the xx and   xy correlations, one would set correlations=[(:Sx,:Sx), (:Sx,:Sy)] or   correlations=[(1,1),(1,2)].\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.eachsite-Tuple{System}","page":"Library API","title":"Sunny.eachsite","text":"eachsite(sys::System)\n\nAn iterator over all Sites in the system. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.enable_dipole_dipole!","text":"enable_dipole_dipole!(sys::System)\n\nEnables long-range dipole-dipole interactions,\n\n    -(Œº_04œÄ) _ij  (3 (ùêå_jùê´_ij)(ùêå_iùê´_ij) - ùêå_iùêå_j)  ùê´_ij^3\n\nwhere the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and ùêí_i is the spin angular momentum dipole in units of ƒß. The Bohr magneton Œº_B and vacuum permeability Œº_0 are physical constants, with numerical values determined by the unit system.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.energy","text":"energy(sys::System)\n\nComputes the total system energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}","page":"Library API","title":"Sunny.generate_mantid_script_from_binning_parameters","text":"generate_mantid_script_from_binning_parameters(params::BinningParameters)\n\nGenerate a Mantid script which bins data according to the  given BinningParameters.\n\nwarning: Units\nTake care to ensure the units are correct (R.L.U. or absolute). You may want to call Sunny.bin_rlu_as_absolute_units! or Sunny.bin_absolute_units_as_rlu! first.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.global_position-Tuple{System, Any}","page":"Library API","title":"Sunny.global_position","text":"global_position(sys::System, site::Site)\n\nPosition of a Site in global coordinates.\n\nTo precompute a full list of positions, one can use eachsite as below:\n\npos = [global_position(sys, site) for site in eachsite(sys)]\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.instant_correlations-Tuple{System}","page":"Library API","title":"Sunny.instant_correlations","text":"instant_correlations(sys::System; process_trajectory=:none, observables=nothing, correlations=nothing)\n\nCreates a SampledCorrelations object for calculating and storing instantaneous structure factor intensities ùíÆ(ùê™). This data will be calculated from the spin-spin correlations of equilibrium snapshots, absent any dynamical information. ùíÆ(ùê™) data can be retrieved by calling instant_intensities_interpolated.\n\nImportant note: When dealing with continuous (non-Ising) spins, consider creating using dynamical_correlations instead of  instant_correlations. The former will provide full ùíÆ(ùê™œâ) data, from which ùíÆ(ùê™) can be obtained by integrating out œâ. During this integration step, Sunny can incorporate temperature- and œâ-dependent classical-to-quantum correction factors to produce more accurate ùíÆ(ùê™) estimates. See instant_intensities_interpolated for more information.\n\nPrior to calling instant_correlations, ensure that sys represents a good equilibrium sample. Additional sample data may be accumulated by calling add_sample!(sc, sys) with newly equilibrated sys configurations.\n\nThe following optional keywords are available:\n\nprocess_trajectory: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are :none and   :symmetrize. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.\nobservables: Allows the user to specify custom observables. The   observables must be given as a list of complex N√óN matrices or   LinearMaps. It's recommended to name each observable, for example:   observables = [:A => a_observable_matrix, :B => b_map, ...]. By default,   Sunny uses the 3 components of the dipole, :Sx, :Sy and :Sz.\ncorrelations: Specify which correlation functions are calculated, i.e. which   matrix elements Œ±Œ≤ of ùíÆ^Œ±Œ≤(qœâ) are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all observables. To retain only the xx and   xy correlations, one would set correlations=[(:Sx,:Sx), (:Sx,:Sy)] or   correlations=[(1,1),(1,2)].\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}","page":"Library API","title":"Sunny.instant_intensities_interpolated","text":"instant_intensities_interpolated(sc::SampledCorrelations, qs; kwargs...)\n\nReturn ùíÆ(ùê™) intensities at wave vectors qs. The functionality is very similar to intensities_interpolated, except the returned array has dimensions identical to qs. If called on a SampledCorrelations with dynamical information, i.e., ùíÆ(ùê™œâ), the œâ information is integrated out.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.integrate_axes!-Tuple{BinningParameters}","page":"Library API","title":"Sunny.integrate_axes!","text":"integrate_axes!(params::BinningParameters; axes)\n\nIntegrate over one or more axes of the histogram by setting the number of bins in that axis to 1. Examples:\n\nintegrate_axes!(params; axes = [2,3])\nintegrate_axes!(params; axes = 2)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.integrated_lorentzian-Tuple{Float64}","page":"Library API","title":"Sunny.integrated_lorentzian","text":"integrated_lorentzian(Œ∑)\n\nReturns x mapsto atan(xŒ∑)œÄ for use with intensities_binned.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any, Sunny.SpinWaveIntensityFormula}","page":"Library API","title":"Sunny.intensities_bands","text":"dispersion, intensities = intensities_bands(swt::SpinWaveTheory, ks, formula::SpinWaveIntensityFormula)\n\nComputes the scattering intensities at each energy band for each momentum transfer k in ks, according to Linear Spin Wave Theory and the given intensity formula. The formula must have a delta-function kernel, e.g.:\n\nformula = intensity_formula(swt, :perp, formula; kernel = delta_function_kernel)\n\nor else the bands will be broadened, and their intensity can not be computed.\n\nThe outputs will be arrays with indices identical to ks, with the last index giving the band index. dispersions reports the energy of each band, while intensities reports the scattering intensity.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}","page":"Library API","title":"Sunny.intensities_binned","text":"intensity, counts = intensities_binned(sc::SampledCorrelations, params::BinningParameters, formula; integrated_kernel)\n\nGiven correlation data contained in a SampledCorrelations and BinningParameters describing the shape of a histogram, compute the intensity and normalization for each histogram bin using a given intensity_formula.\n\nThe BinningParameters are expected to accept (q,œâ) in R.L.U. for the (possibly reshaped) crystal associated with sc.\n\nThis is an alternative to intensities_interpolated which bins the scattering intensities into a histogram instead of interpolating between them at specified qs values. See unit_resolution_binning_parameters for a reasonable default choice of BinningParameters which roughly emulates intensities_interpolated with interpolation = :round.\n\nIf a function integrated_kernel(Œîœâ) is passed, it will be used as the CDF of a kernel function for energy broadening. For example, integrated_kernel = Œîœâ -> atan(Œîœâ/Œ∑)/pi (c.f. integrated_lorentzian implements Lorentzian broadening with parameter Œ∑. Energy-dependent energy broadening can be achieved by providing an integrated_kernel(œâ,Œîœâ) whose first argument is the energy transfer œâ.\n\nCurrently, energy broadening is only supported if the BinningParameters are such that the first three axes are purely spatial and the last (energy) axis is [0,0,0,1].\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}","page":"Library API","title":"Sunny.intensities_broadened","text":"intensities_broadened(swt::SpinWaveTheory, ks, œâvals, formula)\n\nComputes the scattering intensities at each (Q,œâ) according to Linear Spin Wave Theory and the given intensity formula. The required formula must have a non-delta-function kernel, e.g.:\n\nformula = intensity_formula(swt, :perp; kernel = lorentzian(0.05))\n\nor else the intensity at œâvals which are not exactly on the dispersion curve can not be calculated.\n\nThe intensity is computed at each wave vector in ks and each energy in œâvals. The output will be an array with indices identical to ks, with the last index matching œâvals.\n\nNote that ks is an array of wave vectors of arbitrary dimension. Each element k of ks must be a 3-wavevector in absolute units.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}","page":"Library API","title":"Sunny.intensities_interpolated","text":"intensities_interpolated(sc::SampledCorrelations, qs, formula:ClassicalIntensityFormula; interpolation=nothing, negative_energies=false)\n\nThe basic function for retrieving ùíÆ(ùê™œâ) information from a SampledCorrelations. Maps an array of wave vectors qs to an array of structure factor intensities, including an additional energy index. The values of œâ associated with the energy index can be retrieved by calling available_energies. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.\n\ninterpolation: Since ùíÆ(ùê™ œâ) is calculated on a finite lattice, data   is only available at discrete wave vectors. By default, Sunny will round a   requested q to the nearest available wave vector. Linear interpolation can   be applied by setting interpolation=:linear.\nnegative_energies: If set to true, Sunny will return the periodic   extension of the energy axis. Most users will not want this.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}","page":"Library API","title":"Sunny.intensity_formula","text":"formula = intensity_formula(sc::SampledCorrelations)\n\nEstablish a formula for computing the intensity of the discrete scattering modes (q,œâ) using the correlation data ùíÆ^Œ±Œ≤(qœâ) stored in the SampledCorrelations. The formula returned from intensity_formula can be passed to intensities_interpolated or intensities_binned.\n\nintensity_formula(sc,...; kT = Inf, formfactors = ...)\n\nThere are keyword arguments providing temperature and form factor corrections:\n\nkT: If a temperature is provided, the intensities will be rescaled by a   temperature- and œâ-dependent classical-to-quantum factor. kT should be   specified when making comparisons with spin wave calculations or   experimental data. If kT is not specified, infinite temperature (no   correction) is assumed.\nformfactors: To apply form factor corrections, provide this keyword with a   list of FormFactors, one for each symmetry-distinct site in the crystal.   The order of FormFactors must correspond to the order of site symmetry   classes, e.g., as they appear when printed in display(crystal).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, Any}","page":"Library API","title":"Sunny.intensity_formula","text":"A custom intensity formula can be specifed by providing a function intensity = f(q,œâ,correlations) and specifying which correlations it requires:\n\nintensity_formula(f,sc::SampledCorrelations, required_correlations; kwargs...)\n\nThe function is intended to be specified using do notation. For example, this custom formula sums the off-diagonal correlations:\n\nrequired = [(:Sx,:Sy),(:Sy,:Sz),(:Sx,:Sz)]\nintensity_formula(sc,required,return_type = ComplexF64) do k, œâ, off_diagonal_correlations\n    sum(off_diagonal_correlations)\nend\n\nIf your custom formula returns a type other than Float64, use the return_type keyword argument to flag this.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{Function, SpinWaveTheory, AbstractVector{Int64}}","page":"Library API","title":"Sunny.intensity_formula","text":"formula = intensity_formula(swt::SpinWaveTheory; kernel = ...)\n\nEstablish a formula for computing the scattering intensity by diagonalizing the hamiltonian H(q) using Linear Spin Wave Theory.\n\nIf kernel = delta_function_kernel, then the resulting formula can be used with intensities_bands.\n\nIf kernel is an energy broadening kernel function, then the resulting formula can be used with intensities_broadened. Energy broadening kernel functions can either be a function of Œîœâ only, e.g.:\n\nkernel = Œîœâ -> ...\n\nor a function of both the energy transfer œâ and of Œîœâ, e.g.:\n\nkernel = (œâ,Œîœâ) -> ...\n\nThe integral of a properly normalized kernel function over all Œîœâ is one.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}","page":"Library API","title":"Sunny.intensity_formula","text":"intensity_formula([swt or sc], contraction_mode::Symbol)\n\nSunny has several built-in formulas that can be selected by setting contraction_mode to one of these values:\n\n:trace (default), which yields operatornametr ùíÆ(qœâ) = _Œ± ùíÆ^Œ±Œ±(qœâ)\n:perp, which contracts ùíÆ^Œ±Œ≤(qœâ) with the dipole factor Œ¥_Œ±Œ≤ - q_Œ±q_Œ≤, returning the unpolarized intensity.\n:full, which will return all elements ùíÆ^Œ±Œ≤(ùê™œâ) without contraction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Library API","title":"Sunny.lattice_params","text":"lattice_params(latvecs::Mat3)\n\nCompute the lattice parameters (a b c Œ± Œ≤ Œ≥) for the three lattice vectors provided as columns of latvecs. The inverse mapping is lattice_vectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_vectors-NTuple{6, Any}","page":"Library API","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Œ± Œ≤ Œ≥) in degrees. The inverse mapping is lattice_params.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.load_nxs-Tuple{Any}","page":"Library API","title":"Sunny.load_nxs","text":"params, signal = load_nxs(filename)\n\nGiven the name of a Mantid-exported MDHistoWorkspace file, load the BinningParameters and the signal from that file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lorentzian-Tuple{Any, Any}","page":"Library API","title":"Sunny.lorentzian","text":"lorentzian(x, Œ∑)\n\nReturns Œ∑(œÄ(x^2 + Œ∑^2)).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.magnetic_moment-Tuple{System, Any}","page":"Library API","title":"Sunny.magnetic_moment","text":"magnetic_moment(sys::System, site::Site)\n\nGet the magnetic moment for a Site. This is the spin dipole multiplied by the Bohr magneton and the local g-tensor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.merge!-Tuple{SampledCorrelations, Vararg{Any}}","page":"Library API","title":"Sunny.merge!","text":"merge!(sc::SampledCorrelations, others...)\n\nAccumulate the samples in others (one or more SampledCorrelations) into sc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.minimize_energy!","text":"minimize_energy!(sys::System{N}; maxiters=100, subiters=20,\n                 method=Optim.ConjugateGradient(), kwargs...) where N\n\nOptimizes the spin configuration in sys to minimize energy. A total of maxiters iterations will be attempted, with restarts after every subiters iterations. The remaining kwargs will be forwarded to the optimize method of the Optim.jl package.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.polarize_spins!","text":"polarize_spins!(sys::System, dir)\n\nPolarize all spins in the system along the direction dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.position_to_site-Tuple{System, Any}","page":"Library API","title":"Sunny.position_to_site","text":"position_to_site(sys::System, r)\n\nConverts a position r to four indices of a Site. The coordinates of r are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using reshape_supercell.\n\nExample\n\n# Find the `site` at the center of a unit cell which is displaced by four\n# multiples of the first lattice vector\nsite = position_to_site(sys, [4.5, 0.5, 0.5])\n\n# Print the dipole at this site\nprintln(sys.dipoles[site])\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.powder_average_binned-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}","page":"Library API","title":"Sunny.powder_average_binned","text":"powder_average_binned(sc::SampledCorrelations, radial_binning_parameters; formula\n                     œâ_binning_parameters, integrated_kernel = nothing, bzsize = nothing)\n\nThis function emulates the experimental situation of \"powder averaging,\" where only the magnitude (and not the direction) of the momentum transfer is resolvable. The intensities are binned similarly to intensities_binned, but the histogram x-axis is |k| in absolute units, which is a nonlinear function of kx,ky,kz. The y-axis is energy.\n\nRadial binning parameters are specified as tuples (start,end,bin_width), e.g. radial_binning_parameters = (0,6œÄ,6œÄ/55).\n\nEnergy broadening is supported in the same way as intensities_binned, and this function accepts the same kind of intensity_formula.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_bond-Tuple{Crystal, Bond}","page":"Library API","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)\n\nPrints symmetry information for bond bond. A symmetry-equivalent reference bond b_ref can optionally be provided to fix the meaning of the coefficients A, B, ...\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_site-Tuple{Any, Any}","page":"Library API","title":"Sunny.print_site","text":"print_site(cryst, i; R=I)\n\nPrint symmetry information for the site i, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix R can be provided to define the reference frame for expression of the anisotropy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_stevens_expansion-Tuple{Matrix{ComplexF64}}","page":"Library API","title":"Sunny.print_stevens_expansion","text":"function print_stevens_expansion(op)\n\nPrints a local Hermitian operator as a linear combination of Stevens operators. This function works on explicit matrix representations.\n\nExamples\n\nS = spin_matrices(N=5)\nprint_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)\n# Prints: (1/20)ùí™‚ÇÑ‚ÇÄ + (1/4)ùí™‚ÇÑ‚ÇÑ + 102/5\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_suggested_frame-Tuple{Crystal, Int64}","page":"Library API","title":"Sunny.print_suggested_frame","text":"print_suggested_frame(cryst, i; digits=4)\n\nPrint a suggested reference frame, as a rotation matrix R, that can be used as input to print_site(). This is useful to simplify the description of allowed anisotropies.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_symmetry_table-Tuple{Crystal, Any}","page":"Library API","title":"Sunny.print_symmetry_table","text":"print_symmetry_table(cryst::Crystal, max_dist)\n\nPrint symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist), where Bond(i, i, [0,0,0]) refers to a single site i.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.print_wrapped_intensities","text":"print_wrapped_intensities(sys::System; nmax=10)\n\nFor Bravais lattices: Prints up to nmax wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are na√Øvely averaged over sublattices, without incorporating phase shift information. Only wavevectors within the first Brillouin zone are printed. Wavevector coordinates are given in reciprocal lattice units, such that each coordinate is between -12 and 12.  The output from this function will typically be used as input to suggest_magnetic_supercell.\n\nBecause this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use instant_correlations instead.\n\nThe weights printed by print_wrapped_intensities may be given a physical interpretation as follows: All possible q-vectors are periodically wrapped into the first Brillouin zone, and the average over their corresponding instantaneous structure factor intensities produce the output weights.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_delta-Tuple{Any}","page":"Library API","title":"Sunny.propose_delta","text":"propose_delta(magnitude)\n\nGenerate a proposal function that adds a Gaussian perturbation to the existing spin state. In :dipole mode, the procedure is to first introduce a random three-vector perturbation ùê¨ = ùê¨ + ùê¨ Œæ and then return the properly normalized spin ùê¨ (ùê¨ùê¨). Each component of the random vector Œæ is Gaussian distributed with a standard deviation of magnitude; the latter is dimensionless and typically smaller than one. \n\nIn :SUN mode, the procedure is analogous, but now involving Gaussian perturbations to each of the N complex components of an SU(N) coherent state.\n\nIn the limit of very large magnitude, this function coincides with propose_uniform.\n\nFor use with LocalSampler.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.propose_flip","text":"propose_flip\n\nFunction to propose pure spin flip updates in the context of a LocalSampler. Dipoles are flipped as ùê¨  -ùê¨. SU(N) coherent states are flipped using the time-reversal operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_uniform","page":"Library API","title":"Sunny.propose_uniform","text":"propose_uniform\n\nFunction to propose a uniformly random spin update in the context of a LocalSampler. In :dipole mode, the result is a random three-vector with appropriate normalization. In :SUN mode, the result is a random SU(N) coherent state with appropriate normalization.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.randomize_spins!","text":"randomize_spins!(sys::System)\n\nRandomizes all spins under appropriate the uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reciprocal_lattice_vectors-Tuple{Crystal}","page":"Library API","title":"Sunny.reciprocal_lattice_vectors","text":"reciprocal_lattice_vectors(cryst::Crystal)\n\nReturns the 33 matrix (ùêõ‚ÇÅùêõ‚ÇÇùêõ‚ÇÉ) with columns ùêõ·µ¢ as reciprocal lattice vectors. These are defined to satisfy ùêõ·µ¢ùêö‚±º = 2œÄŒ¥·µ¢‚±º, where (ùêö‚ÇÅùêö‚ÇÇùêö‚ÇÉ) are the lattice vectors used to construct cryst.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}","page":"Library API","title":"Sunny.reciprocal_space_path","text":"reciprocal_space_path(cryst::Crystal, qs, density)\n\nReturns a pair (path, xticks). The path return value is a list of wavevectors that samples linearly between the provided wavevectors qs. The xticks return value can be used to label the special ùê™ values on the x-axis of a plot.\n\nSpecial note about units: the wavevectors qs must be provided in reciprocal lattice units (RLU) for the given crystal, but the sampling density must be specified in units of inverse length. The path will therefore include more samples between q-points that are further apart in absolute Fourier distance (units of inverse length).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reciprocal_space_path_bins-Tuple{Any, Any, Any, Vararg{Any}}","page":"Library API","title":"Sunny.reciprocal_space_path_bins","text":"reciprocal_space_path_bins(sc,qs,density,args...;kwargs...)\n\nTakes a list of wave vectors, qs in R.L.U., and builds a series of histogram BinningParameters whose first axis traces a path through the provided points. The second and third axes are integrated over according to the args and kwargs, which are passed through to slice_2D_binning_parameters.\n\nAlso returned is a list of marker indices corresponding to the input points, and a list of ranges giving the indices of each histogram x-axis within a concatenated histogram. The density parameter is given in samples per reciprocal lattice unit (R.L.U.).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}","page":"Library API","title":"Sunny.reciprocal_space_shell","text":"reciprocal_space_shell(cryst::Crystal, radius, n)\n\nSample n points on the reciprocal space sphere with a given radius (units of inverse length).\n\nExamples\n\n# Sample wavevectors on the sphere at fixed density\nreciprocal_space_shell(cryst, r, 4œÄ*r^2*density)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reference_bonds-Tuple{Crystal, Float64}","page":"Library API","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.remove_periodicity!","text":"remove_periodicity!(sys::System, dims)\n\nRemove periodic interactions along the dimensions where dims is true. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nExample\n\n# Remove periodic boundaries along the 1st and 3rd dimensions\nremove_periodicity!(sys::System, (true, false, true))\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.repeat_periodically","text":"repeat_periodically(sys::System{N}, counts) where N\n\nCreates a System identical to sys but repeated a given number of times in each dimension, specified by the tuple counts.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.reshape_supercell","text":"reshape_supercell(sys::System, A)\n\nMaps an existing System to a new one that has the shape and periodicity of a requested supercell. The columns of the 33 integer matrix A represent the supercell lattice vectors measured in units of the original crystal lattice vectors.\n\nThe crystal unit cell may also need to be reshaped to achieve the desired periodicity of the requested supercell. If this is the case, the returned System object will be missing symmetry information. Consequently, certain operations will be unavailable for this system, e.g., setting interactions by symmetry propagation. In practice, one can set all interactions using the original system, and then reshape as a final step.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.resize_supercell","text":"resize_supercell(sys::System{N}, latsize) where N\n\nCreates a System identical to sys but enlarged to a given number of unit cells in each lattice vector direction.\n\nAn error will be thrown if sys is incommensurate with latsize. Use reshape_supercell instead to reduce the volume, or to perform an incommensurate reshaping.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.rotate_operator-Tuple{Matrix, Any}","page":"Library API","title":"Sunny.rotate_operator","text":"rotate_operator(A, R)\n\nRotates the local quantum operator A according to the 33 rotation matrix R.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.rotation_in_rlu-Tuple{Crystal, Any, Any}","page":"Library API","title":"Sunny.rotation_in_rlu","text":"rotation_in_rlu(cryst::Crystal, axis, angle)\n\nReturns a 33 matrix that rotates wavevectors in reciprocal lattice units (RLU). The axis vector is a real-space direction in absolute units (but arbitrary magnitude), and the angle is in radians.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N","page":"Library API","title":"Sunny.set_coherent!","text":"set_coherent!(sys::System, Z, site::Site)\n\nSet a coherent spin state at a Site using the N complex amplitudes in Z.\n\nFor a standard SpinInfo, these amplitudes will be interpreted in the eigenbasis of ùíÆ·∂ª. That is, Z[1] represents the amplitude for the basis state fully polarized along the z-direction, and subsequent components represent states with decreasing angular momentum along this axis (m = S S-1  -S).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N","page":"Library API","title":"Sunny.set_dipole!","text":"set_dipole!(sys::System, dir, site::Site)\n\nPolarize the spin at a Site along the direction dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N","page":"Library API","title":"Sunny.set_exchange!","text":"set_exchange!(sys::System, J, bond::Bond; biquad=0.)\n\nSets a 3√ó3 spin-exchange matrix J along bond, yielding a pairwise interaction energy ùêí_iJ ùêí_j. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter bond has the form Bond(i, j, offset), where i and j are atom indices within the unit cell, and offset is a displacement in unit cells.\n\nThe parameter J may be scalar or matrix-valued. As a convenience, dmvec(D) can be used to construct the antisymmetric part of the exchange, where D is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be ùêÉ(ùêí_iùêí_j).\n\nThe optional parameter biquad defines the strength b for scalar biquadratic interactions of the form b (ùêí_iùêí_j)¬≤ For systems restricted to dipoles, b will be automatically renormalized for maximum consistency with the more variationally accurate SU(N) mode. This renormalization introduces also a correction to the quadratic part of the exchange.\n\nExamples\n\nusing Sunny, LinearAlgebra\n\n# An explicit exchange matrix\nJ1 = [2 3 0;\n     -3 2 0;\n      0 0 2]\nset_exchange!(sys, J1, bond)\n\n# An equivalent Heisenberg + DM exchange \nJ2 = 2*I + dmvec([0,0,3])\nset_exchange!(sys, J2, bond)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N","page":"Library API","title":"Sunny.set_exchange_at!","text":"set_exchange_at!(sys::System, J, site1::Site, site2::Site; biquad=0., offset=nothing)\n\nSets the exchange interaction along the single bond connecting two Sites, ignoring crystal symmetry. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nIf the system is relatively small, the direction of the bond can be ambiguous due to possible periodic wrapping. Resolve this ambiguity by passing an explicit offset vector, in multiples of unit cells.\n\nSee also set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field!-Tuple{System, Any}","page":"Library API","title":"Sunny.set_external_field!","text":"set_external_field!(sys::System, B::Vec3)\n\nSets the external field B that couples to all spins.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field_at!-Tuple{System, Any, Any}","page":"Library API","title":"Sunny.set_external_field_at!","text":"set_external_field_at!(sys::System, B::Vec3, site::Site)\n\nSets a Zeeman coupling between a field B and a single spin. Site includes a unit cell and a sublattice index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_onsite_coupling!-Union{Tuple{N}, Tuple{System{N}, Matrix{ComplexF64}, Int64}} where N","page":"Library API","title":"Sunny.set_onsite_coupling!","text":"set_onsite_coupling!(sys::System, op::Matrix{ComplexF64}, i::Int)\n\nSet the single-ion anisotropy for the ith atom of every unit cell, as well as all symmetry-equivalent atoms. The local operator op may be constructed using spin_operators or stevens_operators.\n\nFor systems restricted to dipoles, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(N) mode.\n\nExamples\n\n# An easy axis anisotropy in the z-direction\nS = spin_operators(sys, i)\nset_onsite_coupling!(sys, -D*S[3]^3, i)\n\n# The unique quartic single-ion anisotropy for a site with cubic point group\n# symmetry\nO = stevens_operators(sys, i)\nset_onsite_coupling!(sys, O[4,0] + 5*O[4,4], i)\n\n# An equivalent expression of this quartic anisotropy, up to a constant shift\nset_onsite_coupling!(sys, 20*(S[1]^4 + S[2]^4 + S[3]^4), i)\n\nSee also spin_operators.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_onsite_coupling_at!-Union{Tuple{N}, Tuple{System{N}, Matrix{ComplexF64}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N","page":"Library API","title":"Sunny.set_onsite_coupling_at!","text":"set_onsite_coupling_at!(sys::System, op::Matrix{ComplexF64}, site::Site)\n\nSets the single-ion anisotropy operator op for a single Site, ignoring crystal symmetry.  The system must support inhomogeneous interactions via to_inhomogeneous.\n\nSee also set_onsite_coupling!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.set_vacancy_at!","text":"set_vacancy_at!(sys::System, site::Site)\n\nMake a single site nonmagnetic. Site includes a unit cell and a sublattice index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}","page":"Library API","title":"Sunny.slice_2D_binning_parameters","text":"slice_2D_binning_parameter(sc::SampledCorrelations, cut_from_q, cut_to_q, cut_bins::Int64, cut_width::Float64; plane_normal = [0,0,1],cut_height = cutwidth)\n\nCreates BinningParameters which make a cut along one dimension of Q-space.\n\nThe x-axis of the resulting histogram consists of cut_bins-many bins ranging from cut_from_q to cut_to_q.  The width of the bins in the transverse direciton is controlled by cut_width and cut_height.\n\nThe binning in the transverse directions is defined in the following way, which sets their normalization and orthogonality properties:\n\ncut_covector = normalize(cut_to_q - cut_from_q)\ntransverse_covector = normalize(plane_normal √ó cut_covector)\ncotransverse_covector = normalize(transverse_covector √ó cut_covector)\n\nIn other words, the axes are orthonormal with respect to the Euclidean metric.\n\nIf the cut is too narrow, there will be very few scattering vectors per bin, or the number per bin will vary substantially along the cut. If the output appears under-resolved, try increasing cut_width.\n\nThe four axes of the resulting histogram are:\n\nAlong the cut\nFist transverse Q direction\nSecond transverse Q direction\nEnergy\n\nThis function can be used without reference to a SampledCorrelations using this alternate syntax to manually specify the bin centers for the energy axis:\n\nslice_2D_binning_parameter(œâ_bincenters, cut_from, cut_to,...)\n\nwhere œâ_bincenters specifies the energy axis, and both cut_from and cut_to are arbitrary covectors, in any units.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.spin_matrices-Tuple{}","page":"Library API","title":"Sunny.spin_matrices","text":"spin_matrices(; N)\n\nConstructs the three spin operators, i.e. the generators of SU(2), in the N-dimensional irrep. See also spin_operators, which determines the appropriate value of N for a given site index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.spin_operators-Union{Tuple{N}, Tuple{System{N}, Int64}} where N","page":"Library API","title":"Sunny.spin_operators","text":"spin_operators(sys, i::Int)\nspin_operators(sys, site::Int)\n\nReturns the three spin operators appropriate to an atom or Site index. Each is an NN matrix of appropriate dimension N.\n\nSee also print_stevens_expansion.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.step!","page":"Library API","title":"Sunny.step!","text":"step!(sys::System, dynamics)\n\nAdvance the spin configuration one dynamical time-step. The dynamics object may be a continuous spin dynamics, such as Langevin or ImplicitMidpoint, or it may be a discrete Monte Carlo sampling scheme such as LocalSampler.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.stevens_operators-Union{Tuple{N}, Tuple{System{N}, Int64}} where N","page":"Library API","title":"Sunny.stevens_operators","text":"stevens_operators(sys, i::Int)\nstevens_operators(sys, site::Int)\n\nReturns a generator of Stevens operators appropriate to an atom or Site index. The return value O can be indexed as O[k,q], where 0  k  6 labels an irrep and q = -k  k. This will produce an NN matrix of appropriate dimension N.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N","page":"Library API","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}","page":"Library API","title":"Sunny.suggest_magnetic_supercell","text":"suggest_magnetic_supercell(qs, latsize)\n\nSuggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors in qs. An upper bound for the supercell is given by latsize, which is measured in units of lattice vectors, and must be commensurate with the wavevectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}","page":"Library API","title":"Sunny.symmetry_equivalent_bonds","text":"symmetry_equivalent_bonds(sys::System, bond::Bond)\n\nGiven a Bond for the original (unreshaped) crystal, return all symmetry equivalent bonds in the System. Each returned bond is represented as a pair of Sites, which may be used as input to set_exchange_at!. Reverse bonds are not included (no double counting).\n\nExample\n\nfor (site1, site2, offset) in symmetry_equivalent_bonds(sys, bond)\n    @assert site1 < site2\n    set_exchange_at!(sys, J, site1, site2; offset)\nend\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.to_inhomogeneous","text":"to_inhomogeneous(sys::System)\n\nReturns a copy of the system that allows for inhomogeneous interactions, which can be set using set_onsite_coupling_at!, set_exchange_at!, and set_vacancy_at!.\n\nInhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}","page":"Library API","title":"Sunny.unit_resolution_binning_parameters","text":"unit_resolution_binning_parameters(sc::SampledCorrelations)\n\nCreate BinningParameters which place one histogram bin centered at each possible (q,œâ) scattering vector of the crystal. This is the finest possible binning without creating bins with zero scattering vectors in them.\n\nThis function can be used without reference to a SampledCorrelations using an alternate syntax to manually specify the bin centers for the energy axis and the lattice size:\n\nunit_resolution_binning_parameters(œâ_bincenters,latsize,[reciprocal lattice vectors])\n\nThe last argument may be a 3x3 matrix specifying the reciprocal lattice vectors, or a Crystal.\n\nLastly, binning parameters for a single axis may be specifed by their bin centers:\n\n(binstart,binend,binwidth) = unit_resolution_binning_parameters(bincenters::Vector{Float64})\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.view_crystal-Tuple{Crystal, Real}","page":"Library API","title":"Sunny.view_crystal","text":"view_crystal(crystal::Crystal, max_dist::Real)\n\nCreate and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using browser().\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.@mix_proposals-Tuple","page":"Library API","title":"Sunny.@mix_proposals","text":"@mix_proposals weight1 propose1 weight2 propose2 ...\n\nMacro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with LocalSampler.\n\nExample\n\n# A proposal function that proposes a spin flip 40% of the time, and a\n# Gaussian perturbation 60% of the time.\n@mix_proposals 0.4 propose_flip 0.6 propose_delta(0.2)\n\n\n\n\n\n","category":"macro"},{"location":"library/#Optional-Makie-extensions","page":"Library API","title":"Optional Makie extensions","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"The following will be enabled through a package extension if either GLMakie or WGLMakie is loaded.","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"plot_spins","category":"page"},{"location":"library/#Sunny.plot_spins","page":"Library API","title":"Sunny.plot_spins","text":"plot_spins(sys::System; arrowscale=1.0, linecolor=:lightgrey,\n           arrowcolor=:red, show_axis=false, show_cell=true,\n           orthographic=false, ghost_radius=0)\n\nPlot the spin configuration defined by sys. Optional parameters include:\n\narrowscale: Scale all arrows by dimensionless factor.\nshow_axis: Show global Cartesian coordinates axis.\nshow_cell: Show original crystallographic unit cell.\northographic: Use camera with orthographic projection.\nghost_radius: Show translucent periodic images up to a radius, given as a multiple of the characteristic distance between sites.\n\n\n\n\n\n","category":"function"},{"location":"library/#Optional-WriteVTK-extensions","page":"Library API","title":"Optional WriteVTK extensions","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"The following will be enabled through a package extension if WriteVTK is loaded.","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"export_vtk","category":"page"},{"location":"library/#Sunny.export_vtk","page":"Library API","title":"Sunny.export_vtk","text":"export_vtk(filename,params::BinningParameters,data)\n\nExport a VTK-compatible file to filename (do not include file extension when specifying the file name) which contains the data as VTK Cell Data on a grid parameterized by params.\n\nAt least one axis of the BinningParameters must be integrated over, since VTK does not support 4D data. See integrate_axes!.\n\n\n\n\n\n","category":"function"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"EditURL = \"../../../examples/fei2_classical.jl\"","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"<a href=\"../../assets/notebooks/fei2_classical.ipynb\" download>Download as a Jupyter notebook</a>","category":"page"},{"location":"examples/fei2_classical/#Structure-Factors-with-Classical-Dynamics","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"","category":"section"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"using Sunny, LinearAlgebra, GLMakie","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"In our previous Case Study: FeI_2, we used linear spin wave theory (LSWT) to calculate the dynamical structure factor. Here, we perform a similar calculation using classical spin dynamics. Because we are interested in the coupled dynamics of spin dipoles and quadrupoles, we employ a classical dynamics of SU(3) coherent states that generalizes the Landau-Lifshitz equation.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Compared to LSWT, simulations using classical dynamics are much slower, and are limited in k-space resolution. However, they make it is possible to capture nonlinear effects associated with finite temperature fluctuations. Classical dynamics are also appealing for studying out-of-equilibrium systems (e.g., relaxation of spin glasses), or systems with quenched inhomogeneities that require large simulation volumes.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"In this tutorial, we show how to study the finite temperature dynamics of FeI_2 using the classical approach. It is important to stress that the estimation of S(ùê™œâ) with classical dynamics is fundamentally a Monte Carlo calculation: sample spin configurations are drawn from thermal equilibrium and used as initial conditions for generating dissipationless trajectories. The correlations of these trajectories are then averaged and used to calculate scattering intensities. It is therefore important to ensure that the initial spin configurations are sampled appropriately and that sufficient statistics are collected. We will demonstrate one approach here.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"As an overview, we will:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Identify the ground state\nMeasure correlation data describing the excitations around that ground state\nUse the correlation data to compute scattering intensities","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"As the implementation of the FeI_2 model is already covered in detail in the LSWT tutorial, we will not repeat it below. Instead, we will assume that you already have defined a sys in the same way with lattice dimensions 444.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"a = b = 4.05012#hide\nc = 6.75214#hide\nlatvecs = lattice_vectors(a, b, c, 90, 90, 120)#hide\npositions = [[0,0,0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]#hide\ntypes = [\"Fe\", \"I\", \"I\"]#hide\nFeI2 = Crystal(latvecs, positions; types)#hide\ncryst = subcrystal(FeI2, \"Fe\")#hide\nsys = System(cryst, (4,4,4), [SpinInfo(1,S=1,g=2)], :SUN, seed=2)#hide\nJ1pm   = -0.236#hide\nJ1pmpm = -0.161#hide\nJ1zpm  = -0.261#hide\nJ2pm   = 0.026#hide\nJ3pm   = 0.166#hide\nJ‚Ä≤0pm  = 0.037#hide\nJ‚Ä≤1pm  = 0.013#hide\nJ‚Ä≤2apm = 0.068#hide\nJ1zz   = -0.236#hide\nJ2zz   = 0.113#hide\nJ3zz   = 0.211#hide\nJ‚Ä≤0zz  = -0.036#hide\nJ‚Ä≤1zz  = 0.051#hide\nJ‚Ä≤2azz = 0.073#hide\nJ1xx = J1pm + J1pmpm#hide\nJ1yy = J1pm - J1pmpm#hide\nJ1yz = J1zpm#hide\nset_exchange!(sys, [J1xx 0.0 0.0; 0.0 J1yy J1yz; 0.0 J1yz J1zz], Bond(1,1,[1,0,0]))#hide\nset_exchange!(sys, [J2pm 0.0 0.0; 0.0 J2pm 0.0; 0.0 0.0 J2zz], Bond(1,1,[1,2,0]))#hide\nset_exchange!(sys, [J3pm 0.0 0.0; 0.0 J3pm 0.0; 0.0 0.0 J3zz], Bond(1,1,[2,0,0]))#hide\nset_exchange!(sys, [J‚Ä≤0pm 0.0 0.0; 0.0 J‚Ä≤0pm 0.0; 0.0 0.0 J‚Ä≤0zz], Bond(1,1,[0,0,1]))#hide\nset_exchange!(sys, [J‚Ä≤1pm 0.0 0.0; 0.0 J‚Ä≤1pm 0.0; 0.0 0.0 J‚Ä≤1zz], Bond(1,1,[1,0,1]))#hide\nset_exchange!(sys, [J‚Ä≤2apm 0.0 0.0; 0.0 J‚Ä≤2apm 0.0; 0.0 0.0 J‚Ä≤2azz], Bond(1,1,[1,2,1]))#hide\nD = 2.165#hide\nS = spin_operators(sys, 1)#hide\nset_onsite_coupling!(sys, -D*S[3]^2, 1)#hide","category":"page"},{"location":"examples/fei2_classical/#Finding-a-ground-state","page":"Structure Factors with Classical Dynamics","title":"Finding a ground state","text":"","category":"section"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Sunny uses the Langevin dynamics of SU(N) coherent states to sample spin configurations from the thermal equlibrium. One first constructs a Langevin integrator. This requires a time step, temperature, and a phenomenological damping parameter Œª that sets the coupling to the thermal bath.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Œît = 0.05/D    # Should be inversely proportional to the largest energy scale\n               # in the system. For FeI2, this is the easy-axis anisotropy,\n               # `D = 2.165` (meV). The prefactor 0.05 is relatively small,\n               # and achieves high accuracy.\nkT = 0.2       # Temperature of the thermal bath (meV).\nŒª = 0.1        # This value is typically good for Monte Carlo sampling,\n               # independent of system details.\n\nlangevin = Langevin(Œît; kT, Œª);\nnothing #hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Sampling with a large number of Langevin time-steps should hopefully thermalize the system to a target temperature. For demonstration purposes, we will here run for a relatively short period of 1,000 timesteps.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"randomize_spins!(sys)\nfor _ in 1:1_000\n    step!(sys, langevin)\nend","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"To inspect the structure of the spin configuration, we use the function minimize_energy! to find a nearby local minimum. Then print_wrapped_intensities provides information about the Fourier modes in reciprocal lattice units (RLU).","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"minimize_energy!(sys)\nprint_wrapped_intensities(sys)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"The wide distribution of intensities indicates an imperfect magnetic order. The defects are immediately apparent in the real-space spin configuration.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"plot_spins(sys)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"In this case, we can find the correct ground state simply by running the Langevin dynamics for longer.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"for _ in 1:10_000\n    step!(sys, langevin)\nend\nminimize_energy!(sys)\nprint_wrapped_intensities(sys)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"This is the perfect single-ùêê ground state. This worked because the temperature kT = 0.2 was carefully selected. It is below the magnetic ordering temperature, but still large enough that the Langevin dynamics could quickly overcome local energy barriers. More complicated magnetic orderings will frequently require more sophisticated sampling schemes. One possibility is simulated annealing, where kT is slowly lowered over the course of the sampling procedure.","category":"page"},{"location":"examples/fei2_classical/#Calculating-Thermal-Averaged-Correlations-\\langle-S{\\alpha\\beta}(ùê™,œâ)\\rangle","page":"Structure Factors with Classical Dynamics","title":"Calculating Thermal-Averaged Correlations langle S^alphabeta(ùê™œâ)rangle","text":"","category":"section"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Now that we have identified an appropriate ground state, we will adjust the temperature so that the system still remains near the ground state, but still has thermal fluctuations.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"kT = 3.5 * meV_per_K     # 3.5K ‚âà 0.30 meV\nlangevin.kT = kT;\nnothing #hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Additionally, since these classical simulations are conducted on a finite-sized lattice, obtaining acceptable resolution in momentum space requires the use of a larger system size. We resize the magnetic supercell to a much larger simulation volume, provided as multiples of the original unit cell.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"sys_large = resize_supercell(sys, (16,16,4)) # 16x16x4 copies of the original unit cell\nplot_spins(sys_large)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"As stressed above, we need to sample multiple spin configurations from the thermal equilibrium distribution. We therefore begin by using Langevin dynamics to bring the system into thermal equilibrium at the new temperature.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"# At the new temperature\nfor _ in 1:10_000\n    step!(sys_large, langevin)\nend","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Now that we are in a state drawn from thermal equilibrium, we are ready to begin collecting correlation data S^alphabeta.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"To collect one sample of spin-spin correlation data, we integrate the Hamiltonian dynamics of SU(N) coherent states. This generates trajectories S^alpha(vec rt). However, note that the spins are only defined at the finitely-many lattice sites, so vec r is discrete. From the trajectories, Sunny computes fourier-transformed correlations S^alphabeta(qomega), where q is discrete for the same reason.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"The correlation data from this sample is now ready to be averaged together with data from other samples to form the thermal average. Samples of correlation data are accumulated and averaged into a SampledCorrelations, which is initialized by calling dynamical_correlations:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"sc = dynamical_correlations(sys_large; Œît=2Œît, nœâ=120, œâmax=7.5)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"dynamical_correlations takes a System and three keyword parameters that determine the œâ information that will be available: an integration step size, the number of œâs to resolve, and the maximum œâ to resolve. For the time step, twice the value used for the Langevin integrator is usually a good choice.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"sc currently contains no data. The first sample can be accumulated into it by calling add_sample!.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"add_sample!(sc, sys_large)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Additional samples can be added after re-sampling new spin configurations from the thermal distribution. The new samples are generated in the same way as the first sample, by running the Langevin dynamics. The dynamics should be run long enough that consecutive samples are uncorrelated, or else the thermal average will converge only very slowly.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"for _ in 1:2\n    for _ in 1:1000               # Enough steps to decorrelate spins\n        step!(sys_large, langevin)\n    end\n    add_sample!(sc, sys_large)    # Accumulate the sample into `sc`\nend","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Now, sc has more samples included:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"sc","category":"page"},{"location":"examples/fei2_classical/#Computing-Scattering-Intensities","page":"Structure Factors with Classical Dynamics","title":"Computing Scattering Intensities","text":"","category":"section"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"With the thermally-averaged correlation data langle S^alphabeta(qomega)rangle in hand, we now need to specify how to extract a scattering intensity from this information. This is done by constructing an intensity_formula. By way of example, we will use a formula which computes the trace of the structure factor and applies a classical-to-quantum temperature-dependent rescaling kT.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"formula = intensity_formula(sc, :trace; kT = kT)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Recall that langle S^alphabeta(qomega)rangle is only available at certain discrete q values, due to the finite lattice size. There are two basic approaches to handling this discreteness. The first approach is to interpolate between the available data using intensities_interpolated. For example, we can plot single-q slices at (0,0,0) and (œÄ,œÄ,œÄ) using this method:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"qs = [[0, 0, 0], [0.5, 0.5, 0.5]]\nis = intensities_interpolated(sc, qs, formula; interpolation = :round)\n\nœâs = available_energies(sc)\nfig = lines(œâs, is[1,:]; axis=(xlabel=\"meV\", ylabel=\"Intensity\"), label=\"(0,0,0)\")\nlines!(œâs, is[2,:]; label=\"(œÄ,œÄ,œÄ)\")\naxislegend()\nfig","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"The resolution in energy can be improved by increasing nœâ (and decreasing Œît), and the general accuracy can be improved by collecting additional samples from the thermal equilibrium.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"For real calculations, one often wants to apply further corrections and more accurate formulas. Here, we apply FormFactor corrections appropriate for Fe2 magnetic ions, and a dipole polarization correction :perp.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"formfactors = [FormFactor(\"Fe2\"; g_lande=3/2)]\nnew_formula = intensity_formula(sc, :perp; kT = kT, formfactors = formfactors)","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Frequently, one wants to extract energy intensities along lines that connect special wave vectors‚Äìa so-called \"spaghetti plot\". The function reciprocal_space_path creates an appropriate horizontal axis for this plot by linearly sampling between provided q-points, with a given sample density.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"points = [[0,   0, 0],  # List of wave vectors that define a path\n          [1,   0, 0],\n          [0,   1, 0],\n          [1/2, 0, 0],\n          [0,   1, 0],\n          [0,   0, 0]]\ndensity = 40\npath, xticks = reciprocal_space_path(cryst, points, density);\nnothing #hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Again using intensities_interpolated, we can evaluate the (interpolated) intensity at each point on the path. Since scattering intensities are only available at a certain discrete (Qomega) points, the intensity on the path can be calculated by interpolating between these discrete points:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"is_interpolated = intensities_interpolated(sc, path, new_formula;\n    interpolation = :linear,       # Interpolate between available wave vectors\n);\n# Add artificial broadening\nis_interpolated_broadened = broaden_energy(sc, is, (œâ, œâ‚ÇÄ)->lorentzian(œâ-œâ‚ÇÄ, 0.05));\nnothing #hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"The second approach to handle the discreteness of the data is to bin the intensity at the discrete points into the bins of a histogram. First, the five sub-histograms are set up using reciprocal_space_path_bins in analogy to reciprocal_space_path.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"cut_width = 0.3\ndensity = 15\nparamsList, markers, ranges = reciprocal_space_path_bins(sc,points,density,cut_width);\nnothing #hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Then, the intensity data is computed using intensities_binned for each sub-histogram:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"total_bins = ranges[end][end]\nenergy_bins = paramsList[1].numbins[4]\nis_binned = zeros(Float64,total_bins,energy_bins)\nintegrated_kernel = integrated_lorentzian(0.05) # Lorentzian broadening\nfor k in eachindex(paramsList)\n    bin_data, counts = intensities_binned(sc,paramsList[k], new_formula;\n        integrated_kernel = integrated_kernel\n    )\n    is_binned[ranges[k],:] = bin_data[:,1,1,:] ./ counts[:,1,1,:]\nend","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"The graph produced by interpolating (top) is similar to the one produced by binning (bottom):","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"fig = Figure()\nax_top = Axis(fig[1,1],ylabel = \"meV\",xticklabelrotation=œÄ/8,xticklabelsize=12;xticks)\nax_bottom = Axis(fig[2,1],ylabel = \"meV\",xticks = (markers, string.(points)),xticklabelrotation=œÄ/8,xticklabelsize=12)\n\nheatmap!(ax_top,1:size(is_interpolated,1), œâs, is_interpolated;\n    colorrange=(0.0,0.07),\n)\n\nheatmap!(ax_bottom,1:size(is_binned,1), œâs, is_binned;\n    colorrange=(0.0,0.05),\n)\n\nfig","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Note that we have clipped the colors in order to make the higher-energy excitations more visible.","category":"page"},{"location":"examples/fei2_classical/#Unconventional-R.L.U.-Systems-and-Constant-Energy-Cuts","page":"Structure Factors with Classical Dynamics","title":"Unconventional R.L.U. Systems and Constant Energy Cuts","text":"","category":"section"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Often it is useful to plot cuts across multiple wave vectors but at a single energy. We'll pick an energy,","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"œâidx = 60\ntarget_œâ = œâs[œâidx]\nprintln(\"target_œâ = $(target_œâ)\")#hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"and take a constant-energy cut at that energy. The most straightforward way is to make a plot whose axes are aligned with the conventional reciprocal lattice of the crystal. This is accomplished using unit_resolution_binning_parameters:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"params = unit_resolution_binning_parameters(sc)\nparams.binstart[1:2] .= -1 # Expand plot range slightly\n\n# Set energy integration range\nomega_width = 0.3\nparams.binstart[4] = target_œâ - (omega_width/2)\nparams.binend[4] = target_œâ # `binend` should be inside (e.g. at the center) of the range\nparams.binwidth[4] = omega_width\n\nintegrate_axes!(params, axes = 3) # Integrate out z direction entirely\nparams#hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"In each of the following plots, black dashed lines represent (direct) lattice vectors. Since these plots are in reciprocal space, direct lattice vectors are represented as covectors (i.e. coordinate grids) instead of as arrows.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"is, counts = intensities_binned(sc,params,new_formula)\n\nfig = Figure()\nax = Axis(fig[1,1];\n    title=\"Œîœâ=0.3 meV (Binned)\", aspect=true,\n    xlabel = \"[H, 0, 0]\",\n    ylabel = \"[0, K, 0]\"\n)\nbcs = axes_bincenters(params)\nhm = heatmap!(ax,bcs[1],bcs[2],is[:,:,1,1] ./ counts[:,:,1,1])\nfunction add_lines!(ax,params)#hide\n  bes = Sunny.axes_binedges(params)#hide\n  hrange = range(-2,2,length=17)#hide\n  linesegments!(ax,[(Point2f(params.covectors[1,1:3] ‚ãÖ [h,-10,0],params.covectors[2,1:3] ‚ãÖ [h,-10,0]),Point2f(params.covectors[1,1:3] ‚ãÖ [h,10,0],params.covectors[2,1:3] ‚ãÖ [h,10,0])) for h = hrange],linestyle=:dash,color=:black)#hide\n  krange = range(-2,2,length=17)#hide\n  linesegments!(ax,[(Point2f(params.covectors[1,1:3] ‚ãÖ [-10,k,0],params.covectors[2,1:3] ‚ãÖ [-10,k,0]),Point2f(params.covectors[1,1:3] ‚ãÖ [10,k,0],params.covectors[2,1:3] ‚ãÖ [10,k,0])) for k = krange],linestyle=:dash,color=:black)#hide\n  xlims!(ax,bes[1][1],bes[1][end])#hide\n  ylims!(ax,bes[2][1],bes[2][end])#hide\nend#hide\nadd_lines!(ax,params)\nColorbar(fig[1,2], hm);\nfig","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"In the above plot, the dashed-line (direct) lattice vectors are clearly orthogonal. However, we know that in real space, the lattice vectors a and b are not orthogonal, but rather point along the edges of a hexagon (see lower left corner):","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"<br><img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_crystal.jpg\" width=\"400\"><br>","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Thus, plotting the direct lattice vectors as orthogonal (even in reciprocal space) is somewhat misleading. Worse yet, the [H,0,0] by [0,K,0] plot apparently loses the 6-fold symmetry of the crystal! Lastly, if one works out the components of the real-space metric with respect to the axes of the plot, one finds that there are non-zero off-diagonal entries,","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"latvecs = sys.crystal.latvecs\nmetric = latvecs' * I(3) * latvecs","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"so real-space rotations and angles map into reciprocal space rotations angles in a complicated way.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"To resolve these important issues, we want to use axes which are orthogonal (i.e. they diagonalize the metric and solve all of the problems just mentioned). The canonical choice is to use the combination frac12a + b of lattice vectors (equiv. a^* - frac12b^*), which is orthogonal to a:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"(latvecs * [1/2,1,0]) ‚ãÖ (latvecs * [1,0,0]) == 0","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"This new vector frac12a+b is visibly orthogonal to a in real space:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"f = Figure()#hide\nax = Axis(f[1,1])#hide\narrows!(ax,[Point2f(0,0),Point2f(latvecs[1:2,1] ./ 2)],[Vec2f(latvecs[1:2,1] ./ 2), Vec2f(latvecs[1:2,2])],arrowcolor = :blue,arrowsize = 30.,linewidth = 5.,linecolor = :blue)#hide\narrows!(ax,[Point2f(0,0)],[Vec2f(latvecs[1:2,:] * [1/2,1,0])],arrowcolor = :red,arrowsize = 30.,linewidth = 5.,linecolor = :red, linestyle = :dash)#hide\nscatter!(ax,[Point2f(latvecs[1:2,:] * [a,b,0]) for a in -1:1, b in -1:1][:],color = :black)#hide\nannotations!(ax,[\"0\",\"0+b\",\"0+a\", \"a/2\", \"b\"],[Point2f(0,-0.3),Point2f(latvecs[1:2,2]) .- Vec2f(0,0.3),Point2f(latvecs[1:2,1]) .- Vec2f(0,0.3),Point2f(latvecs[1:2,1] ./ 4) .- Vec2f(0,0.3),Point2f(latvecs[1:2,1] ./ 2) .+ Vec2f(latvecs[1:2,2] ./ 2) .+ Vec2f(0.3,0.3)],color=[:black,:black,:black,:blue,:blue])#hide\nf#hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"To use \"projection onto the new vector\" as a histogram axis, only a single change is needed to the binning parameters. The second covector (previously b) must be swapped out for frac12a + b (recall that reciprocal space covectors, such as those used in BinningParameters correspond to direct space vectors).","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"params.covectors[2,1:3] = [1/2,1,0] # [1/2,1,0] times [a;b;c] is (a/2 + b)\nparams#hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"The second axis of the histogram now agrees with what is conventionally labelled as [H,-H/2,0].","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"warning: Length of the new vector\nNote that, although frac12a+b is orthogonal to a, it is not the same length as a. Instead, it is sqrt(3/4) times as long. Note the unsymmetrical axes labels in the plots that follow as a direct result of this!","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"# Zoom out horizontal axis\nparams.binstart[1], params.binend[1] = -2, 2\n\n# Adjust vertical axis bounds to account for\n# length of a/2 + b\nparams.binstart[2], params.binend[2] = -2 * sqrt(3/4), 2 * sqrt(3/4)\n\n# Re-compute in the new coordinate system\nis, counts = intensities_binned(sc,params,new_formula)\n\nfig = Figure(; resolution=(1200,500))#hide\nax_right = Axis(fig[1,3];#hide\n    title=\"œâ‚âà$(round(target_œâ, digits=2)) meV with Œîœâ=0.3 meV (Binned)\", aspect=true,#hide\n    xlabel = \"[H, -1/2H, 0]\"#hide\n)#hide\nbcs = axes_bincenters(params)#hide\nhm_right = heatmap!(ax_right,bcs[1],bcs[2],is[:,:,1,1] ./ counts[:,:,1,1])#hide\nadd_lines!(ax_right,params)\nColorbar(fig[1,4], hm_right);#hide\nnothing #hide","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"For comparison purposes, we will make the same plot using intensities_interpolated to emulate zero-width bins. This time, it's more convenient to think in terms of reciprocal vectors a^* and b^*. Now, our coordinate transformation consists of establishing a new, orthogonal basis to specify our wave vectors: a^* - frac12b^*, b^* and c^*. Writing this in matrix form allows us to sample a rectilinear grid of wave vectors in this frame. Finally, we'll convert these back into the original RLU system for input into Sunny.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"# New basis matrix\nA = [1    0 0\n     -1/2 1 0\n     0    0 1]\n\n# Define our grid of wave vectors\nnpoints = 60\nas = range(-2, 2, npoints)\nbs = range(-3/‚àö3, 3/‚àö3, npoints)\nqs_ortho = [[a, b, 0] for a in as, b in bs]\n\n# Convert to original RLU system for input to Sunny\nqs = [A * q for q in qs_ortho]\n\n# Use interpolation to get intensities\nis = intensities_interpolated(sc, qs, new_formula; interpolation=:linear)\n\nax_left = Axis(fig[1,2];#hide\n    title=\"œâ‚âà$(round(œâs[œâidx], digits=2)) meV (Interpolated)\", aspect=true,#hide\n    xlabel = \"[H, -1/2H, 0]\", ylabel = \"[0, K, 0]\"#hide\n)#hide\nhm_left = heatmap!(ax_left, as, bs, is[:,:,œâidx])#hide\nadd_lines!(ax_left,params)\nColorbar(fig[1,1], hm_left);#hide\nfig","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Now, not only are the dashed-line lattice vectors no longer misleadingly orthogonal, but the six-fold symmetry has been restored as well! Further, the metric has been diagonalized:","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"metric = (latvecs * inv(A'))' * I(3) * (latvecs * inv(A'))","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"Finally, we note that instantaneous structure factor data, ùíÆ(ùê™), can be obtained from a dynamic structure factor with instant_intensities_interpolated. Here we'll reuse the grid of wave vectors we generated above.","category":"page"},{"location":"examples/fei2_classical/","page":"Structure Factors with Classical Dynamics","title":"Structure Factors with Classical Dynamics","text":"is_static = instant_intensities_interpolated(sc, qs, new_formula; interpolation = :linear)\n\nhm = heatmap(as, bs, is_static;\n    axis=(\n        title=\"Instantaneous Structure Factor\",\n        xlabel = \"[H, -1/2H, 0]\",\n        ylabel = \"[0, K, 0]\",\n        aspect=true\n    )\n)\nColorbar(hm.figure[1,2], hm.plot)\nhm","category":"page"},{"location":"versions/#Version-0.5.1","page":"Version History","title":"Version 0.5.1","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Fix binning edge cases.\nplot_spins accepts resolution argument.","category":"page"},{"location":"versions/#Version-0.5.0","page":"Version History","title":"Version 0.5.0","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"New features.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Support for Linear Spin Wave Theory in :dipole and :SUN modes. (Thanks Hao Zhang!)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"New function minimize_energy! to efficiently find an optimal configuration of spin dipoles or SU(N) coherent states.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Major refactors and enhancements to intensity calculations. This new interface allows unification between LSWT and classical spin dynamics calculations. This interface allows: Custom observables as local quantum operators, better support for linebroadening, and automatic binning to facilitate comparison with experimental data. See intensity_formula for documentation. Use load_nxs to load experimental neutron scattering data.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Breaking changes.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Require Julia 1.9.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Replace set_anisotropy! with a new function set_onsite_coupling! (and similarly set_onsite_coupling_at!). The latter expects an explicit matrix representation for the local Hamiltonian. This can be constructed, e.g., as a linear combination of stevens_operators, or as a polynomial of spin_operators. To understand the mapping between these two, the new function print_stevens_expansion acts on an arbitrary local operator.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Remove set_biquadratic!. Instead, use an optional keyword argument biquad to set_exchange!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename DynamicStructureFactor to dynamical_correlations. Similarly, replace InstantStructureFactor with instant_correlations. The return type has been renamed SampledCorrelations to emphasize that the object may be holding thermodynamic samples, which are collected using add_sample!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Remove intensities function. Instead, use one of intensities_interpolated or intensities_binned. These will require an intensity_formula, which defines a calculator (e.g., LSWT).","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename connected_path to reciprocal_space_path, which now returns an xticks object that can be used in plotting. Replace spherical_shell with reciprocal_space_shell that functions similarly.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename polarize_spin! to set_dipole! for consistency with set_coherent!. The behavior of the former function is unchanged: the spin at a given site will still be polarized along the provided direction.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename all_sites to eachsite consistent with Julia convention for iterators.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename reshape_geometry to reshape_supercell, which is the fundamental reshaping function. Rename resize_periodically to resize_supercell.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The constructor SpinInfo now requires a g-factor or tensor as a named argument.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The constructor FormFactor no longer accepts an atom index. Instead, the form factors are associated with site-symmetry classes in order of appearance.","category":"page"},{"location":"versions/#Version-0.4.3","page":"Version History","title":"Version 0.4.3","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Experimental support for linear SpinWaveTheory, implemented in SU(N) mode. This module may evolve rapidly.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Implement renormalization of single-ion anisotropy and biquadratic interactions when in :dipole mode. This makes the model more faithful to the quantum mechanical Hamiltonian, but is also a breaking change.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Various improvements and bugfixes for to_inhomogeneous. Setting inhomogeneous interactions via set_exchange_at! should now infer the correct bond offset direction, or will report an ambiguity error. Ambiguities can be resolved by passing an explicit offset.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The function remove_periodicity! disables periodicity along specified dimensions.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename StaticStructureFactor to InstantStructureFactor.","category":"page"},{"location":"versions/#Version-0.4.2","page":"Version History","title":"Version 0.4.2","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Introduce LocalSampler, a framework for MCMC sampling with local spin updates.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename print_dominant_wavevectors to print_wrapped_intensities to reduce confusion with the physical instantaneous intensities.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The function spherical_shell now takes a radius in physical units of inverse √Ö.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"New exported functions global_position, magnetic_moment, all_sites.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Remove all uses of Base.deepcopy which resolves crashes.","category":"page"},{"location":"versions/#Version-0.4.1","page":"Version History","title":"Version 0.4.1","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The function to_inhomogeneous creates a system that supports inhomogeneous interactions, which can be set using set_exchange_at!, etc.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"set_biquadratic! replaces set_exchange_with_biquadratic!.","category":"page"},{"location":"versions/#Version-0.4.0","page":"Version History","title":"Version 0.4.0","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"This update includes many breaking changes, and is missing some features of 0.3.0.","category":"page"},{"location":"versions/#Creating-a-spin-System","page":"Version History","title":"Creating a spin System","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename SpinSystem to System. Its constructor now has the form,","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"System(crystal, latsize, infos, mode)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter infos is now a list of SpinInfo objects. Each defines spin angular momentum S = frac12 1 frac32 , and an optional g-factor or tensor.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter mode is one of :SUN or :dipole.","category":"page"},{"location":"versions/#Setting-interactions","page":"Version History","title":"Setting interactions","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Interactions are now added mutably to an existing System using the following functions: set_external_field!, set_exchange!, set_onsite_coupling!, enable_dipole_dipole!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"As a convenience, one can use dmvec(D) to convert a DM vector to a 33 antisymmetric exchange matrix.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Fully general single-ion anisotropy is now possible. The function set_onsite_coupling! expects the single ion anisotropy to be expressed as a polynomial in symbolic spin operators ùíÆ, or as a linear combination of symbolic Stevens operators ùí™. For example, an easy axis anisotropy in the direction n may be written D*(ùíÆ‚ãÖn)^2.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Stevens operators ùí™[k,q] admit polynomial expression in spin operators ùíÆ[Œ±]. Conversely, a polynomial of spin operators can be expressed as a linear combination of Stevens operators. To see this expansion use print_anisotropy_as_stevens.","category":"page"},{"location":"versions/#Inhomogeneous-field","page":"Version History","title":"Inhomogeneous field","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"An external field can be applied to a single site with set_external_field_at!. ","category":"page"},{"location":"versions/#Structure-factor-rewrite","page":"Version History","title":"Structure factor rewrite","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The calculation of structure factors has been completely rewritten. For the new interface, see the Structure Factor Calculations page.","category":"page"},{"location":"versions/#Various","page":"Version History","title":"Various","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The \"Sampler\" interface is in flux. Langevin replaces both LangevinHeunP and LangevinSampler. Local spin-flip Monte Carlo sampling methods are temporarily broken.\nrepeat_periodically replaces extend_periodically.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Additional related functions include resize_periodically and reshape_geometry, the latter being fundamental.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"print_symmetry_table replaces print_bond_table().","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The new function includes the list of symmetry-allowed single ion anisotropies in addition to exchange interactions.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"When reading CIF files, the field _atom_site_label is now used in place of the field _atom_site_type_symbol.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"This is required for correctness. The field _atom_site_label is guaranteed to be present, and is guaranteed to be a distinct label for each symmetry-inequivalent site. Code that explicitly referred to site labels (e.g. in calls to subcrystal) will need to be updated to use the new label.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"EditURL = \"../../../examples/one_dim_chain.jl\"","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"<a href=\"../../assets/notebooks/one_dim_chain.ipynb\" download>Download as a Jupyter notebook</a>","category":"page"},{"location":"examples/one_dim_chain/#Fitting-model-parameters-in-a-1D-spin-1-ferromagnetic-chain","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"","category":"section"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"using Sunny, LinearAlgebra, GLMakie, Optim","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"In this Example, we consider a 1D chain of spin-1 sites. The sites along the chain interact via a ferromagnetic nearest-neighbor interaction Jsum_langle ijrangle mathbfS_i cdot mathbfS_j, with J  0. By default, the ground state would be ferromagnetic and highly degenerate, since the spins can align in any direction. An on-site interaction, Dsum_i (S^z_i)^2 breaks this isotropy by making it easier for the spins to align in the pm z direction than in any other orientation. Thus, the entire Hamiltonian is:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"mathcalH = overbraceJsum_langle ijrangle mathbfS_i cdot mathbfS_j^textFerromagnetic overbrace-Dsum_i (S^z_i)^2^textEasy-axis single-ion anisotropy","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"The goal of this Example is to illustrate how to determine the parameters J and D from \"experiment\" data by fitting using Sunny's implementation of Linear Spin Wave Theory. In our case, the \"experiment\" data will actually be simulation data produced using Landau-Lifschitz dynamics.","category":"page"},{"location":"examples/one_dim_chain/#Creating-simulated-\"experiment\"-data-using-Landau-Lifschitz-dynamics","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Creating simulated \"experiment\" data using Landau-Lifschitz dynamics","text":"","category":"section"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Our simulated data will use ground truth values J_0 = -1textmeV and D_0 = 10textmeV with a lattice spacing a = 10 angstrom.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"We begin with a 1D chain of spin-1 sites along the x direction.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"# Establish geometry of the unit cell.\n# \"P1\" is required due to the rotational symmetry about the\n# x-axis being broken.\nchain_spacing = 10. # Angstrom\nlatvecs = chain_spacing * I(3)\none_dimensional_chain = Crystal(latvecs,[[0,0,0]],\"P1\")\n\n# Establish geometry of the whole chain.\nchain_length = 16 # Number of atoms\nlatsize = (chain_length,1,1) # 1D chain is Nx1x1 lattice\nspin_one_chain = System(one_dimensional_chain, latsize, [SpinInfo(1,S=1,g=2)], :SUN)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Configure the nearest-neighbor interaction:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"# Scalar J indicates J*(S·µ¢‚ãÖS‚±º)\nJ_groundtruth = -1.\n\n# Interaction is with the left and right next neighbor along the chain (x-direction)\nnearest_neighbor_right = Bond(1,1,(1,0,0))\nnearest_neighbor_left = Bond(1,1,(-1,0,0))\n\nset_exchange!(spin_one_chain,J_groundtruth,nearest_neighbor_right)\nset_exchange!(spin_one_chain,J_groundtruth,nearest_neighbor_left)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Configure the symmetry-breaking easy-axis term:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"D_groundtruth = 10.\nSz = spin_operators(spin_one_chain, 1)[3]\nset_onsite_coupling!(spin_one_chain, -D_groundtruth*Sz^2, 1)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"With the ground-truth hamiltonian in place, we use Sunny's classical dynamics to generate ficticious experiment data at temperature kT = 0.1.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Œît = 0.05/D_groundtruth\nŒª = 0.1\nkT = 0.1\nlangevin = Langevin(Œît; kT, Œª);\n\nfunction viz_chain(sys;kwargs...)#hide\n  ##ups = map(x -> abs2(x[1]), sys.coherents)[:];#hide\n  ##zs = map(x -> abs2(x[2]), sys.coherents)[:];#hide\n  ##downs = map(x -> abs2(x[3]), sys.coherents)[:];#hide\n###hide\n  ##f = Figure()#hide\n  ##ax = LScene(f[1,1];show_axis = false)#hide\n  ##_ = Makie.cam3d!(ax.scene, projectiontype=Makie.Orthographic)#hide\n###hide\n  ##linewidth = 5.#hide\n  ##arrowsize = 10.#hide\n  ##lengthscale = 15.#hide\n  ##pts = [Point3f(Sunny.global_position(sys,site)) for site in eachsite(sys)][:]#hide\n###hide\n  #### Ups#hide\n  ##vecs = [Vec3f([0,0,1]) for site in eachsite(sys)][:]#hide\n  ##cols = map(x -> (:blue,x), ups)#hide\n  ##Makie.arrows!(ax, pts .+ 0.5 .* vecs, vecs;#hide\n        ##linecolor = cols, arrowcolor = cols,#hide\n        ##lengthscale, arrowsize, linewidth, kwargs...)#hide\n###hide\n  #### Downs#hide\n  ##vecs = [Vec3f([0,0,-1]) for site in eachsite(sys)][:]#hide\n  ##cols = map(x -> (:red,x), downs)#hide\n  ##Makie.arrows!(ax, pts .+ 0.5 .* vecs, vecs;#hide\n        ##linecolor = cols, arrowcolor = cols,#hide\n        ##lengthscale, arrowsize, linewidth, kwargs...)#hide\n###hide\n  ##cols = map(x -> (:green,x), zs)#hide\n  ##meshscatter!(ax,pts, markersize = 7., color = cols)#hide\n  ##f#hide\n  Sunny.Plotting.plot_coherents(sys;quantization_axis = [0,0,1],kwargs...)\nend#hide\nrandomize_spins!(spin_one_chain)\nviz_chain(spin_one_chain)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"In this plot, the z-axis has been used as the quantization axis for each site, with the up/down arrows and circle representing the pm hbar and 0hbar spin projections onto the z-axis respectively. The opacity of each object represents the probability (absolute value squared), and the color represents the phase. Since we are using classical dynamics to simulate the data, the phase will be mostly random.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"First, we thermalize the chain, and then take several samples in order get reasonably good \"experiment\" data.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"nStep = 50_000#hide\nfor _ in 1:nStep#hide\n    step!(spin_one_chain, langevin)#hide\nend#hide\n# ... thermalize ...\nviz_chain(spin_one_chain)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"sc = dynamical_correlations(spin_one_chain; Œît, nœâ = 80, œâmax = 20.);#hide\n\nfor _ in 1:10_000#hide\n    step!(spin_one_chain, langevin)#hide\nend#hide\nadd_sample!(sc, spin_one_chain)#hide\n# ... some time later ...\nviz_chain(spin_one_chain)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"for _ in 1:10_000#hide\n    step!(spin_one_chain, langevin)#hide\nend#hide\nadd_sample!(sc, spin_one_chain)#hide\n# ... some time later ...\nviz_chain(spin_one_chain)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"for _ in 1:20#hide\n    for _ in 1:10_000#hide\n        step!(spin_one_chain, langevin)#hide\n    end#hide\n    add_sample!(sc, spin_one_chain)#hide\nend#hide\n# ... some time later ...\nviz_chain(spin_one_chain)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Now that we have collected several samples,","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"sc","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"we are ready to generate the intensity data. Since this is supposed to represent an experiment, the intensity data will go in a histogram:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS = unit_resolution_binning_parameters(sc)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Here's what the experiment data looks like:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"formula = intensity_formula(sc,:perp;kT)\nis, counts = intensities_binned(sc,SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS,formula)\n\nSIMULATED_EXPERIMENT_DATA = (is ./ counts)[:,1,1,:]\n\nbcs = axes_bincenters(SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS)\nf = Figure()#hide\nax = Axis(f[1,1])#hide\nheatmap!(ax,bcs[1],bcs[4],log10.(SIMULATED_EXPERIMENT_DATA))\nf#hide","category":"page"},{"location":"examples/one_dim_chain/#Fitting-to-the-experiment-data","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting to the experiment data","text":"","category":"section"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"To fit this data, we first model the known aspects of the system in Sunny. The first steps are the same whether we are simulating a known system or modelling an unknown system:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"# Same as before\nchain_spacing = 10. # Angstrom\nlatvecs = chain_spacing * I(3)\none_dimensional_chain = Crystal(latvecs,[[0,0,0]],\"P1\")\nchain_length = 16 # Number of atoms\nlatsize = (chain_length,1,1) # 1D chain is Nx1x1 lattice\nspin_one_chain = System(one_dimensional_chain, latsize, [SpinInfo(1,S=1,g=2)], :SUN)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Originally, the next step would have been to configure the hamiltonian by specifying the J and D values. However, since these are unknowns, we will avoid using them as long as possible, and instead proceed to set up the bonds, spin operators, and Langevin integrator‚Äìnone of which require the values:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Œît = 0.05\nŒª = 0.1\nkT = 0. # LSWT uses zero temperature\nlangevin = Langevin(Œît; kT, Œª);\n\nnearest_neighbor_right = Bond(1,1,(1,0,0))\nnearest_neighbor_left = Bond(1,1,(-1,0,0))\n\nSz = spin_operators(spin_one_chain, 1)[3]","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"After this setup work is done once, we create a function forward_problem(J_trial,D_trial) which will compute the Linear Spin Wave Theoretic spectrum at the trial values of the J and D fitting parameters. In other words, the part of the original calculation which depends on the fitting parameters gets wrapped into a function:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"function forward_problem(J_trial, D_trial)\n\n  # Ensure there is no phase transition (or else LSWT will throw errors)\n  J_trial = min(J_trial,0)\n  D_trial = max(D_trial,0)\n\n  # Uses J_trial\n  set_exchange!(spin_one_chain,J_trial,nearest_neighbor_right)\n  set_exchange!(spin_one_chain,J_trial,nearest_neighbor_left)\n\n  # Uses D_trial\n  set_onsite_coupling!(spin_one_chain, -D_trial*Sz^2, 1)\n\n  # Perform spin wave calculation, continued below...","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Note that forward_problem refers to variables defined outside of the scope of the function. This allows us to reuse those variables in each call to forward_problem, without reconstructing them each time. In general, the more that is known about the system you are modelling, the later in the code function forward_problem(...) can be inserted, and the more setup work can be re-used.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"tip: `forward_problem` is a closure\nIn computer progrogramming parlance, forward_problem is said to 'capture' variables such as spin_one_chain from the enviroment. Since the result of calling forward_problem depends not only on J_trial and D_trial, but also on spin_one_chain, it's no longer a function of only its arguments.Since forward_problem is not a closed system, but forward_problem + (captured variables) is a closed system, the latter is called the 'closure' of the former.","category":"page"},{"location":"examples/one_dim_chain/#Spin-wave-calculation","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Spin wave calculation","text":"","category":"section"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"We can leverage our knowledge that the ground state should be ferromagnetic to simplify the spin wave calculation. Since the ferrommagnetic unit cell is just one site, the simplified system is extremely simple:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"  # ... perform spin wave calculation, continued from above.\n  one_site_system = reshape_supercell(spin_one_chain,[1 0 0; 0 1 0; 0 0 1])","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"After restricting to a single site, it's best to re-thermalize the system at zero temperature to ensure a good classical ground state for LSWT:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"  langevin.kT = 0.\n  nStep = 1_000\n  for _ in 1:nStep\n      step!(one_site_system, langevin)\n  end","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"The spin wave intensity data must be placed in a histogram with the same parameters as the experiment data, in order to ensure a good comparision.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"The kernel and intensities_bin_centers used here are temporary, until a better binning method is written.","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"  swt = SpinWaveTheory(one_site_system)\n  formula = intensity_formula(swt,:perp; kernel = lorentzian(0.5))\n  params = SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS\n  is_swt = Sunny.intensities_bin_centers(swt, params, formula)\n\n  return is_swt[:,1,1,:]\nend # end of forward_problem","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"We can see the different possible results from LSWT by plotting the dispersion:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"function plot_forward(J,D)\n  is_swt = forward_problem(J,D)\n  bcs = axes_bincenters(SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS)\n  heatmap(bcs[1],bcs[4],log10.(is_swt))\nend\n\nplot_forward(-1,10)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"plot_forward(-6,2)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"plot_forward(-0.01,15)","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Now, we can easily define a least-squares loss function comparing the \"experiment\" data to the LSWT result:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"function get_loss(parameters)\n  J,D = parameters\n  is_swt = forward_problem(J,D)\n  sqrt(sum(abs2.(SIMULATED_EXPERIMENT_DATA .- is_swt)))\nend","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"Sweeping the parameters over a range containing the true value reveals that the loss is minimized near the true parameters (dot). The minimum loss is not exactly at the ground truth parameters in this case. Gradient descent (finite-differenced) can be used to find the actual minimizer:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"nJ = 30\nnD = 35\nloss_landscape = zeros(Float64,nJ,nD)\nJs = range(-2,0,length=nJ)\nDs = range(8,12,length=nD)\nfor (ij,J) in enumerate(Js)\n  for (id,D) in enumerate(Ds)\n    loss_landscape[ij,id] = get_loss([J,D])\n  end\nend\n\nfig = Figure()\nax = Axis(fig[1,1],xlabel = \"J [meV]\", ylabel = \"D [meV]\")\ncontourf!(ax,Js,Ds,loss_landscape)\n\nx0 = [-2,9.5]\nopt_result = optimize(get_loss,x0,method=GradientDescent(alphaguess=1e-3),store_trace=true,extended_trace = true,time_limit=10.)\nlines!(ax,Point2f.(Optim.x_trace(opt_result)))\nscatter!(ax,-1,10)\nfig","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"The fit can be verified by plotting the LSWT band structure over top of the experiment data:","category":"page"},{"location":"examples/one_dim_chain/","page":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","title":"Fitting model parameters in a 1D spin-1 ferromagnetic chain","text":"bcs = axes_bincenters(SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS)\nf = Figure()#hide\nax = Axis(f[1,1]; xlabel=\"Q [R.L.U.]\", ylabel=\"Energy (meV)\")#hide\nheatmap!(ax,bcs[1],bcs[4],log10.(SIMULATED_EXPERIMENT_DATA), colormap = :deepsea)\nf#hide\n\n\nJ_trial, D_trial = opt_result.minimizer\nset_exchange!(spin_one_chain,J_trial,nearest_neighbor_right)#hide\nset_exchange!(spin_one_chain,J_trial,nearest_neighbor_left)#hide\n\nset_onsite_coupling!(spin_one_chain, -D_trial*Sz^2, 1)#hide\none_site_system = reshape_supercell(spin_one_chain,[1 0 0; 0 1 0; 0 0 1])#hide\n\nlangevin.kT = 0.#hide\nnStep = 1_000#hide\nfor _ in 1:nStep#hide\n    step!(one_site_system, langevin)#hide\nend#hide\n\nswt = SpinWaveTheory(one_site_system)#hide\nparams = SIMULATED_EXPERIMENT_HISTOGRAM_PARAMS\n\npath = [[q,0,0] for q in bcs[1]]\ndisp, intensity = intensities_bands(swt, path, intensity_formula(swt,:perp, kernel = delta_function_kernel))\n\nfor i in axes(disp)[2]\n    lines!(ax, bcs[1], disp[:,i]; color=intensity[:,i], colormap = :turbo,linewidth = 5,colorrange = (0.,1.))\nend\nColorbar(f[1,2],colormap = :turbo, limits = (0.,1.))\nColorbar(f[1,3],colormap = :deepsea, limits = (0.,1.))\nf","category":"page"},{"location":"#Sunny-Overview","page":"Overview","title":"Sunny Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Sunny is a Julia package for modeling atomic-scale magnetism. It provides powerful tools to study equilibrium and non-equilibrium magnetic phenomena. In particular, it allows estimation of dynamical structure factor intensities, mathcalS(ùê™œâ), to support quantitative modeling of experimental scattering data.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Features include:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Generalized spin dynamics using SU(N) coherent states.\nAbility specify a crystal by a .cif file, or using its spacegroup symmetry.\nInteractive visualizations of the 3D crystals and magnetic ordering.\nSymmetry analysis to classify allowed interaction terms, and to propagate them by symmetry.\nSingle-ion anisotropy at arbitrary order, which can be specified using Stevens operators or as a polynomial of spin operators.\nMonte Carlo sampling of spin configurations in thermal equilibrium, and optimization tools.\nMeasurements of dynamical correlation functions. For small supercells at low temperature, one can use linear spin wave theory and its multi-boson generalization. Alternatively, one can use the full classical dynamics to study systems with large supercells (e.g., disordered systems), or anharmonic effects with thermal fluctuations.\nLong-range dipole-dipole interactions accelerated with the fast Fourier transform (FFT).\nVarious correction factors to facilitate comparison with experimental data (form factor, dipole factor, temperature-dependent classical-to-quantum factors, intensity binning, etc.).","category":"page"}]
}
