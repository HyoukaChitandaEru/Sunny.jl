<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library API · Sunny documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sunny documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Library API</a><ul class="internal"><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><ul><li><a href="#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a></li><li><a href="#Sunny.𝒪"><code>Sunny.𝒪</code></a></li><li><a href="#Sunny.𝒮"><code>Sunny.𝒮</code></a></li><li><a href="#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a></li><li><a href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="#Sunny.IsingSampler"><code>Sunny.IsingSampler</code></a></li><li><a href="#Sunny.LangevinHeunP"><code>Sunny.LangevinHeunP</code></a></li><li><a href="#Sunny.LangevinSampler"><code>Sunny.LangevinSampler</code></a></li><li><a href="#Sunny.MetropolisSampler"><code>Sunny.MetropolisSampler</code></a></li><li><a href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a></li><li><a href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.StructureFactor</code></a></li><li><a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a></li><li><a href="#Sunny.Site-Tuple{CartesianIndex{4}}"><code>Sunny.Site</code></a></li><li><a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>Sunny.add_sample!</code></a></li><li><a href="#Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.anneal!</code></a></li><li><a href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a></li><li><a href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a></li><li><a href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a></li><li><a href="#Sunny.enable_dipole_dipole!-Tuple{System}"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a></li><li><a href="#Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.extend_periodically</code></a></li><li><a href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a></li><li><a href="#Sunny.get_temp-Tuple{MetropolisSampler}"><code>Sunny.get_temp</code></a></li><li><a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.intensities</code></a></li><li><a href="#Sunny.intensity_grid-Tuple{StructureFactor, Any}"><code>Sunny.intensity_grid</code></a></li><li><a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a></li><li><a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a></li><li><a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a></li><li><a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a></li><li><a href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a></li><li><a href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a></li><li><a href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a></li><li><a href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a></li><li><a href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a></li><li><a href="#Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N"><code>Sunny.sample!</code></a></li><li><a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a></li><li><a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a></li><li><a href="#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N"><code>Sunny.set_exchange_with_biquadratic!</code></a></li><li><a href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a></li><li><a href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a></li><li><a href="#Sunny.set_temp!-Tuple{MetropolisSampler, Any}"><code>Sunny.set_temp!</code></a></li><li><a href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a></li><li><a href="#Sunny.static_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.static_intensities</code></a></li><li><a href="#Sunny.step!-Tuple{System{0}, LangevinHeunP}"><code>Sunny.step!</code></a></li><li><a href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a></li><li><a href="#Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.thermalize!</code></a></li><li><a href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a></li><li><a href="#Sunny.ωvals-Tuple{StructureFactor}"><code>Sunny.ωvals</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Units.meV
Units.theory</code></pre><p>The unit system is implicitly determined by the definition of two physical constants: the vacuum permeability <span>$μ₀$</span> and the Bohr magneton <span>$μ_B$</span>. Temperatures are effectively measured in units of energy (<span>$k_B = 1$</span>) and time is effectively measured in units of inverse energy (<span>$ħ = 1$</span>). The default unit system, <code>Units.meV</code>, employs (meV, Å, tesla). Select alternatively <code>Units.theory</code> for a units system defined so that <span>$μ₀ = μ_B = 1$</span>.</p><p>See also <a href="#Sunny.meV_per_K"><code>meV_per_K</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Units.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.meV_per_K" href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meV_per_K = 0.086173332621451774</code></pre><p>A physical constant. Useful for converting kelvin into the default energy units, meV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Units.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.𝒪" href="#Sunny.𝒪"><code>Sunny.𝒪</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">𝒪[k,q]</code></pre><p>Abstract symbols for the Stevens operators. Linear combinations of these can be used to define a single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/LocalOperators.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.𝒮" href="#Sunny.𝒮"><code>Sunny.𝒮</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">𝒮[1], 𝒮[2], 𝒮[3]</code></pre><p>Abstract symbols for the spin operators. Polynomials of these can be used to define a single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/LocalOperators.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; symprec=1e-5)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>.  The optional parameter <code>symprec</code> controls the precision tolerance for spacegroup symmetries.</p><pre><code class="nohighlight hljs">Crystal(lat_vecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>lat_vecs</code>. Spacegroup symmetry information is automatically inferred. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(lat_vecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)</code></pre><p>Builds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional <code>setting</code> string will disambiguate between unit cell conventions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build an FCC crystal using the primitive unit cell. The spacegroup number
# 225 is inferred.
lat_vecs = [1 1 0;
            1 0 1;
            0 1 1] / 2
positions = [[0, 0, 0]]
Crystal(lat_vecs, positions)

# Build a CsCl crystal (two cubic sublattices). By providing distinct type
# strings, the spacegroup number 221 is inferred.
lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0,0,0], [0.5,0.5,0.5]]
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(lat_vecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227. This
# spacegroup has two possible settings (&quot;1&quot; or &quot;2&quot;), which determine an
# overall unit cell translation.
lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[1, 1, 1] / 4]
cryst = Crystal(lat_vecs, positions, 227; setting=&quot;1&quot;)</code></pre><p>See also <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Crystal.jl#L8-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}" href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FormFactor(atom::Int64, elem::String; g_lande=nothing)</code></pre><p>Basic type for specifying form factor parameters. Must be provided a site within the unit cell (<code>atom</code>) and a string specifying the element name. This used when calling <a href="@ref"><code>get_intensities</code></a>, which requires a list of <code>FormFactors</code>s.</p><p>A list of supported element names is available at:</p><p>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</p><p>The Landé g-factor may also be specified. </p><p>In more detail, the data stored in a <code>FormFactor</code> will be used to compute the form factor for each momentum space magnitude <code>|k|</code>, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor <span>$f$</span> is returned. If the keyword <code>g_lande</code> is given a numerical value, then a second order form factor <span>$F$</span> is returned.</p><p>It is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable <span>$s = |k|/4π$</span>, where <span>$|k|$</span> can be interpreted as the magnitude of momentum transfer.</p><p>The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation</p><p><span>$\langle j_l(s) \rangle = A e^{-as^2} + B e^{-bs^2} + Ce^{-cs^2} + D,$</span></p><p>where coefficients <span>$A, B, C, D, a, b, c$</span> are obtained from semi-empirical fits, depending on the orbital angular momentum index <span>$l = 0, 2$</span>. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.</p><p>A first approximation to the magnetic form factor is</p><p><span>$f(s) = \langle j_0(s) \rangle$</span></p><p>A second order correction is given by</p><p><span>$F(s) = \frac{2-g}{g} \langle j_2(s) \rangle s^2 + f(s)$</span>, where <span>$g$</span> is the Landé g-factor.  </p><p>Digital tables are available at:</p><ul><li>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</li></ul><p>Additional references are:</p><ul><li>Marshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)</li><li>Clementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)</li><li>Freeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)</li><li>Descleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/FormFactor.jl#L12-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(Δt::Float64; atol=1e-12) where N</code></pre><p>Energy-conserving integrator for simulating dynamics without damping or noise. Use with the <code>step!</code> function to evolve a <code>System</code> forward by a time step of <code>Δt</code>:</p><p>step!(sys::System, integrator::ImplicitMidpoint)</p><p>The above function will use the spherical midpoint integration scheme for dipole systems and the Schrodinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic (energy-conserving) and are appropriate for simulating dissipationless dynamics over long periods of time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Integrators.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.IsingSampler" href="#Sunny.IsingSampler"><code>Sunny.IsingSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsingSampler(sys::System, kT::Float64, nsweeps::Int)</code></pre><p>A sampler which performs the standard Metropolis Monte Carlo algorithm to sample a <code>System</code> at the requested temperature.</p><p>This version differs from <code>MetropolisSampler</code> in that each single-spin update only attempts to completely flip the spin. One call to <code>sample!</code> will attempt to flip each spin <code>nsweeps</code> times.</p><p>Before constructing, be sure that your <code>System</code> is initialized so that each spin points along its &quot;Ising-like&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.LangevinHeunP" href="#Sunny.LangevinHeunP"><code>Sunny.LangevinHeunP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LangevinHeunP(kT::Float64, λ::Float64, Δt::Float64)</code></pre><p>Projected Heun integration scheme with noise and damping. Use with the <code>step!</code> function to evolve a <code>System</code> forward by a time step of <code>Δt</code>:</p><p>step!(sys::System, integrator::LangevinHeunP)</p><p>If <code>kT &gt; 0</code>, this will simulate dynamics in the presence of a thermal bath. <code>λ</code> is an empirical parameter that determines the strength of coupling to the thermal bath and sets a time scale for decorrelation, <code>1/λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Integrators.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.LangevinSampler" href="#Sunny.LangevinSampler"><code>Sunny.LangevinSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LangevinSampler(integrator::LangevinHeunP, nsteps::Int)</code></pre><p>Creates a sampler from a Langevin integrator. <code>nsteps</code> determines how many times <code>step!</code> is called using the integrator. <code>nsteps</code> should be selected large enough to ensure that the state of the System after integration is decorrelated with respect to its initial state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.MetropolisSampler" href="#Sunny.MetropolisSampler"><code>Sunny.MetropolisSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MetropolisSampler(sys::System, kT::Float64, nsweeps::Int)</code></pre><p>A sampler which performs the standard Metropolis Monte Carlo algorithm to sample  a <code>System</code> at the requested temperature.</p><p>Each single-spin update attempts to completely randomize the spin. One call to  <code>sample!</code> will attempt to flip each spin <code>nsweeps</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.SpinInfo" href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinInfo(atom::Int, S; g=2)</code></pre><p>Characterizes the spin at a given <code>atom</code> index within the crystal unit cell. <code>S</code> is an integer multiple of 1/2 and gives the spin angular momentum in units of ħ. <code>g</code> is the g-factor or tensor, such that an angular momentum dipole <span>$s$</span> produces a magnetic moment <span>$g s$</span> in units of the Bohr magneton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/SpinInfo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.StructureFactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructureFactor(sys::System; nω, Δt = 0.1, ωmax = nothing,
                    apply_g = true, ops = nothing, matrix_elems = nothing,
                    process_trajectory=:none)</code></pre><p><code>StructureFactor</code> is the basic type for calculating <span>$𝒮^{αβ}(q,ω)$</span>, storing the results, and retrieving intensity information. </p><p>Most users should use <a href="@ref"><code>calculate_structure_factor</code></a> to generate a structure factor. However, one may also directly create a structure factor by providing a <code>System</code> to <code>StructureFactor</code>. Then, to manually generate a sample, the user must ensure that the spins of their system are drawn from an appropriate equilibrium distribution and call <a href="@ref"><code>add_trajectory!</code></a> function. This process may be repeated as necessary to generate a sufficient statistics. </p><p>The keywords specify all the parameters used in subsequent calculations and must be determined at the time that the <code>StructureFactor</code> is initiated. Specifically:</p><ul><li><code>nω</code>: Required keyword argument that determines how many energy bins to   resolve between 0 and <code>ωmax</code>. If set to 1, Sunny will calculate a static   structure factor.</li><li><code>Δt</code>: Sets the step size of the integrator used to calculate trajectories.</li><li><code>ωmax</code>: Determines the maximum resolved energy.</li><li><code>apply_g</code>: Determines whether to apply the g-factor when calculating   trajectories.</li><li><code>ops</code>: Enables an advanced feature for SU(<em>N</em>) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, <code>ops</code> must be given an <code>N×N×numops</code> array, where the   final index is used to retrieve each <code>N×N</code> operator.</li><li><code>matrix_elems</code>: Allows the user to specify which correlation functions are   calculated. This is specified with a vector of tuples. By default Sunny   records all auto- and cross-correlations generated by the x, y, and z   dipolar components. To retain only the xx and xy correlations, one would set   <code>matrix_elems=[(1,1), (1,2)]</code>.</li></ul><p>If you wish to calculate a dynamical structure factor, the keyword <code>nω</code> must set to an integer greater than 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/StructureFactors.jl#L21-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}" href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)</code></pre><p>Construct a <code>System</code> of spins for a given <code>crystal</code> symmetry. The <code>latsize</code> parameter determines the number of unit cells in each lattice vector direction. The <code>infos</code> parameter is a list of <a href="#Sunny.SpinInfo"><code>SpinInfo</code></a> objects, which determine the magnitude <span>$S$</span> and <span>$g$</span>-tensor of each spin.</p><p>The three possible options for <code>mode</code> are <code>:dipole</code>, <code>:SUN</code>, and <code>:projected</code>. The choice <code>:dipole</code> restricts each a spin to an angular momentum dipole. In contrast, the choice <code>:SUN</code> describes each spin as a full SU(<em>N</em>) coherent state, where <span>$N = 2S + 1$</span>. The SU(<em>N</em>) approach captures more dynamical degrees of freedom, e.g.,  quadrupolar moments <span>$⟨ŜᵅŜᵝ+ŜᵝŜᵅ⟩$</span>. Finally, the choice <code>:projected</code> projects the SU(<em>N</em>) dynamics onto the space of dipoles. In practice, the distinction between <code>:projected</code> and <code>:dipoles</code> is that the former will automatically apply appropriate renormalizations to the single-ion anisotropy and biquadratic exchange interactions for maximum accuracy.</p><p>The default units system of (meV, Å, tesla) can be overridden by with the <code>units</code> parameter; see <a href="#Sunny.Units"><code>Units</code></a>. </p><p>All spins are initially polarized in the <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/System.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Site-Tuple{CartesianIndex{4}}" href="#Sunny.Site-Tuple{CartesianIndex{4}}"><code>Sunny.Site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Site(n1, n2, n3, i)</code></pre><p>References a single site in a <code>System</code> via its unit cell <code>(n1,n2,n3)</code> and its sublattice <code>i</code>. Can be used to index <code>dipoles</code> and <code>coherents</code> fields of a <code>System</code>, or to set inhomogeneous interactions.</p><p>See also <a href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>set_vacancy_at!</code></a>, <a href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>set_external_field_at!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/System.jl#L103-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.add_sample!-Tuple{StructureFactor, System}" href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>Sunny.add_sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_sample!(sf::StructureFactor, sys::System)</code></pre><p>When given a <code>StructureFactor</code> and a <code>System</code>, <code>add_trajectory</code> will use the spin state contained in the <code>System</code> as the initial condition for a dynamical trajectory. The correlations generated by the trajectory are calculated and accumulated into the <code>StructureFactor</code>. All trajectory parameters are specified in the <a href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>StructureFactor</code></a>.</p><p>Note that for dynamic structure factors, this function will change the state of <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/SampleGeneration.jl#L132-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S&lt;:Sunny.AbstractSampler" href="#Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.anneal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anneal!(sampler, temp_schedule, step_schedule)</code></pre><p><code>sample!</code> a sampler at a series of temperatures, staying at each temperature   for the number of steps in <code>step_schedule</code>.</p><pre><code class="nohighlight hljs">anneal!(sampler, temp_function::Function, num_samples)</code></pre><p><code>sample!</code> a sampler <code>num_samples</code> times, with the sample at timestep <code>n</code>  drawn at a temperature <code>temp_function(n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L35-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.browser-Tuple{String}" href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">browser(html_str; dir)</code></pre><p>Launch a system browser to display the provided HTML string or SunnyViewer. If a directory <code>dir</code> is provided, an HTML file will be written at that location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/SunnyGfx/SunnyGfx.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.connected_path-Tuple{Vector, Any}" href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connected_path(qs::Vector, density)</code></pre><p>Takes a list of wave vectors, <code>qs</code>, and builds an expanded list of wave vectors that traces a path through the provided points. Also returned is a list of marker indices corresponding to the intput points. The <code>density</code> parameter controls the frequency of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/DataRetrieval.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.dmvec-Tuple{Any}" href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Antisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,</p><pre><code class="nohighlight hljs">  [  0    D[3] -D[2]
   -D[3]   0    D[1]
    D[2] -D[1]   0  ]</code></pre><p>Useful in the context of <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/PairExchanges.jl#L132-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.enable_dipole_dipole!-Tuple{System}" href="#Sunny.enable_dipole_dipole!-Tuple{System}"><code>Sunny.enable_dipole_dipole!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System)</code></pre><p>Enables long-range dipole-dipole interactions,</p><p class="math-container">\[    -(μ₀/4π) ∑_{⟨ij⟩}  (3 (𝐌_j⋅𝐫̂_{ij})(𝐌_i⋅𝐫̂_{ij}) - 𝐌_i⋅𝐌_j) / |𝐫_{ij}|^3\]</p><p>where the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are <span>$𝐌_i = μ_B g 𝐒_i$</span> where <span>$g$</span> is the g-factor or g-tensor, and <span>$𝐒_i$</span> is the spin angular momentum dipole in units of ħ. The Bohr magneton <span>$μ_B$</span> and vacuum permeability <span>$μ_0$</span> are physical constants, with numerical values determined by the unit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/Interactions.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>Computes the total system energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/Interactions.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.extend_periodically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_periodically(sys::System{N}, mults::NTuple{3, Int64}) where N</code></pre><p>Creates a new System identical to <code>sys</code> but with each dimension multiplied by the corresponding factor given in the tuple <code>mults</code>. The original spin configuration is simply repeated periodically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/System.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forces(Array{Vec3}, sys::System)</code></pre><p>Returns the effective local field (force) at each site, <span>$𝐁 = -∂E/∂𝐬$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/Interactions.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.get_temp-Tuple{MetropolisSampler}" href="#Sunny.get_temp-Tuple{MetropolisSampler}"><code>Sunny.get_temp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_temp(sampler) :: Float64</code></pre><p>Returns the temperature of the sampler, as <code>kT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.intensities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities(sf::StructureFactor, qs, mode; interpolation = nothing,
                kT = nothing, formfactors = nothing, negative_energies = false)</code></pre><p>The basic function for retrieving <span>$𝒮(𝐪,ω)$</span> information from a <code>StructureFactor</code>. Maps an array of wave vectors <code>qs</code> to an array of structure factor intensities, including an additional energy index. The values of <span>$ω$</span> associated with the energy index can be retrieved by calling <a href="#Sunny.ωvals-Tuple{StructureFactor}"><code>ωvals</code></a>. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.</p><ul><li><code>mode</code>: Should be one of <code>:trace</code>, <code>:perp</code>, or <code>:full</code>. Determines an optional   contraction on the indices <span>$α$</span> and <span>$β$</span> of <span>$𝒮^{αβ}(q,ω)$</span>. Setting   <code>trace</code> yields <span>$∑_α 𝒮^{αα}(q,ω)$</span>. Setting <code>perp</code> will employ a   polarization correction on the traced value. Setting <code>full</code> will return all   elements <span>$𝒮^{αβ}(q,ω)$</span> with contraction.</li><li><code>interpolation</code>: Since <span>$𝒮(q,ω)$</span> is calculated on a finite lattice, data is   only available at discrete wave vectors. By default, Sunny will round a   requested <code>q</code> to the nearest available wave vector. Linear interpolation can   be applied by setting <code>interpolation=:linear</code>.</li><li><code>kT</code>: If a temperature is provided, the intensities will be rescaled by a   temperature- and ω-dependent classical-to-quantum factor. <code>kT</code> should be   specified when making comparisons with spin wave calculations or   experimental data.</li><li><code>formfactors</code>: To apply form factor corrections, provide this keyword with a   vector of <code>FormFactor</code>s, one for each unique site in the unit cell. Sunny   will symmetry propagate the results to all equivalent sites.</li><li><code>negative_energies</code>: If set to <code>true</code>, Sunny will return the periodic   extension of the energy axis. Most users will not want this.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/DataRetrieval.jl#L66-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.intensity_grid-Tuple{StructureFactor, Any}" href="#Sunny.intensity_grid-Tuple{StructureFactor, Any}"><code>Sunny.intensity_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_grid(sf::StructureFactor, mode;
                   bzsize=(1,1,1), negative_energies = false, index_labels = false, kwargs...)</code></pre><p>Returns intensities at discrete wave vectors for which there is exact information. Shares all keywords with <a href="@ref"><code>get_intensities</code></a>, and provides two additional options:</p><ul><li><code>bzsize</code>: Specifies the number of Brillouin zones to return, given as a 3-tuple of integers.</li><li><code>index_labels</code>: If set to <code>true</code>, will return axis label information for the   data, which may be upacked as: <code>(; vals, qpoints, ωs)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/DataRetrieval.jl#L186-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}" href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_params(lat_vecs::Mat3)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, α, β, γ)$</span> for the three lattice vectors provided as columns of <code>lat_vecs</code>. The inverse mapping is <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_vectors-NTuple{6, Any}" href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, α, β, γ)</code></pre><p>Return the lattice vectors, as columns of the <span>$3×3$</span> output matrix, that correspond to the conventional unit cell defined by the lattice constants <span>$(a, b, c)$</span> and the angles <span>$(α, β, γ)$</span> in degrees. The inverse mapping is <a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>lattice_params</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/LatticeUtils.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_classical_spins-Tuple{Any}" href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_classical_spins(p)</code></pre><p>Prints a quantum operator (e.g. linear combination of Stevens operators) as a polynomial of spin expectation values in the classical limit.</p><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/LocalOperators.jl#L323-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_stevens-Tuple{Any}" href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_stevens(p; N)</code></pre><p>Prints a quantum operator (e.g. a polynomial of the spin operators <code>𝒮</code>) as a linear combination of Stevens operators. The parameter <code>N</code> specifies the dimension of the SU(<em>N</em>) representation, corresponding to quantum spin magnitude <span>$S = (N-1)/2$</span>. The special value <code>N = 0</code> indicates the large-<span>$S$</span> classical limit.</p><p>In the output, the symbol <code>X</code> denotes the spin operator magnitude squared. Quantum spin operators <span>$𝒮$</span> of any finite dimension satisfy <span>$X = |𝒮|^2 = S (S+1)$</span>. To take the large-<span>$S$</span> limit, however, we keep only leading order powers of <span>$S$</span>, such that <span>$X = S^2$</span>.</p><p>This function can be useful for understanding the conversions performed internally by <a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>set_anisotropy!</code></a>.</p><p>For the inverse mapping, see <a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>print_anisotropy_as_classical_spins</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/LocalOperators.jl#L337-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_bond-Tuple{Crystal, Bond}" href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Printing.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_site-Tuple{Any, Any}" href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_site(cryst, i; R=I)</code></pre><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Printing.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_suggested_frame-Tuple{Crystal, Int64}" href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_suggested_frame(cryst, i; digits=4)</code></pre><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. This is useful to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Printing.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_symmetry_table-Tuple{Crystal, Any}" href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Printing.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reference_bonds-Tuple{Crystal, Float64}" href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/SymmetryAnalysis.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N" href="#Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N"><code>Sunny.sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample!(sampler)</code></pre><p>Samples <code>sampler.sys</code> to a new state, under the Boltzmann distribution  as defined by <code>sampler.sys.interactions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N" href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_anisotropy!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The parameter <code>op</code> may be a polynomial in symbolic spin operators <code>𝒮[α]</code>, or a linear combination of symbolic Stevens operators <code>𝒪[k,q]</code>.</p><p>The characters <code>𝒮</code> and <code>𝒪</code> can be copy-pasted from this help message, or typed at a Julia terminal using <code>\scrS</code> or <code>\scrO</code> followed by tab-autocomplete.</p><p>For systems with <code>:projected</code>, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An easy axis anisotropy in the z-direction
set_anisotropy!(sys, -D*𝒮[3]^3, i)

# The unique quartic single-ion anisotropy for a site with cubic point group
# symmetry
set_anisotropy!(sys, 𝒪[4,0] + 5𝒪[4,4], i)

# An equivalent expression of this quartic anisotropy, up to a constant shift
set_anisotropy!(sys, 20*(𝒮[1]^4 + 𝒮[2]^4 + 𝒮[3]^4), i)</code></pre><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/SingleIonAnisotropies.jl#L15-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond)</code></pre><p>Sets a 3×3 spin-exchange matrix <code>J</code> along <code>bond</code>, yielding a pairwise interaction energy <span>$𝐒_i⋅J 𝐒_j$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>Scalar <code>J</code> implies a pure Heisenberg exchange.</p><p>As a convenience, <code>dmvec(D)</code> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$𝐃⋅(𝐒_i×𝐒_j)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Sunny, LinearAlgebra

# An explicit exchange matrix
J1 = [2 3 0;
     -3 2 0;
      0 0 2]
set_exchange!(sys, J1, bond)

# An equivalent Heisenberg + DM exchange 
J2 = 2*I + dmvec([0,0,3])
set_exchange!(sys, J2, bond)</code></pre><p>See also <a href="#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N"><code>set_exchange_with_biquadratic!</code></a>, <a href="#Sunny.dmvec-Tuple{Any}"><code>dmvec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/PairExchanges.jl#L94-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N" href="#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N"><code>Sunny.set_exchange_with_biquadratic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange_with_biquadratic!(sys::System, J1, J2, bond::Bond)</code></pre><p>Sets both quadratic and biquadratic exchange interactions along <code>bond</code>, yielding a pairwise energy <span>$𝐒_i⋅J_1 𝐒_j + J_2 (𝐒_i⋅𝐒_j)²$</span>. These interactions will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten.</p><p>For systems with <code>mode=:projected</code> the biquadratic interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode. This renormalization introduces a correction to the quadratic part of the exchange, which is why the two parts must be specified concurrently.</p><p>See also <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/PairExchanges.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field!-Tuple{System, Any}" href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field!(sys::System, B::Vec3)</code></pre><p>Sets the external field <code>B</code> that couples to all spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/Interactions.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field_at!-Tuple{System, Any, Any}" href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field_at!(sys::System, B::Vec3, idx::Site)</code></pre><p>Sets a Zeeman coupling between a field <code>B</code> and a single spin. <a href="#Sunny.Site-Tuple{CartesianIndex{4}}"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/Interactions.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_temp!-Tuple{MetropolisSampler, Any}" href="#Sunny.set_temp!-Tuple{MetropolisSampler, Any}"><code>Sunny.set_temp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_temp!(sampler, kT)</code></pre><p>Changes the temperature of the sampler to <code>kT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vacancy_at!(sys::System, idx::Site)</code></pre><p>Make a single site nonmagnetic. <a href="#Sunny.Site-Tuple{CartesianIndex{4}}"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/System/System.jl#L205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.static_intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.static_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.static_intensities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_static_intensities(sf::StructureFactor, qs, mode; kwargs...)</code></pre><p>Return the static structure factor intensities at wave vectors <code>qs</code>. The functionality is very similar to <a href="@ref"><code>get_intensities</code></a>, except the returned array has dimensions identical to <code>qs</code>. The energy axis has been summed out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/DataRetrieval.jl#L170-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.step!-Tuple{System{0}, LangevinHeunP}" href="#Sunny.step!-Tuple{System{0}, LangevinHeunP}"><code>Sunny.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, integrator)</code></pre><p>Advance the spin system forward one step using the parameters and integration scheme specified by <code>integrator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Integrators.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N" href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Symmetry/Crystal.jl#L392-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S&lt;:Sunny.AbstractSampler" href="#Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.thermalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermalize!(sampler, num_samples)</code></pre><p><code>sample!</code> a sampler a given number of times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/Samplers.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.view_crystal-Tuple{Crystal, Real}" href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal, max_dist::Real)</code></pre><p>Create and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using <code>browser()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/SunnyGfx/CrystalViewer.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ωvals-Tuple{StructureFactor}" href="#Sunny.ωvals-Tuple{StructureFactor}"><code>Sunny.ωvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ωvals(sf::StructureFactor)</code></pre><p>Return the ω-values associated with the energy index of a <code>StructureFactor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/31dde5550821d37ffa2be6bf1e41695fd6366076/src/StructureFactors/SFUtils.jl#L14-L18">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>To reduce package load times, certain plotting functions are only available when the user explicitly executes &quot;<code>using GLMakie</code>&quot;.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick-start/">« Quick Start</a><a class="docs-footer-nextpage" href="../structure-factor/">Structure Factor Calculations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 26 January 2023 16:42">Thursday 26 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
