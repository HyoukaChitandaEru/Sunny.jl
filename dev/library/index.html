<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library API ¬∑ Sunny documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sunny documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fei2_tutorial/">Case Study: FeI<span>$_{2}$</span></a></li><li><a class="tocitem" href="../examples/powder_averaging/">Powder Averaging</a></li><li><a class="tocitem" href="../examples/ising2d/">Classical Ising model</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library API</a><ul class="internal"><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><ul><li><a href="#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a></li><li><a href="#Sunny.ùí™"><code>Sunny.ùí™</code></a></li><li><a href="#Sunny.ùíÆ"><code>Sunny.ùíÆ</code></a></li><li><a href="#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a></li><li><a href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="#Sunny.Langevin"><code>Sunny.Langevin</code></a></li><li><a href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a></li><li><a href="#Sunny.Site"><code>Sunny.Site</code></a></li><li><a href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a></li><li><a href="#Sunny.SpinWaveTheory-Union{Tuple{System{N}}, Tuple{N}, Tuple{System{N}, Float64}, Tuple{System{N}, Float64, Float64}} where N"><code>Sunny.SpinWaveTheory</code></a></li><li><a href="#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a></li><li><a href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.StructureFactor</code></a></li><li><a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a></li><li><a href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>Sunny.DynamicStructureFactor</code></a></li><li><a href="#Sunny.InstantStructureFactor-Tuple{System}"><code>Sunny.InstantStructureFactor</code></a></li><li><a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>Sunny.add_sample!</code></a></li><li><a href="#Sunny.all_exact_wave_vectors-Tuple{StructureFactor}"><code>Sunny.all_exact_wave_vectors</code></a></li><li><a href="#Sunny.all_sites-Tuple{System}"><code>Sunny.all_sites</code></a></li><li><a href="#Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}"><code>Sunny.broaden_energy</code></a></li><li><a href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a></li><li><a href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a></li><li><a href="#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>Sunny.dispersion</code></a></li><li><a href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a></li><li><a href="#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>Sunny.dssf</code></a></li><li><a href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a></li><li><a href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a></li><li><a href="#Sunny.global_position-Tuple{System, Any}"><code>Sunny.global_position</code></a></li><li><a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.instant_intensities</code></a></li><li><a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.intensities</code></a></li><li><a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a></li><li><a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a></li><li><a href="#Sunny.lorentzian-Tuple{Any, Any}"><code>Sunny.lorentzian</code></a></li><li><a href="#Sunny.magnetic_moment-Tuple{System, Any}"><code>Sunny.magnetic_moment</code></a></li><li><a href="#Sunny.merge!-Tuple{StructureFactor, Vararg{Any}}"><code>Sunny.merge!</code></a></li><li><a href="#Sunny.minimize_energy!-Tuple{Any}"><code>Sunny.minimize_energy!</code></a></li><li><a href="#Sunny.plot_spins-Tuple{System}"><code>Sunny.plot_spins</code></a></li><li><a href="#Sunny.polarize_spin!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.polarize_spin!</code></a></li><li><a href="#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.polarize_spins!</code></a></li><li><a href="#Sunny.position_to_site-Tuple{System, Any}"><code>Sunny.position_to_site</code></a></li><li><a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a></li><li><a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a></li><li><a href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a></li><li><a href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a></li><li><a href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a></li><li><a href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a></li><li><a href="#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_wrapped_intensities</code></a></li><li><a href="#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a></li><li><a href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a></li><li><a href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a></li><li><a href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a></li><li><a href="#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a></li><li><a href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_geometry</code></a></li><li><a href="#Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_periodically</code></a></li><li><a href="#Sunny.rotate_operator-Tuple{Matrix, Any}"><code>Sunny.rotate_operator</code></a></li><li><a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a></li><li><a href="#Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>Sunny.set_anisotropy_at!</code></a></li><li><a href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_biquadratic!</code></a></li><li><a href="#Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>Sunny.set_biquadratic_at!</code></a></li><li><a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a></li><li><a href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>Sunny.set_exchange_at!</code></a></li><li><a href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a></li><li><a href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a></li><li><a href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a></li><li><a href="#Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}"><code>Sunny.spherical_shell</code></a></li><li><a href="#Sunny.step!"><code>Sunny.step!</code></a></li><li><a href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a></li><li><a href="#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}"><code>Sunny.suggest_magnetic_supercell</code></a></li><li><a href="#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>Sunny.symmetry_equivalent_bonds</code></a></li><li><a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a></li><li><a href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a></li><li><a href="#Sunny.œâs-Tuple{StructureFactor}"><code>Sunny.œâs</code></a></li><li><a href="#Sunny.@mix_proposals-Tuple"><code>Sunny.@mix_proposals</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Units.meV
Units.theory</code></pre><p>The unit system is implicitly determined by the definition of two physical constants: the vacuum permeability <span>$Œº‚ÇÄ$</span> and the Bohr magneton <span>$Œº_B$</span>. Temperatures are effectively measured in units of energy (<span>$k_B = 1$</span>) and time is effectively measured in units of inverse energy (<span>$ƒß = 1$</span>). The default unit system, <code>Units.meV</code>, employs (meV, ‚Ñ´, tesla). Select alternatively <code>Units.theory</code> for a units system defined so that <span>$Œº‚ÇÄ = Œº_B = 1$</span>.</p><p>See also <a href="#Sunny.meV_per_K"><code>meV_per_K</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Units.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.meV_per_K" href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meV_per_K = 0.086173332621451774</code></pre><p>A physical constant. Useful for converting kelvin into the default energy units, meV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Units.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ùí™" href="#Sunny.ùí™"><code>Sunny.ùí™</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ùí™[k,q]</code></pre><p>Abstract symbols for the Stevens operators. Linear combinations of these can be used to define a single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Operators/Symbolic.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ùíÆ" href="#Sunny.ùíÆ"><code>Sunny.ùíÆ</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ùíÆ[1], ùíÆ[2], ùíÆ[3]</code></pre><p>Abstract symbols for the spin operators. Polynomials of these can be used to define a single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Operators/Symbolic.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; symprec=1e-5)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>.  The optional parameter <code>symprec</code> controls the precision tolerance for spacegroup symmetries.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>latvecs</code>. Spacegroup symmetry information is automatically inferred. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(latvecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)</code></pre><p>Builds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional <code>setting</code> string will disambiguate between unit cell conventions.</p><p>Currently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a <code>.cif</code> file or from the full specification of the unit cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build an FCC crystal using the primitive unit cell. The spacegroup number
# 225 is inferred.
latvecs = [1 1 0;
            1 0 1;
            0 1 1] / 2
positions = [[0, 0, 0]]
Crystal(latvecs, positions)

# Build a CsCl crystal (two cubic sublattices). By providing distinct type
# strings, the spacegroup number 221 is inferred.
latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0,0,0], [0.5,0.5,0.5]]
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(latvecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227. This
# spacegroup has two possible settings (&quot;1&quot; or &quot;2&quot;), which determine an
# overall unit cell translation.
latvecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[1, 1, 1] / 4]
cryst = Crystal(latvecs, positions, 227; setting=&quot;1&quot;)</code></pre><p>See also <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Crystal.jl#L8-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}" href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FormFactor(atom::Int64, elem::String; g_lande=nothing)</code></pre><p>Basic type for specifying form factor parameters. Must be provided a site within the unit cell (<code>atom</code>) and a string specifying the element name. This used when calling <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>, which requires a list of <code>FormFactors</code>s.</p><p>A list of supported element names is available at:</p><p>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</p><p>The Land√© g-factor may also be specified. </p><p>In more detail, the data stored in a <code>FormFactor</code> will be used to compute the form factor for each momentum space magnitude <code>|k|</code>, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor <span>$f$</span> is returned. If the keyword <code>g_lande</code> is given a numerical value, then a second order form factor <span>$F$</span> is returned.</p><p>It is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable <span>$s = |k|/4œÄ$</span>, where <span>$|k|$</span> can be interpreted as the magnitude of momentum transfer.</p><p>The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation</p><p><span>$\langle j_l(s) \rangle = A e^{-as^2} + B e^{-bs^2} + Ce^{-cs^2} + D,$</span></p><p>where coefficients <span>$A, B, C, D, a, b, c$</span> are obtained from semi-empirical fits, depending on the orbital angular momentum index <span>$l = 0, 2$</span>. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.</p><p>A first approximation to the magnetic form factor is</p><p><span>$f(s) = \langle j_0(s) \rangle$</span></p><p>A second order correction is given by</p><p><span>$F(s) = \frac{2-g}{g} \langle j_2(s) \rangle s^2 + f(s)$</span>, where <span>$g$</span> is the Land√© g-factor.  </p><p>Digital tables are available at:</p><ul><li>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</li></ul><p>Additional references are:</p><ul><li>Marshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)</li><li>Clementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)</li><li>Freeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)</li><li>Descleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/FormFactor.jl#L12-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(Œît::Float64; atol=1e-12) where N</code></pre><p>Energy-conserving spin dynamics. One call to the <a href="#Sunny.step!"><code>step!</code></a> function will advance a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> by <code>Œît</code> units of time.</p><p>Uses the spherical midpoint integration scheme for dipole systems and the Schr√∂dinger midpoint integration scheme for SU(<em>N</em>) spin systems. Both integration schemes are symplectic, and therefore avoid energy drift over long periods of simulation time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Integrators.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Langevin" href="#Sunny.Langevin"><code>Sunny.Langevin</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Langevin(Œît::Float64; Œª::Float64, kT::Float64)</code></pre><p>Spin dynamics with coupling to a Langevin thermostat, which includes damping and noise terms. One call to the <a href="#Sunny.step!"><code>step!</code></a> function will advance a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> by <code>Œît</code> units of time.</p><p>Assuming ergodicity, the Langevin dynamics will sample from thermal equilibrium for the target temperature <code>kT</code>. The empirical parameter <code>Œª</code> determines the strength of the coupling to the thermal bath. In other words, <code>1/Œª</code> is the decorrelation time-scale. If <span>$Œª = 0$</span>, then the spin dynamics coincides with <a href="#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>.</p><p>An alternative approach to sampling is <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>, which may be preferred when the allowed spin values become effective discrete (e.g. Ising spins).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Integrators.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.LocalSampler" href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)</code></pre><p>Monte Carlo simulation involving Metropolis updates to individual spins. One call to the <a href="#Sunny.step!"><code>step!</code></a> function will perform <code>nsweeps</code> of MCMC sampling for a provided <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The default value of <code>1.0</code> means that <code>step!</code> performs, on average, one trial update per spin.</p><p>Assuming ergodicity, the <code>LocalSampler</code> will sample from thermal equilibrium for the target temperature <code>kT</code>. </p><p>The trial spin updates are sampled using the <code>propose</code> function. Built-in options include <a href="#Sunny.propose_uniform"><code>propose_uniform</code></a>, <a href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>propose_flip</code></a>, and <a href="#Sunny.propose_delta-Tuple{Any}"><code>propose_delta</code></a>. Multiple proposals can be mixed with the macro <a href="#Sunny.@mix_proposals-Tuple"><code>@mix_proposals</code></a>.</p><p>The returned object stores fields <code>ŒîE</code> and <code>Œîs</code>, which represent the cumulative change to the net energy and dipole, respectively.</p><p>An alternative approach to sampling is <a href="#Sunny.Langevin"><code>Langevin</code></a>, which may be preferred for simulating continuous spins, especially in the presence of long-range dipole-dipole interactions (cf. <a href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>enable_dipole_dipole!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Samplers.jl#L111-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Site" href="#Sunny.Site"><code>Sunny.Site</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(cell1, cell2, cell3, i) :: Site</code></pre><p>Four indices identifying a single site in a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The first three indices select the lattice cell and the last selects the sublattice (i.e., the atom within the unit cell).</p><p>This object can be used to index <code>dipoles</code> and <code>coherents</code> fields of a <code>System</code>. A <code>Site</code> is also required to specify inhomogeneous interactions via functions such as <a href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>set_external_field_at!</code></a> or <a href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>set_exchange_at!</code></a>.</p><p>Note that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the <code>Site</code> using <a href="#Sunny.position_to_site-Tuple{System, Any}"><code>position_to_site</code></a>, which always takes a position in fractional coordinates of the original lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L125-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.SpinInfo" href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinInfo(atom::Int; S, g=2)</code></pre><p>Characterizes the spin at a given <code>atom</code> index within the crystal unit cell. <code>S</code> is an integer multiple of 1/2 and gives the spin angular momentum in units of ƒß. <code>g</code> is the g-factor or tensor, such that an angular momentum dipole <span>$s$</span> produces a magnetic moment <span>$g s$</span> in units of the Bohr magneton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/SpinInfo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.SpinWaveTheory" href="#Sunny.SpinWaveTheory"><code>Sunny.SpinWaveTheory</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Additional fields for linear spin-wave calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/SpinWaveTheory/SpinWaveTheory.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.SpinWaveTheory-Union{Tuple{System{N}}, Tuple{N}, Tuple{System{N}, Float64}, Tuple{System{N}, Float64, Float64}} where N" href="#Sunny.SpinWaveTheory-Union{Tuple{System{N}}, Tuple{N}, Tuple{System{N}, Float64}, Tuple{System{N}, Float64, Float64}} where N"><code>Sunny.SpinWaveTheory</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>External constructor for <code>SpinWaveTheory</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/SpinWaveTheory/SpinWaveTheory.jl#L126-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.StructureFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructureFactor</code></pre><p>An object holding <span>$ùíÆ(ùê™,œâ)$</span> or <span>$ùíÆ(ùê™)$</span> data. Construct a <code>StructureFactor</code> using <a href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>DynamicStructureFactor</code></a> or <a href="#Sunny.InstantStructureFactor-Tuple{System}"><code>InstantStructureFactor</code></a>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/StructureFactors.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}" href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)</code></pre><p>Construct a <code>System</code> of spins for a given <a href="#Sunny.Crystal"><code>Crystal</code></a> symmetry. The <code>latsize</code> parameter determines the number of unit cells in each lattice vector direction. The <code>infos</code> parameter is a list of <a href="#Sunny.SpinInfo"><code>SpinInfo</code></a> objects, which determine the magnitude <span>$S$</span> and <span>$g$</span>-tensor of each spin.</p><p>The three possible options for <code>mode</code> are <code>:SUN</code>, <code>:dipole</code>, and <code>:large_S</code>. The most variationally accurate choice is <code>:SUN</code>, in which each spin-<span>$S$</span> degree of freedom is described as an SU(<em>N</em>) coherent state, where <span>$N = 2S + 1$</span>. Note that an SU(<em>N</em>) coherent state fully describes any local spin state; this description includes expected dipole components <span>$‚ü®SÃÇ·µÖ‚ü©$</span>, quadrupole components <span>$‚ü®SÃÇ·µÖSÃÇ·µù+SÃÇ·µùSÃÇ·µÖ‚ü©$</span>, etc.</p><p>The mode <code>:dipole</code> projects the SU(<em>N</em>) dynamics onto the space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but all single-ion anisotropy and biquadratic exchange interactions will be automatically renormalized for maximum accuracy.</p><p>To disable such renormalization, e.g. to reproduce results using the historical large-<span>$S$</span> classical limit, use the experimental mode <code>:large_S</code>. Modes <code>:SUN</code> or <code>:dipole</code> are strongly preferred for the development of new models.</p><p>The default units system of (meV, ‚Ñ´, tesla) can be overridden by with the <code>units</code> parameter; see <a href="#Sunny.Units"><code>Units</code></a>. </p><p>An optional <code>seed</code> may be provided to achieve reproducible random number generation.</p><p>All spins are initially polarized in the <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.DynamicStructureFactor-Tuple{System}" href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>Sunny.DynamicStructureFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DynamicStructureFactor(sys::System; Œît, nœâ, œâmax, 
    process_trajectory=:none, observables=nothing, correlations=nothing)</code></pre><p>Creates a <code>StructureFactor</code> for calculating and storing <span>$ùíÆ(ùê™,œâ)$</span> data. This information will be obtained by running dynamical spin simulations on equilibrium snapshots, and measuring pair-correlations. The <span>$ùíÆ(ùê™,œâ)$</span> data can be retrieved by calling <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>. Alternatively, <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a> will integrate out <span>$œâ$</span> to obtain <span>$ùíÆ(ùê™)$</span>, optionally applying classical-to-quantum correction factors.</p><p>Prior to calling <code>DynamicStructureFactor</code>, ensure that <code>sys</code> represents a good equilibrium sample. Additional sample data may be accumulated by calling <a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>add_sample!</code></a><code>(sf, sys)</code> with newly equilibrated <code>sys</code> configurations.</p><p>Three keywords are required to specify the dynamics used for the trajectory calculation.</p><ul><li><code>Œît</code>: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an <a href="#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a> integrator.</li><li><code>œâmax</code>: The maximum energy, <span>$œâ$</span>, that will be resolved.</li><li><code>nœâ</code>: The number of energy bins to calculated between 0 and <code>œâmax</code>.</li></ul><p>Additional keyword options are the following:</p><ul><li><code>process_trajectory</code>: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are <code>:none</code> and   <code>:symmetrize</code>. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.</li><li><code>observables</code>: Enables an advanced feature for SU(<em>N</em>) mode, allowing the user   to specify custom observables other than the three components of the dipole.   To use this features, <code>observables</code> must be given an <code>N√óN√ónumops</code> array,   where the final index is used to retrieve each <code>N√óN</code> operator.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$Œ±Œ≤$</span> of <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by the x, y, and z dipolar components (1, 2,   and 3 respectively). To retain only the xx and xy correlations, one would   set <code>correlations=[(1,1), (1,2)]</code>. If custom observables (<code>observables</code>) are   given, the indices are ordered in the same manner as the final index of   <code>ops</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/StructureFactors.jl#L117-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.InstantStructureFactor-Tuple{System}" href="#Sunny.InstantStructureFactor-Tuple{System}"><code>Sunny.InstantStructureFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InstantStructureFactor(sys::System; process_trajectory=:none,
                        observables=nothing, correlations=nothing)</code></pre><p>Creates a <code>StructureFactor</code> object for calculating and storing instantaneous structure factor intensities <span>$ùíÆ(ùê™)$</span>. This data will be calculated from the spin-spin correlations of equilibrium snapshots, absent any dynamical information. <span>$ùíÆ(ùê™)$</span> data can be retrieved by calling <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a>.</p><p><em>Important note</em>: When dealing with continuous (non-Ising) spins, consider creating a full <a href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>DynamicStructureFactor</code></a> object instead of an <code>InstantStructureFactor</code>. The former will provide full <span>$ùíÆ(ùê™,œâ)$</span> data, from which <span>$ùíÆ(ùê™)$</span> can be obtained by integrating out <span>$œâ$</span>. During this integration step, Sunny can incorporate temperature- and <span>$œâ$</span>-dependent classical-to-quantum correction factors to produce more accurate <span>$ùíÆ(ùê™)$</span> estimates. See <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a> for more information.</p><p>Prior to calling <code>InstantStructureFactor</code>, ensure that <code>sys</code> represents a good equilibrium sample. Additional sample data may be accumulated by calling <a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>add_sample!</code></a><code>(sf, sys)</code> with newly equilibrated <code>sys</code> configurations.</p><p>The following optional keywords are available:</p><ul><li><code>process_trajectory</code>: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are <code>:none</code> and   <code>:symmetrize</code>. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.</li><li><code>observables</code>: Enables an advanced feature for SU(<em>N</em>) mode, allowing the user   to specify custom observables other than the three components of the dipole.   To use this features, <code>observables</code> must be given an <code>N√óN√ónumops</code> array,   where the final index is used to retrieve each <code>N√óN</code> operator.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$Œ±Œ≤$</span> of <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by the x, y, and z dipolar components (1, 2,   and 3 respectively). To retain only the xx and xy correlations, one would   set <code>correlations=[(1,1), (1,2)]</code>. If custom observables (<code>observables</code>) are   given, the indices are ordered in the same manner as the final index of   <code>observables</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/StructureFactors.jl#L169-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.add_sample!-Tuple{StructureFactor, System}" href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>Sunny.add_sample!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_sample!(sf::StructureFactor, sys::System)</code></pre><p><code>add_trajectory</code> uses the spin configuration contained in the <code>System</code> to generate a correlation data and accumulate it into <code>sf</code>. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculating in time and accumulated into <code>sf</code>. </p><p>This function will change the state of <code>sys</code> when calculating dynamical structure factor data. To preserve the initial state of <code>sys</code>, it must be saved separately prior to calling <code>add_sample!</code>. Alternatively, the initial spin configuration may be copied into a new <code>System</code> and this new <code>System</code> can be passed to <code>add_sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/SampleGeneration.jl#L128-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_exact_wave_vectors-Tuple{StructureFactor}" href="#Sunny.all_exact_wave_vectors-Tuple{StructureFactor}"><code>Sunny.all_exact_wave_vectors</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_exact_wave_vectors(sf::StructureFactor; bzsize=(1,1,1))</code></pre><p>Returns all wave vectors for which <code>sf</code> contains exact values. <code>bsize</code> specifies the number of Brillouin zones to be included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/SFUtils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_sites-Tuple{System}" href="#Sunny.all_sites-Tuple{System}"><code>Sunny.all_sites</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_sites(sys::System)</code></pre><p>An iterator over all <a href="#Sunny.Site"><code>Site</code></a>s in the system. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}" href="#Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}"><code>Sunny.broaden_energy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broaden_energy(sf::StructureFactor, vals, kernel::Function; negative_energies=false)</code></pre><p>Performs a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>. <code>kernel</code> must be a function that takes two numbers: <code>kernel(œâ, œâ‚ÇÄ)</code>, where <code>œâ</code> is a frequency, and <code>œâ‚ÇÄ</code> is the center frequency of the kernel. Sunny provides <a href="#Sunny.lorentzian-Tuple{Any, Any}"><code>lorentzian</code></a> for the most common use case:</p><pre><code class="nohighlight hljs">newvals = broaden_energy(sf, vals, (œâ, œâ‚ÇÄ) -&gt; lorentzian(œâ-œâ‚ÇÄ, 0.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/DataRetrieval.jl#L235-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.browser-Tuple{String}" href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">browser(html_str; dir)</code></pre><p>Launch a system browser to display the provided HTML string or SunnyViewer. If a directory <code>dir</code> is provided, an HTML file will be written at that location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/SunnyGfx/SunnyGfx.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.connected_path-Tuple{Vector, Any}" href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connected_path(qs::Vector, density)</code></pre><p>Takes a list of wave vectors, <code>qs</code>, and builds an expanded list of wave vectors that traces a path through the provided points. Also returned is a list of marker indices corresponding to the intput points. The <code>density</code> parameter controls the frequency of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/DataRetrieval.jl#L199-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.dispersion-Tuple{SpinWaveTheory, Any}" href="#Sunny.dispersion-Tuple{SpinWaveTheory, Any}"><code>Sunny.dispersion</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispersion(swt::SpinWaveTheory, qs)</code></pre><p>Computes the spin excitation energy dispersion relations given a <code>SpinWaveField</code> and an array of wave vectors <code>qs</code>. Each element <span>$q$</span> of <code>qs</code> must be a 3-vector in units of reciprocal lattice units. I.e., <span>$q·µ¢$</span> is given in <span>$2œÄ/|a·µ¢|$</span> with <span>$|a·µ¢|$</span> the lattice constant of the chemical lattice.</p><p>The first indices of the returned array correspond to those of <code>qs</code>. A final index, corresponding to mode, is added to these. Each entry of the array is an energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/SpinWaveTheory/SWTCalculations.jl#L352-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.dmvec-Tuple{Any}" href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Antisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,</p><pre><code class="nohighlight hljs">  [  0    D[3] -D[2]
   -D[3]   0    D[1]
    D[2] -D[1]   0  ]</code></pre><p>Useful in the context of <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/PairExchange.jl#L240-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.dssf-Tuple{SpinWaveTheory, Any}" href="#Sunny.dssf-Tuple{SpinWaveTheory, Any}"><code>Sunny.dssf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dssf(swt::SpinWaveTheory, qs)</code></pre><p>Computes the dynamical spin structure factor:   ùíÆ·µÖ·µù(k, œâ) = 1/(2œÄN)‚à´dœâ ‚àë‚Çñ     exp[i(œât - k‚ãÖr)] ‚ü®S·µÖ(r, t)S·µù(0, 0)‚ü©   For spin-wave theory at the linear level ùíÆ·µÖ·µù(k, œâ) = ‚àë‚Çô |A‚Çô·µÖ·µù(k)|¬≤Œ¥[œâ-œâ‚Çô(k)]. </p><p><code>qs</code> is an array of wave vectors of arbitrary dimension. Each element <span>$q$</span> of <code>qs</code> must be a 3-vector in reciprocal lattice units. I.e., <span>$q·µ¢$</span> is given in <span>$2œÄ/|a·µ¢|$</span> with <span>$|a·µ¢|$</span> the lattice constant of the chemical lattice.</p><p>The first indices of the returned array correspond to those of <code>qs</code>. A final index, corresponding to mode, is added to these. Each entry of this array is a tensor (3x3 matrix) containing with indices Œ± and Œ≤ corresponding to <span>$ùíÆ·µÖ·µù(q,œâ)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/SpinWaveTheory/SWTCalculations.jl#L387-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System)</code></pre><p>Enables long-range dipole-dipole interactions,</p><p class="math-container">\[    -(Œº‚ÇÄ/4œÄ) ‚àë_{‚ü®ij‚ü©}  (3 (ùêå_j‚ãÖùê´ÃÇ_{ij})(ùêå_i‚ãÖùê´ÃÇ_{ij}) - ùêå_i‚ãÖùêå_j) / |ùê´_{ij}|^3\]</p><p>where the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are <span>$ùêå_i = Œº_B g ùêí_i$</span> where <span>$g$</span> is the g-factor or g-tensor, and <span>$ùêí_i$</span> is the spin angular momentum dipole in units of ƒß. The Bohr magneton <span>$Œº_B$</span> and vacuum permeability <span>$Œº_0$</span> are physical constants, with numerical values determined by the unit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L56-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>Computes the total system energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forces(Array{Vec3}, sys::System)</code></pre><p>Returns the effective local field (force) at each site, <span>$ùêÅ = -‚àÇE/‚àÇùê¨$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.global_position-Tuple{System, Any}" href="#Sunny.global_position-Tuple{System, Any}"><code>Sunny.global_position</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_position(sys::System, site::Site)</code></pre><p>Position of a <a href="#Sunny.Site"><code>Site</code></a> in global coordinates.</p><p>To precompute a full list of positions, one can use <a href="#Sunny.all_sites-Tuple{System}"><code>all_sites</code></a> as below:</p><pre><code class="language-julia hljs">pos = [global_position(sys, site) for site in all_sites(sys)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L164-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.instant_intensities</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_intensities(sf::StructureFactor, qs, mode; kwargs...)</code></pre><p>Return <span>$ùíÆ(ùê™)$</span> intensities at wave vectors <code>qs</code>. The functionality is very similar to <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>, except the returned array has dimensions identical to <code>qs</code>. If called on a <code>StructureFactor</code> with dynamical information, i.e., <span>$ùíÆ(ùê™,œâ)$</span>, the <span>$œâ$</span> information is integrated out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/DataRetrieval.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.intensities</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities(sf::StructureFactor, qs, mode; interpolation = nothing,
                kT = nothing, formfactors = nothing, negative_energies = false)</code></pre><p>The basic function for retrieving <span>$ùíÆ(ùê™,œâ)$</span> information from a <code>StructureFactor</code>. Maps an array of wave vectors <code>qs</code> to an array of structure factor intensities, including an additional energy index. The values of <span>$œâ$</span> associated with the energy index can be retrieved by calling <a href="#Sunny.œâs-Tuple{StructureFactor}"><code>œâs</code></a>. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.</p><ul><li><code>mode</code>: Should be one of <code>:trace</code>, <code>:perp</code>, or <code>:full</code>. Determines an optional   contraction on the indices <span>$Œ±$</span> and <span>$Œ≤$</span> of <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span>. Setting   <code>trace</code> yields <span>$‚àë_Œ± ùíÆ^{Œ±Œ±}(q,œâ)$</span>. Setting <code>perp</code> will contract   <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span> with the dipole factor <span>$Œ¥_{Œ±Œ≤} - q_{Œ±}q_{Œ≤}$</span>, returning   the unpolarized intensity. Setting <code>full</code> will return all elements   <span>$ùíÆ^{Œ±Œ≤}(ùê™,œâ)$</span> without contraction.</li><li><code>interpolation</code>: Since <span>$ùíÆ(ùê™, œâ)$</span> is calculated on a finite lattice, data   is only available at discrete wave vectors. By default, Sunny will round a   requested <code>q</code> to the nearest available wave vector. Linear interpolation can   be applied by setting <code>interpolation=:linear</code>.</li><li><code>kT</code>: If a temperature is provided, the intensities will be rescaled by a   temperature- and œâ-dependent classical-to-quantum factor. <code>kT</code> should be   specified when making comparisons with spin wave calculations or   experimental data.</li><li><code>formfactors</code>: To apply form factor corrections, provide this keyword with a   vector of <code>FormFactor</code>s, one for each unique site in the unit cell. Sunny   will symmetry propagate the results to all equivalent sites.</li><li><code>negative_energies</code>: If set to <code>true</code>, Sunny will return the periodic   extension of the energy axis. Most users will not want this.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/DataRetrieval.jl#L66-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}" href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_params(latvecs::Mat3)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, Œ±, Œ≤, Œ≥)$</span> for the three lattice vectors provided as columns of <code>latvecs</code>. The inverse mapping is <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_vectors-NTuple{6, Any}" href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)</code></pre><p>Return the lattice vectors, as columns of the <span>$3√ó3$</span> output matrix, that correspond to the conventional unit cell defined by the lattice constants <span>$(a, b, c)$</span> and the angles <span>$(Œ±, Œ≤, Œ≥)$</span> in degrees. The inverse mapping is <a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>lattice_params</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/LatticeUtils.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lorentzian-Tuple{Any, Any}" href="#Sunny.lorentzian-Tuple{Any, Any}"><code>Sunny.lorentzian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lorentzian(x, Œ∑)</code></pre><p>Returns <span>$Œ∑/(œÄ(x^2 + Œ∑^2))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/DataRetrieval.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.magnetic_moment-Tuple{System, Any}" href="#Sunny.magnetic_moment-Tuple{System, Any}"><code>Sunny.magnetic_moment</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">magnetic_moment(sys::System, site::Site)</code></pre><p>Get the magnetic moment for a <a href="#Sunny.Site"><code>Site</code></a>. This is the spin dipole multiplied by the Bohr magneton and the local g-tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.merge!-Tuple{StructureFactor, Vararg{Any}}" href="#Sunny.merge!-Tuple{StructureFactor, Vararg{Any}}"><code>Sunny.merge!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge!(sf::StructureFactor, others...)</code></pre><p>Accumulate the samples in <code>others</code> (one or more <code>StructureFactors</code>) into <code>sf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/StructureFactors.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.minimize_energy!-Tuple{Any}" href="#Sunny.minimize_energy!-Tuple{Any}"><code>Sunny.minimize_energy!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimize_energy!(sys; method=Optim.LBFGS, kwargs...)</code></pre><p>Minimize the energy of a spin system using either LBFGS (<code>method=Optim.LBFGS</code>) or Conjugate Gradient (<code>method=Optim.ConjugateGradient</code>) methods. Currently only works for systems in dipole mode. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Optimization.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.plot_spins-Tuple{System}" href="#Sunny.plot_spins-Tuple{System}"><code>Sunny.plot_spins</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_spins(sys::System; linecolor=:grey, arrowcolor=:red, linewidth=0.1,
                            arrowsize=0.3, arrowlength=1.0, kwargs...)</code></pre><p>Plot the spin configuration defined by <code>sys</code>. <code>kwargs</code> are passed to <code>GLMakie.arrows</code>.        </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Plotting.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.polarize_spin!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N" href="#Sunny.polarize_spin!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N"><code>Sunny.polarize_spin!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarize_spin!(sys::System, dir, site::Site)</code></pre><p>Polarize the spin at a <a href="#Sunny.Site"><code>Site</code></a> along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L399-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.polarize_spins!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarize_spins!(sys::System, dir)</code></pre><p>Polarize all spins in the system along the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.position_to_site-Tuple{System, Any}" href="#Sunny.position_to_site-Tuple{System, Any}"><code>Sunny.position_to_site</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position_to_site(sys::System, r)</code></pre><p>Converts a position <code>r</code> to four indices of a <a href="#Sunny.Site"><code>Site</code></a>. The coordinates of <code>r</code> are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using <a href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_geometry</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find the `site` at the center of a unit cell which is displaced by four
# multiples of the first lattice vector
site = position_to_site(sys, [4.5, 0.5, 0.5])

# Print the dipole at this site
println(sys.dipoles[site])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L200-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_classical_spins-Tuple{Any}" href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_classical_spins(p)</code></pre><p>Prints a quantum operator (e.g. linear combination of Stevens operators) as a polynomial of spin expectation values in the classical limit.</p><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Operators/Symbolic.jl#L225-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_stevens-Tuple{Any}" href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_stevens(p; N)</code></pre><p>Prints a quantum operator (e.g. a polynomial of the spin operators <code>ùíÆ</code>) as a linear combination of Stevens operators. The parameter <code>N</code> specifies the dimension of the SU(<em>N</em>) representation, corresponding to quantum spin magnitude <span>$S = (N-1)/2$</span>. The special value <code>N = 0</code> indicates the large-<span>$S$</span> classical limit.</p><p>In the output, the symbol <code>X</code> denotes the spin operator magnitude squared. Quantum spin operators <span>$ùíÆ$</span> of any finite dimension satisfy <span>$X = |ùíÆ|^2 = S (S+1)$</span>. To take the large-<span>$S$</span> limit, however, we keep only leading order powers of <span>$S$</span>, such that <span>$X = S^2$</span>.</p><p>This function can be useful for understanding the conversions performed internally by <a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>set_anisotropy!</code></a>.</p><p>For the inverse mapping, see <a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>print_anisotropy_as_classical_spins</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Operators/Symbolic.jl#L239-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_bond-Tuple{Crystal, Bond}" href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Printing.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_site-Tuple{Any, Any}" href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_site(cryst, i; R=I)</code></pre><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Printing.jl#L225-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_suggested_frame-Tuple{Crystal, Int64}" href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_suggested_frame(cryst, i; digits=4)</code></pre><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. This is useful to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Printing.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_symmetry_table-Tuple{Crystal, Any}" href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Printing.jl#L190-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_wrapped_intensities</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_wrapped_intensities(sys::System; nmax=10)</code></pre><p>For Bravais lattices: Prints up to <code>nmax</code> wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are na√Øvely averaged over sublattices, without incorporating phase shift information. Only wavevectors within the first Brillouin zone are printed. Wavevector coordinates are given in reciprocal lattice units, such that each coordinate is between <span>$-1/2$</span> and <span>$1/2$</span>.  The output from this function will typically be used as input to <a href="#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}"><code>suggest_magnetic_supercell</code></a>.</p><p>Because this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use <a href="#Sunny.InstantStructureFactor-Tuple{System}"><code>InstantStructureFactor</code></a> instead.</p><p>The weights printed by <code>print_wrapped_intensities</code> may be given a physical interpretation as follows: All possible <span>$q$</span>-vectors are periodically wrapped into the first Brillouin zone, and the average over their corresponding instantaneous structure factor intensities produce the output weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Reshaping.jl#L171-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_delta-Tuple{Any}" href="#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_delta(magnitude)</code></pre><p>Generate a proposal function that adds a Gaussian perturbation to the existing spin state. In <code>:dipole</code> mode, the procedure is to first introduce a random three-vector perturbation <span>$ùê¨‚Ä≤ = ùê¨ + |ùê¨| Œæ$</span> and then return the properly normalized spin <span>$|ùê¨| (ùê¨‚Ä≤/|ùê¨‚Ä≤|)$</span>. Each component of the random vector <span>$Œæ$</span> is Gaussian distributed with a standard deviation of <code>magnitude</code>; the latter is dimensionless and typically smaller than one. </p><p>In <code>:SUN</code> mode, the procedure is analogous, but now involving Gaussian perturbations to each of the <span>$N$</span> complex components of an SU(<em>N</em>) coherent state.</p><p>In the limit of very large <code>magnitude</code>, this function coincides with <a href="#Sunny.propose_uniform"><code>propose_uniform</code></a>.</p><p>For use with <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Samplers.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_flip</code></pre><p>Function to propose pure spin flip updates in the context of a <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>. Dipoles are flipped as <span>$ùê¨ ‚Üí -ùê¨$</span>. SU(<em>N</em>) coherent states are flipped using the time-reversal operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Samplers.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_uniform" href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propose_uniform</code></pre><p>Function to propose a uniformly random spin update in the context of a <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>. In <code>:dipole</code> mode, the result is a random three-vector with appropriate normalization. In <code>:SUN</code> mode, the result is a random SU(<em>N</em>) coherent state with appropriate normalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Samplers.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reference_bonds-Tuple{Crystal, Float64}" href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/SymmetryAnalysis.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat_periodically(sys::System{N}, counts) where N</code></pre><p>Creates a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> identical to <code>sys</code> but repeated a given number of times in each dimension, specified by the tuple <code>counts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Reshaping.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_geometry</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reshape_geometry(sys::System, A)</code></pre><p>Maps an existing <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> to a new one that has the shape and periodicity of a requested supercell. The columns of the <span>$3√ó3$</span> integer matrix <code>A</code> represent the supercell lattice vectors measured in units of the original crystal lattice vectors.</p><p>The crystal unit cell may also need to be reshaped to achieve the desired periodicity of the requested supercell. If this is the case, the returned <code>System</code> object will be missing symmetry information. Consequently, certain operations will be unavailable for this system, e.g., setting interactions by symmetry propagation. In practice, one can set all interactions using the original system, and then reshape as a final step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Reshaping.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_periodically</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_periodically(sys::System{N}, latsize) where N</code></pre><p>Creates a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> identical to <code>sys</code> but enlarged to a given number of unit cells in each lattice vector direction.</p><p>An error will be thrown if <code>sys</code> is incommensurate with <code>latsize</code>. Use <a href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_geometry</code></a> instead to reduce the volume, or to perform an incommensurate reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Reshaping.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.rotate_operator-Tuple{Matrix, Any}" href="#Sunny.rotate_operator-Tuple{Matrix, Any}"><code>Sunny.rotate_operator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_operator(A, R)</code></pre><p>Rotates the local quantum operator <code>A</code> according to the <span>$3√ó3$</span> rotation matrix <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Operators/Rotation.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N" href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_anisotropy!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The parameter <code>op</code> may be a polynomial in symbolic spin operators <code>ùíÆ[Œ±]</code>, or a linear combination of symbolic Stevens operators <code>ùí™[k,q]</code>.</p><p>The characters <code>ùíÆ</code> and <code>ùí™</code> can be copy-pasted from this help message, or typed at a Julia terminal using <code>\scrS</code> or <code>\scrO</code> followed by tab-autocomplete.</p><p>For systems restricted to dipoles, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An easy axis anisotropy in the z-direction
set_anisotropy!(sys, -D*ùíÆ[3]^3, i)

# The unique quartic single-ion anisotropy for a site with cubic point group
# symmetry
set_anisotropy!(sys, ùí™[4,0] + 5ùí™[4,4], i)

# An equivalent expression of this quartic anisotropy, up to a constant shift
set_anisotropy!(sys, 20*(ùíÆ[1]^4 + ùíÆ[2]^4 + ùíÆ[3]^4), i)</code></pre><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/SingleIonAnisotropy.jl#L80-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N" href="#Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>Sunny.set_anisotropy_at!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_anisotropy_at!(sys::System, op, site::Site)</code></pre><p>Sets the single-ion anisotropy operator <code>op</code> for a single <a href="#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry.  The system must support inhomogeneous interactions via <a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>set_anisotropy!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/SingleIonAnisotropy.jl#L161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_biquadratic!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_biquadratic!(sys::System, J, bond::Bond)</code></pre><p>Sets a scalar biquadratic interaction along <code>bond</code>, yielding a pairwise energy <span>$J (ùêí_i‚ãÖùêí_j)¬≤$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous biquadratic exchange interactions on these bonds will be overwritten.</p><p>For systems restricted to dipoles, the biquadratic interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode. This renormalization introduces also a correction to the quadratic part of the exchange.</p><p>See also <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/PairExchange.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N" href="#Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>Sunny.set_biquadratic_at!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_biquadratic_at!(sys::System, J, site1::Site, site2::Site)</code></pre><p>Sets the scalar biquadratic interaction along the single bond connecting two <a href="#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. The system must support inhomogeneous interactions via <a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_biquadratic!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/PairExchange.jl#L185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond)</code></pre><p>Sets a 3√ó3 spin-exchange matrix <code>J</code> along <code>bond</code>, yielding a pairwise interaction energy <span>$ùêí_i‚ãÖJ ùêí_j$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>Scalar <code>J</code> implies a pure Heisenberg exchange.</p><p>As a convenience, <code>dmvec(D)</code> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$ùêÉ‚ãÖ(ùêí_i√óùêí_j)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Sunny, LinearAlgebra

# An explicit exchange matrix
J1 = [2 3 0;
     -3 2 0;
      0 0 2]
set_exchange!(sys, J1, bond)

# An equivalent Heisenberg + DM exchange 
J2 = 2*I + dmvec([0,0,3])
set_exchange!(sys, J2, bond)</code></pre><p>See also <a href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_biquadratic!</code></a>, <a href="#Sunny.dmvec-Tuple{Any}"><code>dmvec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/PairExchange.jl#L77-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N" href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>Sunny.set_exchange_at!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange_at!(sys::System, J, site1::Site, site2::Site)</code></pre><p>Sets the exchange interaction along the single bond connecting two <a href="#Sunny.Site"><code>Site</code></a>s, ignoring crystal symmetry. The system must support inhomogeneous interactions via <a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/PairExchange.jl#L208-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field!-Tuple{System, Any}" href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field!(sys::System, B::Vec3)</code></pre><p>Sets the external field <code>B</code> that couples to all spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field_at!-Tuple{System, Any, Any}" href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field_at!(sys::System, B::Vec3, site::Site)</code></pre><p>Sets a Zeeman coupling between a field <code>B</code> and a single spin. <a href="#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vacancy_at!(sys::System, site::Site)</code></pre><p>Make a single site nonmagnetic. <a href="#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}" href="#Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}"><code>Sunny.spherical_shell</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spherical_shell(sf::StructureFactor, radius, density)</code></pre><p>Returns a set of wave vectors lying on a sphere of specified radius, where <code>radius</code> is given in <span>$√Ö^{-1}$</span>. <code>density</code> controls how many points to select per <span>$√Ö^{-2}$</span>. </p><p>The points are generated by mapping a Fibonacci lattice onto a sphere. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/PowderAveraging.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.step!" href="#Sunny.step!"><code>Sunny.step!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, dynamics)</code></pre><p>Advance the spin configuration one dynamical time-step. The <code>dynamics</code> object may be a continuous spin dynamics, such as <a href="#Sunny.Langevin"><code>Langevin</code></a> or <a href="#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>, or it may be a discrete Monte Carlo sampling scheme such as <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Integrators.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N" href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Symmetry/Crystal.jl#L459-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.suggest_magnetic_supercell-Tuple{Any, Any}" href="#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}"><code>Sunny.suggest_magnetic_supercell</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">suggest_magnetic_supercell(qs, latsize)</code></pre><p>Suggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors in <code>qs</code>. An upper bound for the supercell is given by <code>latsize</code>, which is measured in units of lattice vectors, and must be commensurate with the wavevectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Reshaping.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}" href="#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}"><code>Sunny.symmetry_equivalent_bonds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetry_equivalent_bonds(sys::System, bond::Bond)</code></pre><p>Given a <a href="#Sunny.Bond"><code>Bond</code></a> for the original (unreshaped) crystal, return all symmetry equivalent bonds in the <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. Each returned bond is represented as a pair of <a href="#Sunny.Site"><code>Site</code></a>s, which may be used as input to <a href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>set_exchange_at!</code></a> or <a href="#Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>set_biquadratic_at!</code></a>. Reverse bonds are not included (no double counting).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">for (site1, site2) in symmetry_equivalent_bonds(sys, bond)
    @assert site1 &lt; site2
    set_exchange_at!(sys, J, site1, site2)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/System.jl#L279-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_inhomogeneous(sys::System)</code></pre><p>Returns a copy of the system that allows for inhomogeneous interactions, which can be set using <a href="#Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>set_anisotropy_at!</code></a>, <a href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>set_exchange_at!</code></a>, <a href="#Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Any}} where N"><code>set_biquadratic_at!</code></a>, and <a href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>set_vacancy_at!</code></a>.</p><p>Inhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/System/Interactions.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.view_crystal-Tuple{Crystal, Real}" href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal, max_dist::Real)</code></pre><p>Create and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using <code>browser()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/SunnyGfx/CrystalViewer.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.œâs-Tuple{StructureFactor}" href="#Sunny.œâs-Tuple{StructureFactor}"><code>Sunny.œâs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâs(sf::StructureFactor; negative_energies=false)</code></pre><p>Return the œâ values for the energy index of a <code>StructureFactor</code>. By default, only returns values for non-negative energies, which corresponds to the default output of <code>intensities</code>. Set <code>negative_energies</code> to true to retrieve all œâ values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/StructureFactors/SFUtils.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.@mix_proposals-Tuple" href="#Sunny.@mix_proposals-Tuple"><code>Sunny.@mix_proposals</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@propose_mix weight1 propose1 weight2 propose2 ...</code></pre><p>Macro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># A proposal function that proposes a spin flip 40% of the time, and a
# Gaussian perturbation 60% of the time.
@propose_mix 0.4 propose_flip 0.6 propose_delta(0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/5bde5f42b03ae100e4b082b41fca3dc64c5ce6b4/src/Samplers.jl#L69-L82">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>To reduce package load times, certain plotting functions are only available when the user explicitly executes &quot;<code>using GLMakie</code>&quot;.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/ising2d/">¬´ Classical Ising model</a><a class="docs-footer-nextpage" href="../structure-factor/">Structure Factor Calculations ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 16:54">Tuesday 18 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
