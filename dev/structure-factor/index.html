<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structure Factor Calculations · Sunny documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sunny documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fei2_tutorial/">Case Study: FeI<span>$_{2}$</span></a></li><li><a class="tocitem" href="../examples/out_of_equilibrium/">CP<span>$^2$</span> Skyrmion Quench</a></li><li><a class="tocitem" href="../examples/powder_averaging/">Powder averaged CoRh<span>$_2$</span>O<span>$_4$</span></a></li><li><a class="tocitem" href="../examples/fei2_classical/">Structure Factors with Classical Dynamics</a></li><li><a class="tocitem" href="../examples/ising2d/">Classical Ising model</a></li><li><a class="tocitem" href="../examples/one_dim_chain/">Fitting model parameters in a 1D spin-1 ferromagnetic chain</a></li></ul></li><li><a class="tocitem" href="../library/">Library API</a></li><li class="is-active"><a class="tocitem" href>Structure Factor Calculations</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Estimating-stucture-factors-with-classical-dynamics"><span>Estimating stucture factors with classical dynamics</span></a></li></ul></li><li><a class="tocitem" href="../anisotropy/">Single-Ion Anisotropy</a></li><li><a class="tocitem" href="../writevtk/">Volumetric Rendering with ParaView</a></li><li><a class="tocitem" href="../parallelism/">Parallel Computation</a></li><li><a class="tocitem" href="../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Structure Factor Calculations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structure Factor Calculations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/structure-factor.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Structure-Factor-Calculations"><a class="docs-heading-anchor" href="#Structure-Factor-Calculations">Structure Factor Calculations</a><a id="Structure-Factor-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-Factor-Calculations" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The dynamical structure factor is of fundamental importance for characterizing a magnetic system, and facilitates quantitative comparison between theory and experimental scattering data.</p><p>Consider, for example, a two-point dynamical spin correlation function, <span>$⟨s^α(𝐱+Δ𝐱, t+Δt) s^β(𝐱, t)⟩$</span>. Here <span>$s^α(𝐱, t)$</span> represents the time dynamics of a spin dipole component <span>$α$</span> at position <span>$𝐱$</span>, and brackets represent an average over equilibrium initial conditions and over <span>$(𝐱, t)$</span>. The dynamical structure factor is defined as the Fourier transform of this two-point correlation in both space and time, up to an overall scaling factor. Using the convolution theorem, the result is,</p><p class="math-container">\[𝒮^{αβ}(𝐪, ω) = \frac{1}{V} ⟨ŝ^α(𝐪, ω)^\ast ŝ^β(𝐪, ω) ⟩,\]</p><p>with <span>$V$</span> the system volume. We will restrict attention to lattice systems with periodic boundaries.</p><p>Consider a crystal unit cell defined by three lattice vectors <span>$𝐚_1, 𝐚_2, 𝐚_3$</span>, and linear system sizes <span>$L_1, L_2, L_3$</span> measured in unit cells. The allowed momentum vectors take on discrete values <span>$𝐪 = \sum_{α=1}^{3} m_α 𝐛_α / L_α$</span>, where <span>$m_α$</span> are an integers and the reciprocal lattice vectors <span>$𝐛_α$</span> are defined to satisfy <span>$𝐚_α ⋅ 𝐛_β = 2π δ_{α,β}$</span>. For a Bravais lattice, <span>$𝐪$</span> will be periodic in the first Brillouin zone, i.e., under any shift <span>$𝐪 → 𝐪 ± 𝐛_α$</span>. More generally, consider a non-Bravais lattice such that each unit cell may contain multiple spins. By partitioning spins <span>$s_j(𝐱,t)$</span> according to their sublattice index <span>$j$</span>, the relevant momenta <span>$𝐪$</span> remain discretized as above, but now periodicity in the first Brillouin zone is lost. The structure factor may be written as a phase-average over the displacements between sublattices <span>$𝐫_{j,k}$</span>,</p><p class="math-container">\[𝒮^{αβ}(𝐪, ω) = ∑_{j,k} e^{i 𝐫_{j,k} ⋅ 𝐪} 𝒮̃^{αβ}_{j,k}(𝐪, ω) ⟩,\]</p><p>From a theoretical perspective, the quantity</p><p class="math-container">\[𝒮̃^{αβ}_{j,k}(𝐪, ω) = \frac{1}{V} ⟨ŝ_j^α(𝐪, ω)^\ast ŝ_k^β(𝐪, ω)⟩\]</p><p>is fundamental. For each sublattice <span>$j$</span>, the data <span>$ŝ_j^α(𝐪, ω)$</span> can be efficiently obtained by fast Fourier tranformation of a real space configuration <span>$s_j^α(𝐱, t)$</span>. Internally, Sunny will calculate and store the discrete <span>$𝒮̃^{αβ}_{j,k}(𝐪, ω)$</span> correlation data, and use this to construct <span>$𝒮^{αβ}(𝐪,ω)$</span> intensities that can be compared with experiment.</p><p>Calculating this structure factor involves several steps, with various possible settings. Sunny provides a number of tools to facilitate this calculation and to extract information from the results. These tools are briefly outlined below. Please see the Examples for a &quot;real life&quot; use case. Detailed function information is available in the Library API.</p><h2 id="Estimating-stucture-factors-with-classical-dynamics"><a class="docs-heading-anchor" href="#Estimating-stucture-factors-with-classical-dynamics">Estimating stucture factors with classical dynamics</a><a id="Estimating-stucture-factors-with-classical-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-stucture-factors-with-classical-dynamics" title="Permalink"></a></h2><p>Classical dynamics may be used to estimate structure factor data by analyzing the spin-spin correlations of dynamical trajectories. This is fundamentally a Monte Carlo approach, as the trajectories must be started from an initial spin configuration that is sampled at thermal equilibrium. (Note that it is not possible to estimate a true T=0 dynamical structure factor using this method, but the temperature may be very low.) Samples are accumulated into a <code>SampledCorrelations</code>, from which intensity information may be extracted. The user does not typically build their own <code>SampledCorrelations</code> but instead initializes one by calling either <code>dynamical_correlations</code> or <code>instant_correlations</code>, as described below.</p><h3 id="Estimating-a-dynamical-structure-factor:-𝒮(𝐪,ω)"><a class="docs-heading-anchor" href="#Estimating-a-dynamical-structure-factor:-𝒮(𝐪,ω)">Estimating a dynamical structure factor: <span>$𝒮(𝐪,ω)$</span></a><a id="Estimating-a-dynamical-structure-factor:-𝒮(𝐪,ω)-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-a-dynamical-structure-factor:-𝒮(𝐪,ω)" title="Permalink"></a></h3><p>A <code>SampledCorrelations</code> for estimating the dynamical structure factor, <span>$𝒮^{αβ}(𝐪,ω)$</span>, may be created by calling <a href="../library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a>. This requires three keyword arguments. These will determine the dynamics used to calculate samples and, consequently, the <span>$ω$</span> information that will be available. </p><ol><li><code>Δt</code>: Determines the step size used for simulating the dynamics. A smaller number will require proportionally more calculation time. While a smaller <code>Δt</code> will enable the resolution of higher energies, <code>Δt</code> is typically selected to ensure numerical stability rather than to maximize the largest <span>$ω$</span> value. A safe choice is to use the smaller value of <code>Δt = 0.1/(J* S^2)</code> or <code>Δt = 0.1/(D * S)</code>, where <code>S</code> is magnetic moment of the largest local spin (as specified in <a href="../library/#Sunny.SpinInfo"><code>SpinInfo</code></a>), <code>J</code> is the parameter governing the largest bilinear interaction (e.g. exchange), and <code>D</code> is the parameter governing the largest single-site term of the Hamiltonian (e.g., anisotropy or Zeeman term).</li><li><code>ωmax</code>: Sets the maximum resolved energy. Note that this is not independent of <code>Δt</code>. If <code>ωmax</code> too large, Sunny will throw an error and ask you to choose a smaller <code>Δt</code>. </li><li><code>nω</code>: Determines the number of energy bins to resolve. A larger number will require more calculation time.</li></ol><p>A sample may be added by calling <code>add_sample!(sc, sys)</code>. The input <code>sys</code> must be a spin configuration in good thermal equilibrium, e.g., using the continuous <a href="../library/#Sunny.Langevin"><code>Langevin</code></a> dynamics or using single spin flip trials with <a href="../library/#Sunny.LocalSampler"><code>LocalSampler</code></a>. The statistical quality of the <span>$𝒮^{αβ}(𝐪,ω)$</span> can be improved by repeatedly generating decorrelated spin configurations in <code>sys</code> and calling <code>add_sample!</code> on each configuration.</p><p>The outline of typical use case might look like this:</p><pre><code class="nohighlight hljs"># Make a `SampledCorrelations`
sc = dynamical_correlations(sys; Δt=0.05, ωmax=10.0, nω=100) 

# Add samples
for _ in 1:nsamples
   decorrelate_system(sys) # Perform some type of Monte Carlo simulation
   add_sample!(sc, sys)    # Use spins to calculate trajectory and accumulate new sample of 𝒮(𝐪,ω)
end</code></pre><p>The calculation may be configured in a number of ways; see the <a href="../library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> documentation for a list of all keywords.</p><h3 id="Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-𝒮(𝐪)"><a class="docs-heading-anchor" href="#Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-𝒮(𝐪)">Estimating an instantaneous (&quot;static&quot;) structure factor: <span>$𝒮(𝐪)$</span></a><a id="Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-𝒮(𝐪)-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-𝒮(𝐪)" title="Permalink"></a></h3><p>Sunny provides two methods for calculating instantaneous, or static, structure factors: <span>$𝒮^{αβ}(𝐪)$</span>. The first involves calculating spatial spin-spin correlations at single time slices. The second involves calculating a dynamic structure factor first and integrating out the <span>$ω$</span> information. The advantage of the latter approach is that it enables application of an <span>$ω$</span>-dependent classical-to-quantum rescaling of structure factor intensities, a method that should be preferred whenever comparing results to experimental data or spin wave calculations. A disadvantage of this approach is that it is computationally more expensive. There are also many cases when it is not straightforward to calculate a meaningful dynamics, as when working with Ising spins. In this section we will discuss how to calculate instantaneous structure factors from static spin configurations. Information about calculating instantaneous data from a dynamical correlations can be found in the following section.</p><p>The basic usage for the instantaneous case is very similar to the dynamic case, except one calls <a href="../library/#Sunny.instant_correlations-Tuple{System}"><code>instant_correlations</code></a> instead of <code>dynamical_correlations</code> to configure a <code>SampledCorrelations</code>. Note that there are no required keywords as there is no need to specify any dynamics. <code>instant_correlations</code> will return a <code>SampledCorrelations</code> containing no data. Samples may be added by calling <code>add_sample!(sc, sys)</code>, where <code>sc</code> is the <code>SampledCorrelations</code>. When performing a finite-temperature calculation, it is important to ensure that the spin configuration in the <code>sys</code> represents a good equilibrium sample, as in the dynamical case. Note, however, that we recommend calculating instantaneous correlations at finite temperature calculations by using full dynamics (i.e., using <code>dynamical_correlations</code>) and then integrating out the energy axis. An approach to doing this is described in the next section.</p><h3 id="Extracting-information-from-sampled-correlation-data"><a class="docs-heading-anchor" href="#Extracting-information-from-sampled-correlation-data">Extracting information from sampled correlation data</a><a id="Extracting-information-from-sampled-correlation-data-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-information-from-sampled-correlation-data" title="Permalink"></a></h3><p>The basic function for extracting information from a <code>SampledCorrelations</code> at a particular wave vector, <span>$𝐪$</span>, is <a href="../library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. It takes a <code>SampledCorrelations</code>, a <em>list</em> of wave vectors, and an <a href="../library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>intensity_formula</code></a>. The <code>intensity_formula</code> specifies how to contract and correct correlation data to arrive at a physical intensity. A simple example is <code>formula = intensity_formula(sc, :perp)</code>, which will instruct Sunny apply polarization corrections: <span>$\sum_{αβ}(I-q_α q_β) 𝒮^{αβ}(𝐪,ω)$</span>. An intensity at the wave vector <span>$𝐪 = (𝐛_2 + 𝐛_3)/2$</span> may then be retrieved with  <code>intensities_interpolated(sf, [[0.0, 0.5, 0.5]], formula)</code> .  <code>intensities_interpolated</code> returns a list of <code>nω</code> elements at each wavevector. The corresponding <span>$ω$</span> values can be retrieved by calling <a href="../library/#Sunny.available_energies-Tuple{SampledCorrelations}"><code>available_energies</code></a> on <code>sf</code>.</p><p>Since Sunny only calculates the structure factor on a finite lattice when performing classical simulations, it is important to realize that exact information is only available at a discrete set of wave vectors. Specifically, for each axis index <span>$i$</span>, we will get information at <span>$q_i = \frac{n}{L_i}$</span>, where <span>$n$</span> runs from <span>$(\frac{-L_i}{2}+1)$</span> to <span>$\frac{L_i}{2}$</span> and <span>$L_i$</span> is the linear dimension of the lattice used for the calculation. If you request a wave vector that does not fall into this set, Sunny will automatically round to the nearest <span>$𝐪$</span> that is available. If <code>intensities_interpolated</code> is given the keyword argument <code>interpolation=:linear</code>, Sunny will use trilinear interpolation to determine a result at the requested wave vector. </p><p>To retrieve the intensities at all wave vectors for which there is exact data, first call the function <a href="../library/#Sunny.available_wave_vectors-Tuple{SampledCorrelations}"><code>available_wave_vectors</code></a> to generate a list of <code>qs</code>. This takes an optional keyword argument <code>bzsize</code>, which must be given a tuple of three integers specifying the number of Brillouin zones to calculate, e.g., <code>bzsize=(2,2,2)</code>. The resulting list of wave vectors may then be passed to <code>intensities_interpolated</code>.</p><p>Alternatively, <a href="../library/#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a> can be used to place the exact data into histogram bins for comparison with experiment.</p><p>The convenience function <a href="../library/#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>reciprocal_space_path</code></a> returns a list of wavevectors sampled along a path that connects specified <span>$𝐪$</span> points. This list can be used as an input to <code>intensities</code>. Another convenience method, <a href="../library/#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}"><code>reciprocal_space_shell</code></a> will generate points on a sphere of a given radius. This is useful for powder averaging. </p><p>A number of arguments for <a href="../library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>intensity_formula</code></a> are available which modify the calculation of structure factor intensity. It is generally recommended to provide a value of <code>kT</code> corresponding to the temperature of sampled configurations. Given <code>kT</code>, Sunny will include an energy- and temperature-dependent classical-to-quantum  rescaling of intensities in the formula.</p><p>To retrieve intensity data from a instantaneous structure factor, use <a href="../library/#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a>, which accepts similar arguments to <code>intensities_interpolated</code>. This function may also be used to calculate instantaneous information from a dynamical correlation data, i.e. from a <code>SampledCorrelations</code> created with <code>dynamical_correlations</code>. Note that it is important to supply a value to <code>kT</code> to reap the benefits of this approach over simply calculating a static structure factor at the outset. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Library API</a><a class="docs-footer-nextpage" href="../anisotropy/">Single-Ion Anisotropy »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 11 September 2023 20:59">Monday 11 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
