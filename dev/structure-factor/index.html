<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structure Factor Calculations Â· Sunny documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sunny documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fei2_tutorial/">Case Study: FeI<span>$_{2}$</span></a></li><li><a class="tocitem" href="../examples/out_of_equilibrium/">CP<span>$^2$</span> Skyrmion Quench</a></li><li><a class="tocitem" href="../examples/powder_averaging/">Powder averaged CoRh<span>$_2$</span>O<span>$_4$</span></a></li><li><a class="tocitem" href="../examples/fei2_classical/">Structure Factors with Classical Dynamics</a></li><li><a class="tocitem" href="../examples/ising2d/">Classical Ising model</a></li><li><a class="tocitem" href="../examples/one_dim_chain/">Fitting model parameters in a 1D spin-1 ferromagnetic chain</a></li></ul></li><li><a class="tocitem" href="../library/">Library API</a></li><li class="is-active"><a class="tocitem" href>Structure Factor Calculations</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Estimating-stucture-factors-with-classical-dynamics"><span>Estimating stucture factors with classical dynamics</span></a></li></ul></li><li><a class="tocitem" href="../anisotropy/">Single-Ion Anisotropy</a></li><li><a class="tocitem" href="../writevtk/">Volumetric Rendering with ParaView</a></li><li><a class="tocitem" href="../parallelism/">Parallel Computation</a></li><li><a class="tocitem" href="../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Structure Factor Calculations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structure Factor Calculations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/structure-factor.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Structure-Factor-Calculations"><a class="docs-heading-anchor" href="#Structure-Factor-Calculations">Structure Factor Calculations</a><a id="Structure-Factor-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-Factor-Calculations" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The dynamical structure factor is of fundamental importance for characterizing a magnetic system, and facilitates quantitative comparison between theory and experimental scattering data.</p><p>Consider, for example, a two-point dynamical spin correlation function, <span>$âŸ¨s^Î±(ğ±+Î”ğ±, t+Î”t) s^Î²(ğ±, t)âŸ©$</span>. Here <span>$s^Î±(ğ±, t)$</span> represents the time dynamics of a spin dipole component <span>$Î±$</span> at position <span>$ğ±$</span>, and brackets represent an average over equilibrium initial conditions and over <span>$(ğ±, t)$</span>. The dynamical structure factor is defined as the Fourier transform of this two-point correlation in both space and time, up to an overall scaling factor. Using the convolution theorem, the result is,</p><p class="math-container">\[ğ’®^{Î±Î²}(ğª, Ï‰) = \frac{1}{V} âŸ¨sÌ‚^Î±(ğª, Ï‰)^\ast sÌ‚^Î²(ğª, Ï‰) âŸ©,\]</p><p>with <span>$V$</span> the system volume. We will restrict attention to lattice systems with periodic boundaries.</p><p>Consider a crystal unit cell defined by three lattice vectors <span>$ğš_1, ğš_2, ğš_3$</span>, and linear system sizes <span>$L_1, L_2, L_3$</span> measured in unit cells. The allowed momentum vectors take on discrete values <span>$ğª = \sum_{Î±=1}^{3} m_Î± ğ›_Î± / L_Î±$</span>, where <span>$m_Î±$</span> are an integers and the reciprocal lattice vectors <span>$ğ›_Î±$</span> are defined to satisfy <span>$ğš_Î± â‹… ğ›_Î² = 2Ï€ Î´_{Î±,Î²}$</span>. For a Bravais lattice, <span>$ğª$</span> will be periodic in the first Brillouin zone, i.e., under any shift <span>$ğª â†’ ğª Â± ğ›_Î±$</span>. More generally, consider a non-Bravais lattice such that each unit cell may contain multiple spins. By partitioning spins <span>$s_j(ğ±,t)$</span> according to their sublattice index <span>$j$</span>, the relevant momenta <span>$ğª$</span> remain discretized as above, but now periodicity in the first Brillouin zone is lost. The structure factor may be written as a phase-average over the displacements between sublattices <span>$ğ«_{j,k}$</span>,</p><p class="math-container">\[ğ’®^{Î±Î²}(ğª, Ï‰) = âˆ‘_{j,k} e^{i ğ«_{j,k} â‹… ğª} ğ’®Ìƒ^{Î±Î²}_{j,k}(ğª, Ï‰) âŸ©,\]</p><p>From a theoretical perspective, the quantity</p><p class="math-container">\[ğ’®Ìƒ^{Î±Î²}_{j,k}(ğª, Ï‰) = \frac{1}{V} âŸ¨sÌ‚_j^Î±(ğª, Ï‰)^\ast sÌ‚_k^Î²(ğª, Ï‰)âŸ©\]</p><p>is fundamental. For each sublattice <span>$j$</span>, the data <span>$sÌ‚_j^Î±(ğª, Ï‰)$</span> can be efficiently obtained by fast Fourier tranformation of a real space configuration <span>$s_j^Î±(ğ±, t)$</span>. Internally, Sunny will calculate and store the discrete <span>$ğ’®Ìƒ^{Î±Î²}_{j,k}(ğª, Ï‰)$</span> correlation data, and use this to construct <span>$ğ’®^{Î±Î²}(ğª,Ï‰)$</span> intensities that can be compared with experiment.</p><p>Calculating this structure factor involves several steps, with various possible settings. Sunny provides a number of tools to facilitate this calculation and to extract information from the results. These tools are briefly outlined below. Please see the Examples for a &quot;real life&quot; use case. Detailed function information is available in the Library API.</p><h2 id="Estimating-stucture-factors-with-classical-dynamics"><a class="docs-heading-anchor" href="#Estimating-stucture-factors-with-classical-dynamics">Estimating stucture factors with classical dynamics</a><a id="Estimating-stucture-factors-with-classical-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-stucture-factors-with-classical-dynamics" title="Permalink"></a></h2><p>Classical dynamics may be used to estimate structure factor data by analyzing the spin-spin correlations of dynamical trajectories. This is fundamentally a Monte Carlo approach, as the trajectories must be started from an initial spin configuration that is sampled at thermal equilibrium. (Note that it is not possible to estimate a true T=0 dynamical structure factor using this method, but the temperature may be very low.) Samples are accumulated into a <code>SampledCorrelations</code>, from which intensity information may be extracted. The user does not typically build their own <code>SampledCorrelations</code> but instead initializes one by calling either <code>dynamical_correlations</code> or <code>instant_correlations</code>, as described below.</p><h3 id="Estimating-a-dynamical-structure-factor:-ğ’®(ğª,Ï‰)"><a class="docs-heading-anchor" href="#Estimating-a-dynamical-structure-factor:-ğ’®(ğª,Ï‰)">Estimating a dynamical structure factor: <span>$ğ’®(ğª,Ï‰)$</span></a><a id="Estimating-a-dynamical-structure-factor:-ğ’®(ğª,Ï‰)-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-a-dynamical-structure-factor:-ğ’®(ğª,Ï‰)" title="Permalink"></a></h3><p>A <code>SampledCorrelations</code> for estimating the dynamical structure factor, <span>$ğ’®^{Î±Î²}(ğª,Ï‰)$</span>, may be created by calling <a href="../library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a>. This requires three keyword arguments. These will determine the dynamics used to calculate samples and, consequently, the <span>$Ï‰$</span> information that will be available. </p><ol><li><code>Î”t</code>: Determines the step size used for simulating the dynamics. A smaller number will require proportionally more calculation time. While a smaller <code>Î”t</code> will enable the resolution of higher energies, <code>Î”t</code> is typically selected to ensure numerical stability rather than to maximize the largest <span>$Ï‰$</span> value. A safe choice is to use the smaller value of <code>Î”t = 0.1/(J* S^2)</code> or <code>Î”t = 0.1/(D * S)</code>, where <code>S</code> is magnetic moment of the largest local spin (as specified in <a href="../library/#Sunny.SpinInfo"><code>SpinInfo</code></a>), <code>J</code> is the parameter governing the largest bilinear interaction (e.g. exchange), and <code>D</code> is the parameter governing the largest single-site term of the Hamiltonian (e.g., anisotropy or Zeeman term).</li><li><code>Ï‰max</code>: Sets the maximum resolved energy. Note that this is not independent of <code>Î”t</code>. If <code>Ï‰max</code> too large, Sunny will throw an error and ask you to choose a smaller <code>Î”t</code>. </li><li><code>nÏ‰</code>: Determines the number of energy bins to resolve. A larger number will require more calculation time.</li></ol><p>A sample may be added by calling <code>add_sample!(sc, sys)</code>. The input <code>sys</code> must be a spin configuration in good thermal equilibrium, e.g., using the continuous <a href="../library/#Sunny.Langevin"><code>Langevin</code></a> dynamics or using single spin flip trials with <a href="../library/#Sunny.LocalSampler"><code>LocalSampler</code></a>. The statistical quality of the <span>$ğ’®^{Î±Î²}(ğª,Ï‰)$</span> can be improved by repeatedly generating decorrelated spin configurations in <code>sys</code> and calling <code>add_sample!</code> on each configuration.</p><p>The outline of typical use case might look like this:</p><pre><code class="nohighlight hljs"># Make a `SampledCorrelations`
sc = dynamical_correlations(sys; Î”t=0.05, Ï‰max=10.0, nÏ‰=100) 

# Add samples
for _ in 1:nsamples
   decorrelate_system(sys) # Perform some type of Monte Carlo simulation
   add_sample!(sc, sys)    # Use spins to calculate trajectory and accumulate new sample of ğ’®(ğª,Ï‰)
end</code></pre><p>The calculation may be configured in a number of ways; see the <a href="../library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N"><code>dynamical_correlations</code></a> documentation for a list of all keywords.</p><h3 id="Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-ğ’®(ğª)"><a class="docs-heading-anchor" href="#Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-ğ’®(ğª)">Estimating an instantaneous (&quot;static&quot;) structure factor: <span>$ğ’®(ğª)$</span></a><a id="Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-ğ’®(ğª)-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-an-instantaneous-(&quot;static&quot;)-structure-factor:-ğ’®(ğª)" title="Permalink"></a></h3><p>Sunny provides two methods for calculating instantaneous, or static, structure factors: <span>$ğ’®^{Î±Î²}(ğª)$</span>. The first involves calculating spatial spin-spin correlations at single time slices. The second involves calculating a dynamic structure factor first and integrating out the <span>$Ï‰$</span> information. The advantage of the latter approach is that it enables application of an <span>$Ï‰$</span>-dependent classical-to-quantum rescaling of structure factor intensities, a method that should be preferred whenever comparing results to experimental data or spin wave calculations. A disadvantage of this approach is that it is computationally more expensive. There are also many cases when it is not straightforward to calculate a meaningful dynamics, as when working with Ising spins. In this section we will discuss how to calculate instantaneous structure factors from static spin configurations. Information about calculating instantaneous data from a dynamical correlations can be found in the following section.</p><p>The basic usage for the instantaneous case is very similar to the dynamic case, except one calls <a href="../library/#Sunny.instant_correlations-Tuple{System}"><code>instant_correlations</code></a> instead of <code>dynamical_correlations</code> to configure a <code>SampledCorrelations</code>. Note that there are no required keywords as there is no need to specify any dynamics. <code>instant_correlations</code> will return a <code>SampledCorrelations</code> containing no data. Samples may be added by calling <code>add_sample!(sc, sys)</code>, where <code>sc</code> is the <code>SampledCorrelations</code>. When performing a finite-temperature calculation, it is important to ensure that the spin configuration in the <code>sys</code> represents a good equilibrium sample, as in the dynamical case. Note, however, that we recommend calculating instantaneous correlations at finite temperature calculations by using full dynamics (i.e., using <code>dynamical_correlations</code>) and then integrating out the energy axis. An approach to doing this is described in the next section.</p><h3 id="Extracting-information-from-sampled-correlation-data"><a class="docs-heading-anchor" href="#Extracting-information-from-sampled-correlation-data">Extracting information from sampled correlation data</a><a id="Extracting-information-from-sampled-correlation-data-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-information-from-sampled-correlation-data" title="Permalink"></a></h3><p>The basic function for extracting information from a <code>SampledCorrelations</code> at a particular wave vector, <span>$ğª$</span>, is <a href="../library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any, Sunny.ClassicalIntensityFormula}"><code>intensities_interpolated</code></a>. It takes a <code>SampledCorrelations</code>, a <em>list</em> of wave vectors, and an <a href="../library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>intensity_formula</code></a>. The <code>intensity_formula</code> specifies how to contract and correct correlation data to arrive at a physical intensity. A simple example is <code>formula = intensity_formula(sc, :perp)</code>, which will instruct Sunny apply polarization corrections: <span>$\sum_{Î±Î²}(I-q_Î± q_Î²) ğ’®^{Î±Î²}(ğª,Ï‰)$</span>. An intensity at the wave vector <span>$ğª = (ğ›_2 + ğ›_3)/2$</span> may then be retrieved with  <code>intensities_interpolated(sf, [[0.0, 0.5, 0.5]], formula)</code> .  <code>intensities_interpolated</code> returns a list of <code>nÏ‰</code> elements at each wavevector. The corresponding <span>$Ï‰$</span> values can be retrieved by calling <a href="../library/#Sunny.available_energies-Tuple{SampledCorrelations}"><code>available_energies</code></a> on <code>sf</code>.</p><p>Since Sunny only calculates the structure factor on a finite lattice when performing classical simulations, it is important to realize that exact information is only available at a discrete set of wave vectors. Specifically, for each axis index <span>$i$</span>, we will get information at <span>$q_i = \frac{n}{L_i}$</span>, where <span>$n$</span> runs from <span>$(\frac{-L_i}{2}+1)$</span> to <span>$\frac{L_i}{2}$</span> and <span>$L_i$</span> is the linear dimension of the lattice used for the calculation. If you request a wave vector that does not fall into this set, Sunny will automatically round to the nearest <span>$ğª$</span> that is available. If <code>intensities_interpolated</code> is given the keyword argument <code>interpolation=:linear</code>, Sunny will use trilinear interpolation to determine a result at the requested wave vector. </p><p>To retrieve the intensities at all wave vectors for which there is exact data, first call the function <a href="../library/#Sunny.available_wave_vectors-Tuple{SampledCorrelations}"><code>available_wave_vectors</code></a> to generate a list of <code>qs</code>. This takes an optional keyword argument <code>bzsize</code>, which must be given a tuple of three integers specifying the number of Brillouin zones to calculate, e.g., <code>bzsize=(2,2,2)</code>. The resulting list of wave vectors may then be passed to <code>intensities_interpolated</code>.</p><p>Alternatively, <a href="../library/#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters, Sunny.ClassicalIntensityFormula}"><code>intensities_binned</code></a> can be used to place the exact data into histogram bins for comparison with experiment.</p><p>The convenience function <a href="../library/#Sunny.reciprocal_space_path-Tuple{Crystal, Any, Any}"><code>reciprocal_space_path</code></a> returns a list of wavevectors sampled along a path that connects specified <span>$ğª$</span> points. This list can be used as an input to <code>intensities</code>. Another convenience method, <a href="../library/#Sunny.reciprocal_space_shell-Tuple{Crystal, Any, Any}"><code>reciprocal_space_shell</code></a> will generate points on a sphere of a given radius. This is useful for powder averaging. </p><p>A number of arguments for <a href="../library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}"><code>intensity_formula</code></a> are available which modify the calculation of structure factor intensity. It is generally recommended to provide a value of <code>kT</code> corresponding to the temperature of sampled configurations. Given <code>kT</code>, Sunny will include an energy- and temperature-dependent classical-to-quantum  rescaling of intensities in the formula.</p><p>To retrieve intensity data from a instantaneous structure factor, use <a href="../library/#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any, Any}"><code>instant_intensities_interpolated</code></a>, which accepts similar arguments to <code>intensities_interpolated</code>. This function may also be used to calculate instantaneous information from a dynamical correlation data, i.e. from a <code>SampledCorrelations</code> created with <code>dynamical_correlations</code>. Note that it is important to supply a value to <code>kT</code> to reap the benefits of this approach over simply calculating a static structure factor at the outset. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">Â« Library API</a><a class="docs-footer-nextpage" href="../anisotropy/">Single-Ion Anisotropy Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 11 September 2023 20:59">Monday 11 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
