<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SU(N) Spin Simulations</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SU(N) Spin Simulations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SU(N) Spin Simulations</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">FastDipole.jl</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions"><span>Example 1: Diamond lattice with antiferromagnetic Heisenberg interactions</span></a></li><li><a class="tocitem" href="#Example-2:-FeI-with-a-complex-collection-of-interactions"><span>Example 2: FeI₂ with a complex collection of interactions</span></a></li><li><a class="tocitem" href="#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation"><span>Example 3: Making manual measurements within a Monte Carlo simulation</span></a></li><li><a class="tocitem" href="#Symmetry-analysis"><span>Symmetry analysis</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MagSims/FastDipole/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>The examples stepped through here are available in <code>examples/</code> as full loadable files containing executable functions. Specifically, we work through here the simulations performed in <code>examples/reproduce_testcases.jl</code>. All of the plotting code in here currently depends on an installation of <a href="http://docs.juliaplots.org/latest/">Plots.jl</a>.</p><p>The high-level outline of performing a simulation is:</p><ol><li>Create a <a href="../library/#FastDipole.Symmetry.Crystal"><code>Crystal</code></a>, either by providing explicit geometry information  (Example 1), or by loading a <code>.cif</code> file (Example 2).</li><li>Using the <code>Crystal</code>, construct a <a href="../library/#FastDipole.Lattice"><code>Lattice</code></a> which specifies the system  size, and a collection of <a href="../library/#Interactions">Interactions</a> assembled into a <a href="../library/#FastDipole.Hamiltonian"><code>Hamiltonian</code></a>.</li><li>Assemble a <a href="../library/#FastDipole.SpinSystem"><code>SpinSystem</code></a> using the newly created <code>Lattice</code> and <code>Interaction</code>s.</li><li>Construct a sampler, either a <a href="../library/#FastDipole.LangevinSampler-Tuple{SpinSystem, Float64, Float64, Float64, Int64}"><code>LangevinSampler</code></a> (Example 1), or a   <a href="../library/#FastDipole.MetropolisSampler"><code>MetropolisSampler</code></a> (Example 2).</li><li>Use the sampler directly to sample new states, or use it to perform <a href="../library/#Structure-factor-calculations">Structure factor calculations</a>.</li></ol><p>Defining interactions in step (2) can be aided by our utilities for symmetry analysis, demonstrated at the bottom of this page.</p><p>In all examples, we will assume that <code>FastDipole</code> and <code>StaticArrays</code> have been loaded:</p><pre><code class="language-julia hljs">using FastDipole
using StaticArrays</code></pre><h2 id="Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions"><a class="docs-heading-anchor" href="#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions">Example 1: Diamond lattice with antiferromagnetic Heisenberg interactions</a><a id="Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions" title="Permalink"></a></h2><p>In this example, we will step through the basic steps needed to set up and run a spin dynamics simulation, with finite-<span>$T$</span> statistics obtained by using Langevin dynamics. The full example is contained in the function <code>test_diamond_heisenberg_sf()</code> within <code>examples/reproduce_testcases.jl</code>.</p><p><strong>(1)</strong> We construct a diamond lattice by explicitly defining the lattice geometry. We will use the conventional cubic Bravais lattice with an 8-site basis. Our simulation box will be <span>$8 \times 8 \times 8$</span> unit cells along each axis. Since we&#39;re not thinking about a specific system, we label all of the sites with the arbitrary species label <code>&quot;A&quot;</code>.</p><pre><code class="language-julia hljs">lat_vecs = [4.0 0.0 0.0;
            0.0 4.0 0.0;
            0.0 0.0 4.0]
basis_vecs = [
    [0.0, 0.0, 0.0],
    [0.0, 1/2, 1/2],
    [1/2, 0.0, 1/2],
    [1/2, 1/2, 0.0],
    [3/4, 3/4, 3/4],
    [3/4, 1/4, 1/4],
    [1/4, 3/4, 1/4],
    [1/4, 1/4, 3/4]
]
basis_labels = fill(&quot;A&quot;, 8)
latsize = [8, 8, 8]
lattice = Lattice{3}(lat_vecs, basis_vecs, basis_labels, latsize)
crystal = Crystal(lattice)</code></pre><p>Here, <code>Lattice</code> is a type which holds the geometry of our simulation box. This type can be indexed into as an array of size <code>B×Lx×Ly×Lz</code>, with the first index selecting the sublattice and the remaining three selecting the unit cell, and the absolute position of the selected site will be given. For example, the following gives the position of the second sublattice site in the unit cell which is fifth along each axis: </p><pre><code class="nohighlight hljs">julia&gt; lattice[2, 5, 5, 5]
3-element SVector{3, Float64} with indices SOneTo(3):
 20.0
 22.0
 22.0</code></pre><p>(To save a minor amount of arithmetic, the bottom-left corner of the simulation box lives at <span>$a+b+c$</span> rather than 0). From this <code>Lattice</code>, we created a <code>Crystal</code> that infers extra information about the symmetries of the lattice and is needed to define interactions in our system later.</p><p><strong>(2)</strong> In step 1, we ended up already creating our <code>Lattice</code>, so all that is left is to define our Heisenberg interactions. We want to set up nearest-neighbor antiferromagnetic interactions with a strength of <span>$J = 28.28~\mathrm{K}$</span>. One nearest-neighbor bond is the one connecting basis site 3 with basis site 6 within a single unit cell. (We can figure this out using our tools for symmetry analysis, at the bottom of this page).</p><pre><code class="language-julia hljs">J = 28.28           # Units of K
interactions = [
    Heisenberg(J, crystal, Bond{3}(3, 6, SA[0,0,0])),
]
ℋ = Hamiltonian{3}(interactions)</code></pre><p>Here, the <code>3</code> in both <code>Bond{3}</code> and <code>Hamiltonian{3}</code> indicates that they are defined in the context of a 3-dimensional system.</p><p><strong>(3)</strong> Assembling a <code>SpinSystem</code> is straightforward. Then, we will randomize the system so that all spins are randomly placed on the unit sphere.</p><pre><code class="language-julia hljs">sys = SpinSystem(lattice, ℋ)
rand!(sys)</code></pre><p>The <code>SpinSystem</code> type is the central type used throughout our simulations. Internally, it contains the spin degrees of freedom which evolve during the simulation as well as the Hamiltonian defining how this evolution should occur. The type is indexable in the same way as <code>Lattice</code>, by providing a sublattice index alongside indices into the unit cell axes:</p><pre><code class="nohighlight hljs">sys[2, 5, 5, 5]
3-element SVector{3, Float64} with indices SOneTo(3):
  0.22787294226659
  0.41462045511988654
 -0.8810015893169237</code></pre><p>Now, we are obtaining the actual spin variable living at site <code>(2, 5, 5, 5)</code>.</p><p><strong>(4)</strong> We will simulate this system using Langevin dynamics, so we need to create a <a href="../library/#FastDipole.LangevinSampler-Tuple{SpinSystem, Float64, Float64, Float64, Int64}"><code>LangevinSampler</code></a>. Note that the units of integration time and temperature are relative to the units implicitly used when setting up the interactions.</p><pre><code class="language-julia hljs">Δt = 0.02 / J       # Units of 1/K
kT = 4.             # Units of K
α  = 0.1
kB = 8.61733e-5     # Units of eV/K
nsteps = 20000
sampler = LangevinSampler(sys, kT, α, Δt, nsteps)</code></pre><p>At this point we can call <code>sample!(sampler)</code> to produce new samples of the system, which will be reflected in the state of <code>sysc</code>. Instead, we will proceed to calculate the finite-<span>$T$</span> structure factor using our built-in routines.</p><p><strong>(5)</strong> The full process of calculating a structure factor is handled by <a href="../library/#FastDipole.structure_factor"><code>structure_factor</code></a>. Internally, this function:</p><ol><li>Thermalizes the system for a while</li><li>Samples a new thermal spin configuration</li><li>Performs constant-energy LL dynamics to obtain a Fourier-transformed  dynamics trajectory. Use this trajectory to calculate a structure  factor contribution <span>$S^{\alpha,\beta}(\boldsymbol{q}, \omega)$</span>.</li><li>Repeat steps (2,3), averaging structure factors across samples.</li></ol><p>See the documentation of <a href="../library/#FastDipole.structure_factor"><code>structure_factor</code></a> for details of how this process is controlled by the function arguments, and how to properly index into the resulting array.</p><p>In this example, we will just look at the diagonal elements of this matrix along some cuts in reciprocal space. To improve statistics, we average these elements across the <span>$x, y, z$</span> spin directions since they are all symmetry equivalent in this model.</p><pre><code class="language-julia hljs">meas_rate = 10
S = structure_factor(
    sys, sampler; num_samples=5, dynΔt=Δt, meas_rate=meas_rate,
    num_freqs=1600, bz_size=(1,1,2), therm_samples=10, verbose=true
)

# Retain just the diagonal elements, which we will average across the
#  symmetry-equivalent directions.
avgS = zeros(Float64, axes(S)[3:end])
for α in 1:3
    @. avgS += real(S[α, α, :, :, :, :])
end
</code></pre><p>We then plot some cuts using a function <code>plot_many_cuts</code> defined within the example script. (I.e. this code block will not successfully execute unless you <code>include(&quot;examples/reproduce_testcases.jl)</code>). We omit this code here as it&#39;s just a large amount of indexing and plotting code, but for details see the script.</p><pre><code class="language-julia hljs"># Calculate the maximum ω present in our FFT
# Need to scale by (S+1) with S=3/2 to match the reference,
#  and then convert to meV.
maxω = 1000 * 2π / ((meas_rate * Δt) / kB) / (5/2)
p = plot_many_cuts(avgS; maxω=maxω, chopω=5.0)
display(p)</code></pre><h2 id="Example-2:-FeI-with-a-complex-collection-of-interactions"><a class="docs-heading-anchor" href="#Example-2:-FeI-with-a-complex-collection-of-interactions">Example 2: FeI₂ with a complex collection of interactions</a><a id="Example-2:-FeI-with-a-complex-collection-of-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-FeI-with-a-complex-collection-of-interactions" title="Permalink"></a></h2><p>In this example, we work through performing a more complicated and realistic simulation of FeI₂. While the number of interactions is much larger, the general process will be remarkably similar. We will also see how to perform sampling using Metropolis Monte Carlo through the <a href="../library/#FastDipole.MetropolisSampler"><code>MetropolisSampler</code></a> type. The full example is contained in the function <code>test_FeI2_MC()</code> within <code>examples/reproduce_testcases.jl</code>.</p><p><strong>(1)</strong> As before, the first step is to make a <a href="../library/#FastDipole.Symmetry.Crystal"><code>Crystal</code></a>. However, this time we will load the crystal directly from a common crystallographic file format called a <code>.cif</code>. You can download the structure file from <a href="https://materials.springer.com/isp/crystallographic/docs/sd_0548497">this link</a>. Then, we can load it as:</p><pre><code class="language-julia hljs">cryst = Crystal(&quot;./FeI2.cif&quot;)
cryst = subcrystal(cryst, &quot;Fe2+&quot;)</code></pre><p>(Be sure to change <code>&quot;./FeI2.cif&quot;</code> to whatever filename you&#39;ve locally saved the file as.)</p><p>As only the Fe atoms are spinful, the second line here is selecting out just them. However, the <a href="../library/#FastDipole.Symmetry.subcrystal"><code>subcrystal</code></a> function critically retains information about the symmetry of the crystal structure with the I atoms present, which is important for symmetry-constraining allowed interactions between sites.</p><p><strong>(2)</strong> We proceed to define our Hamiltonian similarly as before, however this time many more interactions are present. See the documentation on the <a href="../library/#Interactions">Interactions</a> for extended descriptions of each.</p><pre><code class="language-julia hljs">
# All units in meV
J1mat = [-0.397  0      0    ;
          0     -0.075 -0.261;
          0     -0.261 -0.236]
J1 = GeneralCoupling(J1mat, cryst, Bond{3}(1, 1, [1, 0, 0]), &quot;J1&quot;)
J2 = DiagonalCoupling([0.026, 0.026, 0.113], cryst, Bond{3}(1, 1, [1, -1, 0]), &quot;J2&quot;)
J3 = DiagonalCoupling([0.166, 0.166, 0.211], cryst, Bond{3}(1, 1, [2, 0, 0]), &quot;J3&quot;)
J0′ = DiagonalCoupling([0.037, 0.037, -0.036], cryst, Bond{3}(1, 1, [0, 0, 1]), &quot;J0′&quot;)
J1′ = DiagonalCoupling([0.013, 0.013, 0.051], cryst, Bond{3}(1, 1, [1, 0, 1]), &quot;J1′&quot;)
J2a′ = DiagonalCoupling([0.068, 0.068, 0.073], cryst, Bond{3}(1, 1, [1, -1, 1]), &quot;J2a′&quot;)

D = OnSite([0.0, 0.0, -2.165/2], &quot;D&quot;)

ℋ = Hamiltonian{3}([J1, J2, J3, J0′, J1′, J2a′, D])</code></pre><p>Using our <code>Crystal</code>, we also need to generate a <code>Lattice</code> of some size to run our simulation on. In this example, we&#39;ll work with a modestly large system of size <span>$16\times 20\times 4$</span> along the <span>$(a, b, c)$</span> axes. We choose to make the <span>$a$</span> and <span>$b$</span> lengths different to artifically break a sixfold symmetry present in the system to help the Monte Carlo find the correct ground state later on.</p><pre><code class="language-julia hljs">lattice = Lattice(cryst, (16, 20, 4))</code></pre><p>To get better insight into the geometry and the long set of pair interactions we&#39;ve defined above, we can take a look at both using the following plotting function (you may want to replace <code>lattice</code> with something smaller, say <span>$5 \times 5 \times 3$</span> to make the bonds easier to see, or adjust <code>markersize</code> to make the atoms easier to see):</p><pre><code class="language-julia hljs">plot_bonds(lattice, ℋ; markersize=500)</code></pre><p><strong>(3)</strong> As with the previous example, the next step is to make a <code>SpinSystem</code> and randomize it:</p><pre><code class="language-julia hljs">system = SpinSystem(lattice, ℋ)
rand!(system)</code></pre><p><strong>(4)</strong> In this example, we&#39;ll choose to work with Metropolis Monte Carlo rather than Langevin sampling. This is necessary in this system due to a very strong on-site anisotropy (the <code>OnSite</code> term) making the spins nearly Ising-like. Continuous Langevin dyanmics can have ergodicity issues in these situations, so we have to turn back to the standard Metropolis randomized spin flip proposals.</p><pre><code class="language-julia hljs">kB = 8.61733e-2  # Boltzmann constant, units of meV/K
kT = 1.0 * kB    # Target simulation temp, in units of meV

sampler = MetropolisSampler(system, kT, 1000)</code></pre><p><code>MetropolisSampler</code> provides a very similar interface to <code>LangevinSampler</code>. Calling <code>sample!(sampler)</code> will perform some number of spin-flip proposals, then return with <code>system</code> updated to a new set of spin values. The <code>1000</code> in our constructor is asking the sampler to perform 1000 sweeps through the system before the <code>sample!</code> function should return.</p><p><strong>(5)</strong> As in the previous example, we are going to end with computing a dynamic structure factor tensor using the <code>structure_factor</code> function. A heuristic for choosing a reasonable value of <code>Δt</code> using in the Landau-Lifshitz dynamics is <code>0.01</code> divided by the largest energy scale present in the system. Here, that is the on-site anisotropy with a strength of <code>2.165/2</code> meV.</p><p>To make sure we don&#39;t do more work than really necessary, we set how often <code>structure_factor</code> internally stores snapshots (<code>meas_rate</code>) to target a maximum frequency of <code>target_max_ω</code>. We also will only collect the structure factor along two Brillouin zones along the first reciprocal axis, by passing <code>bz_size=(2,0,0)</code></p><p>The following block of code takes about five minutes on a test desktop, but if it&#39;s taking too long you can reduce the time either by reducing the number of sweeps <code>MetropolisSampler</code> does, or the <code>num_samples</code> or <code>num_freqs</code> in the structure factor computation.</p><pre><code class="language-julia hljs">Δt = 0.01 / (2.165/2)       # Units of 1/meV
# Highest energy/frequency we actually care about resolving
target_max_ω = 10.          # Units of meV
# Interval number of steps of dynamics before collecting a snapshot for FFTs
meas_rate = convert(Int, div(2π, (2 * target_max_ω * Δt)))

sampler = MetropolisSampler(system, kT, 500)
println(&quot;Starting structure factor measurement...&quot;)
S = structure_factor(
    system, sampler; num_samples=15, meas_rate=meas_rate,
    num_freqs=1000, bz_size=(2,0,0), verbose=true, therm_samples=15
)</code></pre><p>Given the full complex-valued <span>$\mathcal{S}^{\alpha \beta}(\boldsymbol{q}, \omega)$</span>, we can reduce it to the real-value experimentally-observable cross section by projection each <code>\mathcal{S}^{\alpha \beta}</code> using the neutron dipole factor. See the <a href="../library/#FastDipole.dipole_factor"><code>dipole_factor</code></a> documentation for more details. (To be truly comparable to experiment, a few more steps of processing need to be done which are currently unimplemented.)</p><pre><code class="language-julia hljs">S = dipole_factor(S, lattice)</code></pre><p>(Will add info here about plotting when better structure factor plotting functions are implemented.)</p><p>In the following example, we&#39;ll take a closer look at how to make some more manual measurements of the system.</p><h2 id="Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation"><a class="docs-heading-anchor" href="#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation">Example 3: Making manual measurements within a Monte Carlo simulation</a><a id="Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation" title="Permalink"></a></h2><p>In this example, we will perform an extended Monte Carlo simulation of the same system as in the previous example, but will perform a careful thermal annealing down to low temperatures and measure an <span>$E(T)$</span> curve along the way. To do so, we will need to use the sampling tools a bit more manually.</p><p>As we&#39;re using the same system as before, the setup will be identical. The lines are copied below for convenience, but see the previous example for an explanation of each step.</p><pre><code class="language-julia hljs">cryst = Crystal(&quot;./FeI2.cif&quot;)
cryst = subcrystal(cryst, &quot;Fe2+&quot;)

# All units in meV
J1mat = [-0.397  0      0    ;
          0     -0.075 -0.261;
          0     -0.261 -0.236]
J1 = GeneralCoupling(J1mat, cryst, Bond{3}(1, 1, [1, 0, 0]), &quot;J1&quot;)
J2 = DiagonalCoupling([0.026, 0.026, 0.113], cryst, Bond{3}(1, 1, [1, -1, 0]), &quot;J2&quot;)
J3 = DiagonalCoupling([0.166, 0.166, 0.211], cryst, Bond{3}(1, 1, [2, 0, 0]), &quot;J3&quot;)
J0′ = DiagonalCoupling([0.037, 0.037, -0.036], cryst, Bond{3}(1, 1, [0, 0, 1]), &quot;J0′&quot;)
J1′ = DiagonalCoupling([0.013, 0.013, 0.051], cryst, Bond{3}(1, 1, [1, 0, 1]), &quot;J1′&quot;)
J2a′ = DiagonalCoupling([0.068, 0.068, 0.073], cryst, Bond{3}(1, 1, [1, -1, 1]), &quot;J2a′&quot;)

D = OnSite([0.0, 0.0, -2.165/2], &quot;D&quot;)

ℋ = Hamiltonian{3}([J1, J2, J3, J0′, J1′, J2a′, D])

lattice = Lattice(cryst, (16, 20, 4))

system = SpinSystem(lattice, ℋ)
rand!(system)

sampler = MetropolisSampler(system, 1.0, 10)</code></pre><p>Now, our goal in the following is to measure an entire <span>$E(T)$</span> curve, down to relatively low temperatures. To help the system find the ground state correctly at low temperatures, we will use the same system throughout and slowly &quot;anneal&quot; the temperature from the highest value down to the lowest.</p><p>These next few lines are pure Julia which simply sets up the temperatures we want to measure along, and initializes some <code>Vector</code>&#39;s to store some data during the simulations.</p><pre><code class="language-julia hljs">kB = 8.61733e-2             # Boltzmann constant, units of meV/K

# Units of Kelvin, matching Xiaojian&#39;s range
temps = 10 .^ (range(log10(50), stop=0, length=50))
temps_meV = kB .* temps
energies = Float64[]
energy_errors = Float64[]</code></pre><p>We&#39;ve chosen to measure along a logarithmic temperature grid spanning <span>$T \in [1, 50]$</span>, so that we pack the grid points tighter at lower temperatures where interesting things occur. <code>energies</code> and <code>energy_errors</code> are going to hold our measurements  of the mean energy and the errors at each temperature.</p><p>Now, we&#39;re going to loop over these temperatures (moving from higher to lower temperatures). At each temperature, we&#39;re going to:</p><ol><li>Set the temperature of the sampler to the new temperature using <code>set_temp!</code>.</li><li>Thermalize at the new temperature for a while before collecting  measurements using <code>thermalize!</code>.</li><li>Sample the system 1000 times, and measure the energy of each spin  configuration. We&#39;ll record all of these energies in <code>temp_energies</code>.</li><li>Compute the mean energy and its standard error from our 1000 measurements</li><li>Push this mean energy and standard error to our <code>energies</code> and   <code>energy_errors</code> vectors.</li></ol><p>For simplicity, here we&#39;re just going to use the standard error across all energy measurements as the error. See the <code>binned_statistics</code> function in <code>examples/reproduce_testcases.jl</code> to see how to measure the error more carefully.</p><p>The following block of code takes a few minutes to execute. Feel free to sample a sparser temperature grid, play around with some of the thermalization parameters, or perform fewer measurements to try to get it to execute faster.</p><pre><code class="language-julia hljs">using Statistics

for (i, temp) in enumerate(temps_meV)
    println(&quot;Temperature $i = $(temp)&quot;)

    temp_energies = Float64[]
    set_temp!(sampler, temp)
    thermalize!(sampler, 100)
    for _ in 1:1000
        sample!(sampler) 
        push!(temp_energies, energy(sampler))
    end
    meanE = mean(temp_energies)
    errE  = std(temp_energies) / sqrt(length(temp_energies))
    push!(energies, meanE)
    push!(energy_errors, errE)
end

# Convert energies into energy / spin, in units of K
energies ./= (length(system) * kB)
energy_errors ./= (length(system) * kB)</code></pre><p>Now, we can plot what we&#39;ve gotten! If you have the Plots.jl library installed you can do this as:</p><pre><code class="language-julia hljs">using Plots

p = plot(temps, energies, yerror=energy_errors, marker=:true, ms=3, label=&quot;Monte Carlo Results&quot;)
xlabel!(L&quot;$T$ [K]&quot;)
ylabel!(L&quot;$E$ [K]&quot;)
p</code></pre><p>If all has gone well, you should get a plot that looks something like the following:</p><p><img src="../assets/FeI2_ETcurve.png" alt="FeI₂ Energy Curve"/></p><p>We can take a look at the final low-energy spin configuration by:</p><pre><code class="language-julia hljs">plot_spins(system; arrowsize=1.5, arrowlength=3, linewidth=0.5)</code></pre><p>You should see antiferromagnetic stripes within each <span>$c$</span>-plane, which shift by one lattice site as you move up each plane!</p><h2 id="Symmetry-analysis"><a class="docs-heading-anchor" href="#Symmetry-analysis">Symmetry analysis</a><a id="Symmetry-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-analysis" title="Permalink"></a></h2><p>When defining pair interactions, we are always defining the interactions on entire symmetry classes at the same time. To do this, we need to provide the exchange matrix <span>$J$</span> on a specific reference <code>Bond</code>, which is then automatically propagated to all symmetry-equivalent bonds. However, on any given bond, the exchange matrix must live within a restricted space of <span>$3 \times 3$</span> matrices that is confined by the symmetry properties of the underlying crystal.</p><p>To discover all symmetry classes of bonds up to a certain distance while simultaneously learning what the allowed form of the <code>J</code> matrix is, construct a <code>Crystal</code> then call the function <a href="../library/#FastDipole.Symmetry.print_bond_table"><code>print_bond_table</code></a>.</p><pre><code class="nohighlight hljs">julia&gt; lattice = FastDipole.diamond_conventional(1.0, (8, 8, 8))
julia&gt; crystal = Crystal(lattice)
julia&gt; print_bond_table(crystal, 4.0)

Bond{3}(1, 1, [0, 0, 0])
Distance 0, multiplicity 1
Connects [0, 0, 0] to [0, 0, 0]
Allowed coupling:  |A 0 0 |
                   |0 A 0 |
                   |0 0 A |

Bond{3}(3, 6, [0, 0, 0])
Distance 1.732, multiplicity 4
Connects [0.5, 0, 0.5] to [0.75, 0.25, 0.25]
Allowed coupling:  | A  B -B |
                   | B  A -B |
                   |-B -B  A |

Bond{3}(1, 2, [0, 0, 0])
Distance 2.828, multiplicity 12
Connects [0, 0, 0] to [0, 0.5, 0.5]
Allowed coupling:  | B  D  D |
                   |-D  C  A |
                   |-D  A  C |

Bond{3}(1, 6, [0, 0, 0])
Distance 3.317, multiplicity 12
Connects [0, 0, 0] to [0.75, 0.25, 0.25]
Allowed coupling:  |B C C |
                   |C D A |
                   |C A D |

Bond{3}(1, 1, [1, 0, 0])
Distance 4, multiplicity 6
Connects [0, 0, 0] to [1, 0, 0]
Allowed coupling:  |A 0 0 |
                   |0 B 0 |
                   |0 0 B |</code></pre><p>Each block represents one symmetry equivalence class of bonds, along with a single representative (&quot;canonical&quot;) <code>Bond</code> for that class and the allowed exchange coupling matrix on that canonical bond.</p><p>You can also query what the allowed exchange matrix is on a specific bond using <a href="../library/#FastDipole.Symmetry.allowed_J"><code>allowed_J</code></a>.</p><pre><code class="nohighlight hljs">julia&gt; allowed_J(crystal, Bond{3}(1, 5, [1,-1,0]))

3×3 Matrix{String}:
 &quot;D&quot;  &quot;A&quot;  &quot;B&quot;
 &quot;A&quot;  &quot;E&quot;  &quot;C&quot;
 &quot;B&quot;  &quot;C&quot;  &quot;F&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Monday 11 October 2021 09:36">Monday 11 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
