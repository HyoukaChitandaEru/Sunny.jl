<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SU(N) Spin Simulations</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SU(N) Spin Simulations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SU(N) Spin Simulations</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Sunny.jl</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions"><span>Example 1: Diamond lattice with antiferromagnetic Heisenberg interactions</span></a></li><li><a class="tocitem" href="#Example-2:-FeI-with-a-complex-collection-of-interactions"><span>Example 2: FeI₂ with a complex collection of interactions</span></a></li><li><a class="tocitem" href="#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation"><span>Example 3: Making manual measurements within a Monte Carlo simulation</span></a></li><li><a class="tocitem" href="#Symmetry-analysis"><span>Symmetry analysis</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li><li><a class="tocitem" href="../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>The examples in this document are available in <code>examples/</code> as full loadable files containing executable functions. Specifically, we work through here the simulations performed in <code>examples/reproduce_testcases.jl</code>. The plotting functions make use of <a href="http://docs.juliaplots.org/latest/">Plots.jl</a> and <a href="https://makie.juliaplots.org/stable/">Makie.jl</a>, which you should install from Julia.</p><p>The high-level outline of performing a simulation is:</p><ol><li>Create a <a href="../library/#Sunny.Crystal"><code>Crystal</code></a>, either by providing explicit geometry information  (Example 1), or by loading a <code>.cif</code> file (Example 2).</li><li>Using the <code>Crystal</code>, construct a collection of <a href="../library/#Interactions">Interactions</a>.</li><li>Assemble a <a href="../library/#Sunny.SpinSystem"><code>SpinSystem</code></a> using the newly created <code>Crystal</code> and interactions, the size of the simulation box, and optionally information on the spin magnitude and <span>$g$</span>-tensors of each site by passing a list of <code>SiteInfo</code>.</li><li>Construct a sampler, either a <a href="../library/#Sunny.LangevinSampler-Tuple{SpinSystem, Float64, Float64, Float64, Int64}"><code>LangevinSampler</code></a> (Example 1), or a   <a href="../library/#Sunny.MetropolisSampler"><code>MetropolisSampler</code></a> (Example 2).</li><li>Use the sampler directly to sample new states, or use it to perform <a href="../library/#Structure-factor-calculations">Structure factor calculations</a>.</li></ol><p>Defining interactions in step (2) can be aided by our utilities for symmetry analysis, demonstrated at the bottom of this page.</p><p>In all examples, we will assume that <code>Sunny</code> and <code>LinearAlgebra</code> have been loaded:</p><pre><code class="language-julia hljs">using Sunny
using LinearAlgebra</code></pre><h2 id="Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions"><a class="docs-heading-anchor" href="#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions">Example 1: Diamond lattice with antiferromagnetic Heisenberg interactions</a><a id="Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions" title="Permalink"></a></h2><p>In this example, we will step through the basic steps needed to set up and run a spin dynamics simulation, with finite-<span>$T$</span> statistics obtained by using Langevin dynamics. The full example is contained in the function <code>test_diamond_heisenberg_sf()</code> within <code>examples/reproduce_testcases.jl</code>.</p><h4 id="**(1)**"><a class="docs-heading-anchor" href="#**(1)**"><strong>(1)</strong></a><a id="**(1)**-1"></a><a class="docs-heading-anchor-permalink" href="#**(1)**" title="Permalink"></a></h4><p>We construct a diamond crystal by explicitly defining the eight atom positions in the conventional cubic unit cell,</p><pre><code class="language-julia hljs">a = 1.0     # Length in angstrom
lat_vecs = lattice_vectors(a, a, a, 90, 90, 90)
basis_vecs = [
    [0, 0, 0]/4,
    [2, 2, 0]/4,
    [1, 1, 1]/4,
    [3, 3, 1]/4,
    [2, 0, 2]/4,
    [0, 2, 2]/4,
    [3, 1, 3]/4,
    [1, 3, 3]/4,
]
crystal = Crystal(lat_vecs, basis_vecs)</code></pre><p>The terminal will display information about the automatically-inferred symmetry information for the cell.</p><p>One can optionally enter atom types, which affects the inferred spacegroup. For example, <code>Crystal(lat_vecs, basis_vecs; types=[&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;])</code> would produce a crystal with reduced symmetry.</p><p>A more concise way to create the diamond crystal is using the space group number, which automatically fills in all symmetry equivalent positions,</p><pre><code class="language-julia hljs">crystal = Crystal(lat_vecs, [[0, 0, 0]], 227; setting=&quot;1&quot;)</code></pre><p>For spacegroup 227 (symbol &quot;F d -3 m&quot;), there are two possible conventions for the unit cell origin. Leaving off the <code>setting</code> option returns all possible crystals. <strong>Note</strong>: If you provide the full list of basis sites, their ordering in the crystal will not be changed. Meanwhile, any constructor of <code>Crystal</code> which infers sites through symmetry information will sort the basis sites deterministically during construction. Be aware of this, and always check the orderings of basis sites in your final <code>Crystal</code> when performing the next step.</p><h4 id="**(2)**"><a class="docs-heading-anchor" href="#**(2)**"><strong>(2)</strong></a><a id="**(2)**-1"></a><a class="docs-heading-anchor-permalink" href="#**(2)**" title="Permalink"></a></h4><p>Next, we need to define our Hamiltonian, which for this example will just contain Heisenberg interactions. Specifically, we want to set up nearest-neighbor antiferromagnetic interactions with a strength of <span>$J = 7.5413~\mathrm{K}$</span>.</p><p>A powerful feature of Sunny is its ability to perform automated symmetry analysis. In general, specifying information on any site/bond will automatically propagate that information to all symmetry-equivalent sites/bonds. In this system, all nearest-neighbor bonds are symmetry-equivalent, so we only need to specify the interaction on a single one of them. One nearest-neighbor bond is the one connecting basis index 1 with basis index 3 within a single unit cell. (We can figure this out using our tools for symmetry analysis, at the bottom of this page).</p><p><strong>Note</strong>: By default, Sunny assumes the following units: energy in millielectronvolts (meV), field in tesla (T), and distance in angstrom (Å). Time is measured in 1/meV, such that <span>$ħ = 1$</span>. Temperatures are always provided to all components of Sunny as <span>$k_B T$</span>, in units of meV. For convenience, the  meV<em>per</em>K constant <span>$k_B$</span> in units of meV/K can be accessed as <code>Sunny.meV_per_K</code>. <strong>It becomes necessary to conform to this unit system when a Zeeman or dipole-dipole interaction term is included in the Hamiltonian</strong>. For more information, see <a href="../internals/#Internals">Internals</a>.</p><p>[comment] # Seems like the recommended place to look to explain the unit system should not be Internals – the idea is that Internals is only for people who want to hack/develop on Sunny.</p><p>So, we can create a nearest-neighbor Heisenberg interaction just by specifying:</p><pre><code class="language-julia hljs">J = Sunny.meV_per_K * 7.5413    # Energy in meV
interactions = [
    heisenberg(J, Bond(1, 3, [0,0,0])),
]</code></pre><h4 id="**(3)**"><a class="docs-heading-anchor" href="#**(3)**"><strong>(3)</strong></a><a id="**(3)**-1"></a><a class="docs-heading-anchor-permalink" href="#**(3)**" title="Permalink"></a></h4><p>To assemble a <code>SpinSystem</code>, we must provide the <code>Crystal</code>, the interaction list, the dimensions of the simulation box (in units of the lattice vectors) and some information about each site,</p><pre><code class="language-julia hljs">dims = (8, 8, 8)
site_info = [SiteInfo(1, 3/2)]
sys = SpinSystem(crystal, interactions, dims, site_info)
rand!(sys)</code></pre><p>The <code>site_info</code> parameter is optional. If provided, then it may contain at most one <code>SiteInfo</code> struct per site equivalence class. In the case of diamond, all 8 sites in the unit cell are symmetry-equivalent. Generally, <code>SiteInfo(i, S)</code>, specifies that site <code>i</code> and its symmetry equivalent sites each carry a spin with angular momentum <span>$S$</span> (in units of ħ). One can also provide a <span>$g$</span>-factor or <span>$g$</span>-tensor using <code>SiteInfo(i, S, g)</code>. A <span>$g$</span>-tensor will be covariantly propagated by symmetry. If not specified, then by default, <code>S=1/2</code> and <code>g=2</code>.</p><p>The final line, <code>rand!(sys)</code>, samples each spin randomly, subject to the normalization constraint.</p><p>The <code>SpinSystem</code> type is the central type used throughout our simulations. Internally, it contains the spin degrees of freedom which evolve during the simulation as well as the Hamiltonian defining how this evolution should occur. This type can be indexed into as an array of size <code>B×Lx×Ly×Lz</code>, with the first index selecting the sublattice and the remaining three selecting the unit cell, and the spin located at the  will given. For example, <code>sys[2, 5, 5, 5]</code> gives the spin variable located on the second sublattice in the unit cell, which is fifth along each axis.</p><p>Note that regardless of the spin magnitudes you specify on each site, indexing <code>sys</code> will always return a normalized unit vector.</p><h4 id="**(4)**"><a class="docs-heading-anchor" href="#**(4)**"><strong>(4)</strong></a><a id="**(4)**-1"></a><a class="docs-heading-anchor-permalink" href="#**(4)**" title="Permalink"></a></h4><p>We will simulate this system using Langevin dynamics, so we need to create a <a href="../library/#Sunny.LangevinSampler-Tuple{SpinSystem, Float64, Float64, Float64, Int64}"><code>LangevinSampler</code></a>. Note that the units of integration time are relative to the units implicitly used when setting up the interactions. A rough rule of hand is that a reasonable value for integration timestep size is <span>$Δt ≈ 0.02 / (S^2 * J)$</span>. The temperature for the sampler must be provided as <span>$k_B T$</span> in units of meV.</p><pre><code class="language-julia hljs">Δt = 0.02 / (S^2 * J)     # Units of 1/meV
kT = Sunny.meV_per_K * 4. # 4 kelvin, in units of meV
α  = 0.1
nsteps = 20_000
sampler = LangevinSampler(sys, kT, α, Δt, nsteps)</code></pre><p>At this point we can call <code>sample!(sampler)</code> to produce new samples of the system, which will be reflected in the state of <code>sys</code>. Instead, we will proceed to calculate the finite-<span>$T$</span> structure factor using our built-in routines.</p><h4 id="**(5)**"><a class="docs-heading-anchor" href="#**(5)**"><strong>(5)</strong></a><a id="**(5)**-1"></a><a class="docs-heading-anchor-permalink" href="#**(5)**" title="Permalink"></a></h4><p>The full process of calculating a structure factor is handled by <a href="../library/#Sunny.dynamic_structure_factor"><code>dynamic_structure_factor</code></a>. Internally, this function:</p><ol><li>Thermalizes the system for a while</li><li>Samples a new thermal spin configuration</li><li>Performs constant-energy LL dynamics to obtain a Fourier-transformed  dynamics trajectory. Use this trajectory to calculate a structure  factor contribution <span>$S^{α,β}(𝐪, ω)$</span>.</li><li>Repeat steps (2,3), averaging structure factors across samples.</li></ol><p>See the documentation of <a href="../library/#Sunny.dynamic_structure_factor"><code>dynamic_structure_factor</code></a> for details of how this process is controlled by the function arguments, and how to properly index into the resulting type <a href="../library/#Sunny.StructureFactor"><code>StructureFactor</code></a>. Currently, the main way to interact with this type is to index into its <code>sfactor</code> attribute, which is a large array storing <span>$S^{α,β}(𝐪, ω)$</span> on a grid of <span>$𝐪$</span> points and frequencies.</p><p>In this example, we will just look at the diagonal elements of this matrix along some cuts in reciprocal space. To improve statistics, we average these elements across the <span>$x, y, z$</span> spin directions since they are all symmetry equivalent in this model.</p><pre><code class="language-julia hljs">meas_rate = 40     # Number of timesteps between snapshots of LLD to input to FFT
                   # The maximum frequency we resolve is set by 2π/(meas_rate * Δt)
dyn_meas = 400     # Total number of frequencies we&#39;d like to resolve
dynsf = dynamic_structure_factor(
    sys, sampler; nsamples=10, dynΔt=Δt, meas_rate=meas_rate,
    dyn_meas=dyn_meas, bz_size=(1,1,2), thermalize=10, verbose=true,
    reduce_basis=true, dipole_factor=false,
)

# Retain just the diagonal elements, which we will average across the
#  symmetry-equivalent directions.
sfactor = dynsf.sfactor
avg_sfactor = zeros(Float64, axes(sfactor)[3:end])
for α in 1:3
    @. avg_sfactor += real(sfactor[α, α, :, :, :, :])
end</code></pre><p>We then plot some cuts using a function <code>plot_many_cuts_afmdiamond</code> defined within the example script. (I.e. this code block will not successfully execute unless you <code>include(&quot;examples/reproduce_testcases.jl)</code>). We omit this code here as it&#39;s just a large amount of indexing and plotting code which depends on some external packages, but for details see the script.</p><pre><code class="language-julia hljs"># Calculate the maximum ω present in our FFT. Since the time gap between
#  our snapshots is meas_rate * Δt, the maximum frequency we resolve
#  is 2π / (meas_rate * Δt)
# This is implicitly in the same units as the units you use to define
#  the interactions in the Hamiltonian. Since by default interactions
#  are specified in meV, the frequencies will also be in units of meV.
maxω = 2π / (meas_rate * Δt)
p = plot_many_cuts_afmdiamond(avg_sfactor, J, 3/2; maxω=maxω, chopω=5.0)
display(p)</code></pre><h2 id="Example-2:-FeI-with-a-complex-collection-of-interactions"><a class="docs-heading-anchor" href="#Example-2:-FeI-with-a-complex-collection-of-interactions">Example 2: FeI₂ with a complex collection of interactions</a><a id="Example-2:-FeI-with-a-complex-collection-of-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-FeI-with-a-complex-collection-of-interactions" title="Permalink"></a></h2><p>In this example, we work through performing a more complicated and realistic simulation of FeI₂. While the number of interactions is much larger, the general process will be remarkably similar. We will also see how to perform sampling using Metropolis Monte Carlo through the <a href="../library/#Sunny.MetropolisSampler"><code>MetropolisSampler</code></a> type. The full example is contained in the function <code>test_FeI2_MC()</code> within <code>examples/reproduce_testcases.jl</code>.</p><p><strong>(1)</strong> As before, the first step is to make a <a href="../library/#Sunny.Crystal"><code>Crystal</code></a>. However, this time we will load the crystal directly from a common crystallographic file format called a <code>.cif</code>. You can download the structure file from <a href="https://materials.springer.com/isp/crystallographic/docs/sd_0548497">this link</a>. Then, we can load it as:</p><pre><code class="language-julia hljs">crystal = Crystal(&quot;./FeI2.cif&quot;)
crystal = subcrystal(crystal, &quot;Fe2+&quot;)</code></pre><p>(Be sure to change <code>&quot;./FeI2.cif&quot;</code> to whatever filename you&#39;ve locally saved the file as.)</p><p>As only the Fe atoms are spinful, the second line here is selecting out just them. However, the <a href="../library/#Sunny.subcrystal"><code>subcrystal</code></a> function critically retains information about the symmetry of the crystal structure with the I atoms present, which is important for symmetry-constraining allowed interactions between atoms.</p><p><strong>(2)</strong> We proceed to define our Hamiltonian similarly as before, however this time many more interactions are present. See the documentation on the <a href="../library/#Interactions">Interactions</a> for extended descriptions of each. Note that the <code>diagm</code> function from the <code>LinearAlgebra</code> package just makes a diagonal matrix from the vector giving the diagonal.</p><pre><code class="language-julia hljs"># All units in meV
J1mat = [-0.397  0      0    
          0     -0.075 -0.261
          0     -0.261 -0.236]
J1 = exchange(J1mat, Bond(1, 1, [1, 0, 0]), &quot;J1&quot;)
J2 = exchange(diagm([0.026, 0.026, 0.113]), Bond(1, 1, [1, -1, 0]), &quot;J2&quot;)
J3 = exchange(diagm([0.166, 0.166, 0.211]), Bond(1, 1, [2, 0, 0]), &quot;J3&quot;)
J0′ = exchange(diagm([0.037, 0.037, -0.036]), Bond(1, 1, [0, 0, 1]), &quot;J0′&quot;)
J1′ = exchange(diagm([0.013, 0.013, 0.051]), Bond(1, 1, [1, 0, 1]), &quot;J1′&quot;)
J2a′ = exchange(diagm([0.068, 0.068, 0.073]), Bond(1, 1, [1, -1, 1]), &quot;J2a′&quot;)

D = easy_axis(2.165/2, [0, 0, 1], 1, &quot;D&quot;)
interactions = [J1, J2, J3, J0′, J1′, J2a′, D]</code></pre><p>To get better insight into the geometry and the long set of pair interactions we&#39;ve defined above, we can take a look at both using the following plotting function: (you may want to adjust <code>markersize</code> to make the atoms easier to see):</p><pre><code class="language-julia hljs">using GLMakie
plot_bonds(crystal, interactions, (4,4,4); markersize=500)</code></pre><p>Note that the Sunny plotting functions won&#39;t be available until you execute <code>using GLMakie</code>. Also keep in mind that GLMakie can be slow to load; it may take a minute or more to bring up the first plot. Subsequent plots should be significantly faster.</p><p><strong>(3)</strong> As with the previous example, the next step is to make a <code>SpinSystem</code> and randomize it. We&#39;ll simulate a fairly large box of size <span>$16\times 20\times 4$</span>.</p><pre><code class="language-julia hljs">system = SpinSystem(crystal, interactions, (16, 20, 4), [SiteInfo(1, 1.0)])
rand!(system)</code></pre><p>Note that each Fe site has spin magnitude <span>$S=1$</span>.</p><p><strong>(4)</strong> In this example, we&#39;ll choose to work with Metropolis Monte Carlo rather than Langevin sampling. This is necessary in this system due to a very strong single-ion anisotropy (the <code>easy_axis</code> term) making the spins nearly Ising-like. Continuous Langevin dyanmics can have ergodicity issues in these situations, so we have to turn back to the standard Metropolis randomized spin flip proposals.</p><pre><code class="language-julia hljs">kT = 1.0 * Sunny.meV_per_K    # Target simulation temp, in units of meV
sampler = MetropolisSampler(system, kT, 1000)</code></pre><p><code>MetropolisSampler</code> provides a very similar interface to <code>LangevinSampler</code>. Calling <code>sample!(sampler)</code> will perform some number of spin-flip proposals, then return with <code>system</code> updated to a new set of spin values. The <code>1000</code> in our constructor is asking the sampler to perform 1000 sweeps through the system before the <code>sample!</code> function should return.</p><p><strong>(5)</strong> As in the previous example, we are going to end with computing a dynamic structure factor tensor using the <code>dynamic_structure_factor</code> function. A heuristic for choosing a reasonable value of <code>Δt</code> using in the Landau-Lifshitz dynamics is <code>0.01</code> divided by the largest energy scale present in the system. Here, that is the single-ion anisotropy with a strength of <code>2.165/2</code> meV.</p><p>To make sure we don&#39;t do more work than really necessary, we set how often <code>dynamic_structure_factor</code> internally stores snapshots (<code>meas_rate</code>) to target a maximum frequency of <code>target_max_ω</code>. We also will only collect the structure factor along two Brillouin zones along the first reciprocal axis, by passing <code>bz_size=(2,0,0)</code></p><p>The following block of code takes about five minutes on a test desktop, but if it&#39;s taking too long you can reduce the time either by reducing the number of sweeps <code>MetropolisSampler</code> does, or the <code>num_samples</code> or <code>num_meas</code> in the structure factor computation.</p><pre><code class="language-julia hljs">Δt = 0.01 / (2.165/2)       # Units of 1/meV
# Highest energy/frequency we actually care about resolving
target_max_ω = 10.          # Units of meV
# Interval number of steps of dynamics before collecting a snapshot for FFTs
meas_rate = convert(Int, div(2π, (2 * target_max_ω * Δt)))

sampler = MetropolisSampler(system, kT, 500)
println(&quot;Starting structure factor measurement...&quot;)
dynsf = dynamic_structure_factor(
    system, sampler; nsamples=15, thermalize=15,
    bz_size=(2,0,0), reduce_basis=true, dipole_factor=true,
    dynΔt=Δt, meas_rate=meas_rate, dyn_meas=1000, verbose=true, 
)</code></pre><p>Here, given the full complex-valued <span>$\mathcal{S}^{\alpha \beta}(\boldsymbol{q}, \omega)$</span>, we are asking with <code>dipole_factor=true</code> to have this reduced to a single real-value  by projecting each <code>\mathcal{S}^{\alpha \beta}</code> using the neutron dipole factor. (See <a href="../library/#Structure-factor-calculations">Structure factor calculations</a>. To be truly comparable to experiment, a few more steps of processing need to be done which are currently unimplemented.)</p><p>(Will add info here about plotting when better structure factor plotting functions are implemented.)</p><p>In the following example, we&#39;ll take a closer look at how to make some more manual measurements of the system.</p><h2 id="Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation"><a class="docs-heading-anchor" href="#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation">Example 3: Making manual measurements within a Monte Carlo simulation</a><a id="Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation" title="Permalink"></a></h2><p>In this example, we will perform an extended Monte Carlo simulation of the same system as in the previous example, but will perform a careful thermal annealing down to low temperatures and measure an <span>$E(T)$</span> curve along the way. To do so, we will need to use the sampling tools a bit more manually.</p><p>As we&#39;re using the same system as before, the setup will be identical. The lines are copied below for convenience, but see the previous example for an explanation of each step.</p><pre><code class="language-julia hljs">crystal = Crystal(&quot;./FeI2.cif&quot;)
crystal = subcrystal(crystal, &quot;Fe2+&quot;)

# All units in meV
J1mat = [-0.397  0      0    
          0     -0.075 -0.261
          0     -0.261 -0.236]
J1 = exchange(J1mat, Bond(1, 1, [1, 0, 0]), &quot;J1&quot;)
J2 = exchange(diagm([0.026, 0.026, 0.113]), Bond(1, 1, [1, -1, 0]), &quot;J2&quot;)
J3 = exchange(diagm([0.166, 0.166, 0.211]), Bond(1, 1, [2, 0, 0]), &quot;J3&quot;)
J0′ = exchange(diagm([0.037, 0.037, -0.036]), Bond(1, 1, [0, 0, 1]), &quot;J0′&quot;)
J1′ = exchange(diagm([0.013, 0.013, 0.051]), Bond(1, 1, [1, 0, 1]), &quot;J1′&quot;)
J2a′ = exchange(diagm([0.068, 0.068, 0.073]), Bond(1, 1, [1, -1, 1]), &quot;J2a′&quot;)

D = easy_axis(2.165/2, [0, 0, 1], 1, &quot;D&quot;)
interactions = [J1, J2, J3, J0′, J1′, J2a′, D]

system = SpinSystem(crystal, interactions, (16, 20, 4), [SiteInfo(1, 1.0)])
rand!(system)

sampler = MetropolisSampler(system, 1.0, 10)</code></pre><p>Now, our goal in the following is to measure an entire <span>$E(T)$</span> curve, down to relatively low temperatures. To help the system find the ground state correctly at low temperatures, we will use the same system throughout and slowly &quot;anneal&quot; the temperature from the highest value down to the lowest.</p><p>These next few lines are pure Julia which simply sets up the temperatures we want to measure along, and initializes some <code>Vector</code>&#39;s to store some data during the simulations.</p><pre><code class="language-julia hljs"># Temperature in units of Kelvin on a logarithmic grid spanning [1K, 50K]
temps = 10 .^ (range(log10(50), stop=0, length=50))
temps_meV = Sunny.meV_per_K .* temps
energies = Float64[]
energy_errors = Float64[]</code></pre><p>We&#39;ve chosen to measure along a logarithmic temperature grid spanning <span>$T \in [1, 50]$</span>, so that we pack the grid points tighter at lower temperatures where interesting things occur. <code>energies</code> and <code>energy_errors</code> are going to hold our measurements  of the mean energy and the errors at each temperature.</p><p>Now, we&#39;re going to loop over these temperatures (moving from higher to lower temperatures). At each temperature, we&#39;re going to:</p><ol><li>Set the temperature of the sampler to the new temperature using <code>set_temp!</code>.</li><li>Thermalize at the new temperature for a while before collecting  measurements using <code>thermalize!</code>.</li><li>Sample the system 1000 times, and measure the energy of each spin  configuration. We&#39;ll record all of these energies in <code>temp_energies</code>.</li><li>Compute the mean energy and its standard error from our 1000 measurements</li><li>Push this mean energy and standard error to our <code>energies</code> and   <code>energy_errors</code> vectors.</li></ol><p>For simplicity, here we&#39;re just going to use the standard error across all energy measurements as the error. See the <code>binned_statistics</code> function in <code>examples/reproduce_testcases.jl</code> to see how to measure the error more carefully.</p><p>The following block of code takes a few minutes to execute. Feel free to sample a sparser temperature grid, play around with some of the thermalization parameters, or perform fewer measurements to try to get it to execute faster.</p><p>Note the use of <code>running_energy(sampler)</code>. In some samplers, such as <code>MetropolisSampler</code>, it is very efficient to maintain the current system energy by updating with the local energy changes every time a spin flips. (In other samplers, such as <code>LangevinSampler</code>, this is not the case and <code>running_energy</code> simply does a full energy recalculation).</p><p>However, the &quot;running&quot; in running energy refers to the fact that if you hand-modify the <code>system</code>, this running tally may no longer be correct! You can restart the tally (by recomputing the full system energy from scratch) using <code>reset_energy!(sampler)</code>. Similar functions exist for the total magnetization (<code>running_mag(sampler)</code> and <code>reset_mag!(sampler)</code>).</p><pre><code class="language-julia hljs">using Statistics

for (i, temp) in enumerate(temps_meV)
    println(&quot;Temperature $i = $(temp)&quot;)

    temp_energies = Float64[]
    set_temp!(sampler, temp)
    thermalize!(sampler, 100)
    for _ in 1:1000
        sample!(sampler) 
        push!(temp_energies, running_energy(sampler))
    end
    meanE = mean(temp_energies)
    errE  = std(temp_energies) / sqrt(length(temp_energies))
    push!(energies, meanE)
    push!(energy_errors, errE)
end

# Convert energies into energy / spin, in units of K
energies ./= (length(system) * Sunny.meV_per_K)
energy_errors ./= (length(system) * Sunny.meV_per_K)</code></pre><p>Now, we can plot what we&#39;ve gotten! If you have the Plots.jl library installed you can do this as:</p><pre><code class="language-julia hljs">using Plots

p = plot(temps, energies, yerror=energy_errors, marker=:true, ms=3, label=&quot;Monte Carlo Results&quot;)
xlabel!(L&quot;$T$ [K]&quot;)
ylabel!(L&quot;$E$ [K]&quot;)
p</code></pre><p>If all has gone well, you should get a plot that looks something like the following:</p><p><img src="../assets/FeI2_ETcurve.png" alt="FeI₂ Energy Curve"/></p><p>We can take a look at the final low-energy spin configuration by:</p><pre><code class="language-julia hljs">using GLMakie
plot_spins(system; arrowsize=1.5, arrowlength=3, linewidth=0.5)</code></pre><p>You should see antiferromagnetic stripes within each <span>$c$</span>-plane, which shift by one as you move up each plane!</p><h2 id="Symmetry-analysis"><a class="docs-heading-anchor" href="#Symmetry-analysis">Symmetry analysis</a><a id="Symmetry-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-analysis" title="Permalink"></a></h2><p>When defining pair interactions, we are always defining the interactions on entire symmetry classes at the same time. To do this, we need to provide the exchange matrix <span>$J$</span> for a specific <code>Bond</code>, which is then automatically propagated to all symmetry-equivalent bonds. Any given bond has symmetry constraints that restrict the allowed space of <span>$3 \times 3$</span> coupling matrices.</p><p>To discover the symmetry allowed couplings for all bonds up to a certain distance, we can use the function <a href="../library/#Sunny.print_bond_table"><code>print_bond_table</code></a>.</p><pre><code class="nohighlight hljs">crystal = Sunny.diamond_crystal()
print_bond_table(crystal, 1.0)</code></pre><p>which prints</p><pre><code class="nohighlight hljs">Atom 1, position [0, 0, 0], multiplicity 8
Allowed single-ion anisotropy or g-tensor: | A  0  0 |
                                           | 0  A  0 |
                                           | 0  0  A |

Bond(1, 3, [0, 0, 0])
Distance 0.433, coordination 4
Connects [0, 0, 0] to [0.25, 0.25, 0.25]
Allowed exchange matrix: | A  B  B |
                         | B  A  B |
                         | B  B  A |

Bond(1, 2, [0, 0, 0])
Distance 0.7071, coordination 12
Connects [0, 0, 0] to [0.5, 0.5, 0]
Allowed exchange matrix: | A  C  D |
                         | C  A  D |
                         |-D -D  B |
Allowed DM vector: [D -D 0]

Bond(2, 7, [0, 0, 0])
Distance 0.8292, coordination 12
Connects [0.5, 0.5, 0] to [0.75, 0.25, 0.75]
Allowed exchange matrix: | A  D  C |
                         | D  A -C |
                         | C -C  B |

Bond(1, 1, [1, 0, 0])
Distance 1, coordination 6
Connects [0, 0, 0] to [1, 0, 0]
Allowed exchange matrix: | A  0  0 |
                         | 0  B  0 |
                         | 0  0  B |</code></pre><p>Each entry above makes reference to a specific <code>Bond</code>, but implicitly refers to an entire class of symmetry equivalent bonds. For example, there are 4 symmetry equivalent nearest neighbors in the diamond lattice (coordination number 4). To find the ones starting from atom 2 we can use <a href="../library/#Sunny.all_symmetry_related_bonds_for_atom"><code>all_symmetry_related_bonds_for_atom</code></a>,</p><pre><code class="nohighlight hljs">julia&gt; all_symmetry_related_bonds_for_atom(crystal, 2, Bond(2, 3, [0, 0, 0]))

4-element Vector{Bond}:
 Bond(2, 7, [0, 0, -1])
 Bond(2, 8, [0, 0, -1])
 Bond(2, 3, [0, 0, 0])
 Bond(2, 4, [0, 0, 0])</code></pre><p>You can query properties of a specific bond using <a href="../library/#Sunny.print_bond"><code>print_bond</code></a>.</p><pre><code class="nohighlight hljs">julia&gt; print_bond(crystal, Bond(1, 6, [1,-1,0]))

Bond(1, 6, [1, -1, 0])
Distance 1.225, coordination 24
Connects [0, 0, 0] to [1, -0.5, 0.5]
Allowed exchange matrix: |   A  D-E -D+E |
                         | D+E    B    C |
                         |-D-E    C    B |
Allowed DM vector: [0 -E -E]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 3 February 2022 18:03">Thursday 3 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
