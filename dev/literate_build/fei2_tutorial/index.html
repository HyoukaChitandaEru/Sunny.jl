<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Case Study: FeI_2 · Sunny documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Sunny documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><a class="tocitem" href="../../quick-start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Case Study: FeI<span>$_{2}$</span></a><ul class="internal"><li><a class="tocitem" href="#Crystals-and-symmetry-analysis"><span>Crystals and symmetry analysis</span></a></li><li><a class="tocitem" href="#Spin-systems"><span>Spin systems</span></a></li><li><a class="tocitem" href="#Interactions-and-anisotropies"><span>Interactions and anisotropies</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-a-dynamical-spin-structure-factor"><span>Calculating a dynamical spin structure factor</span></a></li><li><a class="tocitem" href="#Finding-a-ground-state"><span>Finding a ground state</span></a></li><li><a class="tocitem" href="#Calculating-the-structure-factor"><span>Calculating the structure factor</span></a></li><li><a class="tocitem" href="#Accessing-structure-factor-data"><span>Accessing structure factor data</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../library/">Library API</a></li><li><a class="tocitem" href="../../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Case Study: FeI<span>$_{2}$</span></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Case Study: FeI<span>$_{2}$</span></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/examples/fei2_tutorial.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Case-Study:-FeI_{2}"><a class="docs-heading-anchor" href="#Case-Study:-FeI_{2}">Case Study: FeI<span>$_{2}$</span></a><a id="Case-Study:-FeI_{2}-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study:-FeI_{2}" title="Permalink"></a></h1><p>FeI<span>$_{2}$</span> is an effective spin-1 material with strong single-ion anisotropy, making it an excellent candidate for treatment with SU(3) spin dynamics. In particular, one of the elementary excitations of the system can only be captured clasically with an SU(3) treatment. A magnon, clearly visible in the experimental data, would simply be absent if we were to employ traditional Landau-Lifshitz dynamics or SU(2) spin wave theory. Full details about the model can be found in reference [1].</p><p>The model contains a number of competing, anisotropic exchange interactions together with a strong single-ion anisotropy. Writing the exchange terms in the most general way, the Hamiltonian has the form:</p><p class="math-container">\[\mathcal{H}=\sum_{(i,j)} J^{\alpha\beta}_{ij} S^{\alpha}_i S^{\beta}_j - D\sum_i \left(S^z\right)^2\]</p><p>We will calculate a dynamic structure factor using this model. We begin by importing the required packages, starting with <code>Sunny</code>. We will also add <code>GLMakie</code>, a plotting package. If you see <code>Package X not found in current path</code>, you can install the package by entering <code>using Pkg; pkg&quot;add X&quot;</code> in the Julia REPL.</p><pre><code class="language-julia hljs">using Sunny
using GLMakie, Formatting</code></pre><h2 id="Crystals-and-symmetry-analysis"><a class="docs-heading-anchor" href="#Crystals-and-symmetry-analysis">Crystals and symmetry analysis</a><a id="Crystals-and-symmetry-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Crystals-and-symmetry-analysis" title="Permalink"></a></h2><p>The first step of defining a model is building a <code>Crystal</code>. If a CIF file available, it can be loaded using <code>Crystal(&quot;file.cif&quot;)</code>. A <code>Crystal</code> may also be created simply by providing a space group number. Here we will construct the crystal by hand, providing <code>Crystal</code> with a set of lattice vectors and basis vectors, where the basis vectors specify the locations of atoms within the unit cell in terms of fractional coordinates. We also assign labels to each atom with the optional keyword <code>types</code>.</p><p>For convenience, we will create a function which performs all these steps.</p><pre><code class="language-julia hljs">function FeI2_crystal()
    a = b = 4.05012  # Define the length of the three lattice vectors,
    c = 6.75214      # with units here given in angstroms.

    lat_vecs = lattice_vectors(a, b, c, 90, 90, 120) # This is a convenience method.
                                                     # Alternatively, lattice vectors may be
                                                     # specified as columns of a 3x3 matrix.
    basis_vecs = [[0,0,0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]  # Locations of atoms in fractional
                                                              # coordinates.
    types = [&quot;Fe&quot;, &quot;I&quot;, &quot;I&quot;] # Assign a name to each atom
    Crystal(lat_vecs, basis_vecs; types) # Create the crystal
end;</code></pre><p>Sunny will perform symmetry analysis on the crystal, identifying the space group. To aid the symmetry analysis, it is often helpful to provide names for the atoms, as we did above. The result of Sunny&#39;s analysis is given as output when creating the <code>Crystal</code>:</p><pre><code class="language-julia hljs">FeI2_crystal()</code></pre><pre><code class="nohighlight hljs">Crystal
HM symbol &#39;P -3 m 1&#39; (164)
Lattice params a=4.05, b=4.05, c=6.752, α=90°, β=90°, γ=120°
Cell volume 95.92
Type &#39;Fe&#39;, Wyckoff 1a (point group &#39;-3m.&#39;):
   1. [0, 0, 0]
Type &#39;I&#39;, Wyckoff 2d (point group &#39;3m.&#39;):
   2. [0.3333, 0.6667, 0.25]
   3. [0.6667, 0.3333, 0.75]
</code></pre><p>Sunny has inferred the space group <code>P -3 m 1</code>, corresponding to international number 164. This agrees with the crystal specification given in reference [1].</p><p>Sunny will use the symmetry information contained in a <code>Crystal</code> throughout the process of model creation. In particular, the <code>Crystal</code> will be used to determine the form of allowed interactions and anisotropies. The information also allows Sunny to propagate interactions and anisotropies to all symmetry-equivalent sites on a lattice.</p><h2 id="Spin-systems"><a class="docs-heading-anchor" href="#Spin-systems">Spin systems</a><a id="Spin-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-systems" title="Permalink"></a></h2><p>The basic type used to model a spin system is <a href="../../library/#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. Its constructor is:</p><pre><code class="nohighlight hljs">System(crystal, latsize, infos, mode)</code></pre><p>The argument <code>latsize</code> defines the system lattice size as three components, in multiples of unit cells. The argument <code>infos</code> defines the spin magnitude <span>$S$</span> (in units of <span>$ħ$</span>) and the <span>$g$</span>-factor or <span>$g$</span>-tensor for each ion, and this information will be propagated by crystal symmetry. The argument <code>mode</code> determines whether to use traditional Landau-Lifshitz dynamics (<code>:dipole</code>), or generalized SU(<em>N</em>) dynamics (<code>:SUN</code>).</p><p>In this example, we use the command <a href="../../library/#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>subcrystal</code></a> to isolate the magnetic <code>Fe</code> ions, and build a system of <span>$4×4×4$</span> unit cells:</p><pre><code class="language-julia hljs">cryst = subcrystal(FeI2_crystal(), &quot;Fe&quot;)
sys = System(cryst, (4,4,4), [SpinInfo(1,S=1)], :SUN)</code></pre><pre><code class="nohighlight hljs">System [SU(3)]
Cell size 1, Lattice size (4, 4, 4)
</code></pre><p>Sunny created an SU(3) system to capture the dynamics of the <span>$2S+1=3$</span> distinct states for each spin <span>$S=1$</span> degree of freedom.  The default <span>$g$</span>-factor of 2 can be overriden via the <a href="../../library/#Sunny.SpinInfo"><code>SpinInfo</code></a> constructor.</p><h2 id="Interactions-and-anisotropies"><a class="docs-heading-anchor" href="#Interactions-and-anisotropies">Interactions and anisotropies</a><a id="Interactions-and-anisotropies-1"></a><a class="docs-heading-anchor-permalink" href="#Interactions-and-anisotropies" title="Permalink"></a></h2><h3 id="Obtaining-symmetry-information"><a class="docs-heading-anchor" href="#Obtaining-symmetry-information">Obtaining symmetry information</a><a id="Obtaining-symmetry-information-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-symmetry-information" title="Permalink"></a></h3><p>The <code>System</code> above does not contain interactions, only a finite lattice with the symmetry properities of our <code>Crystal</code> together with local spin information for each site of the lattice. We still need to specify the interactions and anisotropies given in our Hamiltonian.</p><p>Information about the allowed interactions and anisotropies is provided by <code>print_symmetry_table(cryst, max_dist)</code>:</p><pre><code class="language-julia hljs">print_symmetry_table(cryst, 10.0)</code></pre><pre><code class="nohighlight hljs">Site 1
Type &#39;Fe&#39;, position [0, 0, 0], multiplicity 1
Allowed g-tensor: | A  0  0 |
                  | 0  A  0 |
                  | 0  0  B |
Allowed anisotropy in Stevens operators 𝒪[k,q]:
    c₁*𝒪[2,0] +
    c₂*𝒪[4,-3] + c₃*𝒪[4,0] +
    c₄*𝒪[6,-3] + c₅*𝒪[6,0] + c₆*𝒪[6,6]

Bond(1, 1, [1, 0, 0])
Distance 4.05012, coordination 6
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [1, 0, 0]
Allowed exchange matrix: | A  0  0 |
                         | 0  B  D |
                         | 0  D  C |

Bond(1, 1, [0, 0, 1])
Distance 6.75214, coordination 2
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [0, 0, 1]
Allowed exchange matrix: | A  0  0 |
                         | 0  A  0 |
                         | 0  0  B |

Bond(1, 1, [1, 2, 0])
Distance 7.01501361675086, coordination 6
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [1, 2, 0]
Allowed exchange matrix: | A  0  0 |
                         | 0  B  D |
                         | 0  D  C |

Bond(1, 1, [1, 0, 1])
Distance 7.8736818956572, coordination 12
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [1, 0, 1]
Allowed exchange matrix: | A  F  E |
                         | F  B  D |
                         | E  D  C |

Bond(1, 1, [2, 0, 0])
Distance 8.10024, coordination 6
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [2, 0, 0]
Allowed exchange matrix: | A  0  0 |
                         | 0  B  D |
                         | 0  D  C |

Bond(1, 1, [1, 2, -1])
Distance 9.73662213618255, coordination 6
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [1, 2, -1]
Allowed exchange matrix: | A  0  0 |
                         | 0  B  D |
                         | 0  D  C |

Bond(1, 1, [1, 2, 1])
Distance 9.73662213618255, coordination 6
Connects &#39;Fe&#39; at [0, 0, 0] to &#39;Fe&#39; at [1, 2, 1]
Allowed exchange matrix: | A  0  0 |
                         | 0  B  D |
                         | 0  D  C |

</code></pre><p>The output begins by specifying information about each site of the <code>Crystal</code>. (In our case there is only one site, since we restricted our crystal to the iron ion.) The allowed form of any g-tensor is given as a 3x3 matrix, and the allowed form of any single-site anisotropy is given as the most general linear combination of Stevens operators.</p><p>After single-site information, Sunny provides a list of the allowed bilinear interactions on every bond that lies within <code>max_dist</code> from the origin of the unit cell. The bond are specified in the following format: Bond(i, j, n). <code>i</code> and <code>j</code> are an pair of atoms within the unit cell. The number of each site is as given when creating the <code>Crystal</code>. Note that the relative order of <code>i</code> and <code>j</code> is significant when the exchange tensor contains antisymmetric elements, as is the case for Dzyaloshinskii–Moriya interactions. Finally, <code>n</code> is a vector of three integers specifying lattice offsets. So <code>Bond(1, 1, [1,0,0])</code> specifies a bond between the same atom in two different unit cells, where the cell offset is along the direction of the first lattice vector.</p><h3 id="Assigning-interactions-and-anisotropies"><a class="docs-heading-anchor" href="#Assigning-interactions-and-anisotropies">Assigning interactions and anisotropies</a><a id="Assigning-interactions-and-anisotropies-1"></a><a class="docs-heading-anchor-permalink" href="#Assigning-interactions-and-anisotropies" title="Permalink"></a></h3><p>Bilinear interactions are assigned to bonds with <code>set_exchange!(sys, J, bond)</code>, where <code>J</code> is an exchange tensor. <code>J</code> may be either a number, for simple Heisenberg exchange, or a 3x3 matrix. When <code>set_exchange!</code> is called, Sunny will both analyze <code>J</code> to ensure that it is symmetry-allowed and then propagate <code>J</code>, with appropriate transformations, to all symmetry-equivalent bonds in your <code>System</code>.</p><p>The function to assign a single site anisotropy is similar: <code>set_anisotropy!(sys, op, i)</code>. <code>i</code> is simply a site rather than a bond. <code>op</code> here a polynomial of either spin operators or Stevens operators. Sunny provides special symbols for their construction: <code>𝒮</code> is a vector of three symbolic operators, corresponding to 𝒮ˣ, 𝒮ʸ, and 𝒮ᶻ, and <code>𝒪</code> is a matrix of symbolic Stevens that takes two indices, corresponding to the traditional <span>$k$</span> (irrep) and <span>$q$</span> (row or column) indices of the Stevens tensors. For example, to assign <span>$(S^z)^2$</span> to our only site, we would call <code>set_anisotropy!(sys, 𝒮[3]^2, 1)</code>.</p><p>The function below combines everything we have learned so far to create a complete model of our FeI2 system.</p><pre><code class="language-julia hljs">function FeI2_system(; latsize=(4,4,4), S=1, seed=0)
    # Create the system
    cryst = subcrystal(FeI2_crystal(), &quot;Fe&quot;)
    sys = System(cryst, latsize, [SpinInfo(1; S)], :SUN; seed)

    # Establish exchange parameters as provided in reference [1]
    J1pm   = -0.236
    J1pmpm = -0.161
    J1zpm  = -0.261
    J2pm   = 0.026
    J3pm   = 0.166
    J′0pm  = 0.037
    J′1pm  = 0.013
    J′2apm = 0.068
    D      = 2.165

    J1zz   = -0.236
    J2zz   = 0.113
    J3zz   = 0.211
    J′0zz  = -0.036
    J′1zz  = 0.051
    J′2azz = 0.073

    J1xx = J1pm + J1pmpm
    J1yy = J1pm - J1pmpm
    J1yz = J1zpm

    # Convert parameters to exchange matrices and make a list of `Js`
    Js = [
        [J1xx  0.0   0.0;
         0.0   J1yy  J1yz;
         0.0   J1yz  J1zz],
        [J2pm  0.0  0.0;
         0.0   J2pm 0.0;
         0.0   0.0  J2zz],
        [J3pm   0.0   0.0;
         0.0    J3pm  0.0;
         0.0    0.0   J3zz],
        [J′0pm  0.0   0.0;
         0.0    J′0pm 0.0;
         0.0    0.0   J′0zz],
        [J′1pm  0.0   0.0;
         0.0    J′1pm 0.0;
         0.0    0.0   J′1zz],
        [J′2apm  0.0   0.0;
         0.0    J′2apm 0.0;
         0.0    0.0   J′2azz],
    ]

    # Make a corrresponding list of bonds
    bonds = [
        Bond(1,1,[1,0,0]),
        Bond(1,1,[1,2,0]),
        Bond(1,1,[2,0,0]),
        Bond(1,1,[0,0,1]),
        Bond(1,1,[1,0,1]),
        Bond(1,1,[1,2,1]),
    ]

    # Assign interactions and anisotropy to the system
    for (bond, J) in zip(bonds, Js)
        set_exchange!(sys, J, bond)
    end
    set_anisotropy!(sys, -D*𝒮[3]^2, 1)

    return sys
end;</code></pre><p>We can now create a <code>System</code> corresponding to our model:</p><pre><code class="language-julia hljs">sys_small = FeI2_system(; latsize=(4,4,4))</code></pre><pre><code class="nohighlight hljs">System [SU(3)]
Cell size 1, Lattice size (4, 4, 4)
</code></pre><h1 id="Calculating-a-dynamical-spin-structure-factor"><a class="docs-heading-anchor" href="#Calculating-a-dynamical-spin-structure-factor">Calculating a dynamical spin structure factor</a><a id="Calculating-a-dynamical-spin-structure-factor-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-a-dynamical-spin-structure-factor" title="Permalink"></a></h1><p>In the remainder of this tutorial, we will examine Sunny&#39;s tools for calculating structure factors using generalized SU(<em>N</em>) classical dynamics. This is a Monte Carlo calculation and will require the sampling of many spin configurations from the Boltzmann distribution at a particular temperature. These samples are then used to generate dynamical trajectories that are analyzed to produce correlation information, i.e., a dynamical structure factor <span>$\mathcal{S}^{\alpha\beta}(\mathbf{q},\omega)$</span>. To compare results with low-temperature experimental data or spin wave calculations, it is necessary to first identify a ground state of the system. We can then thermalize this ground state with the <a href="../../library/#Sunny.Langevin"><code>Langevin</code></a> dynamics to generate sample spin configurations.</p><h2 id="Finding-a-ground-state"><a class="docs-heading-anchor" href="#Finding-a-ground-state">Finding a ground state</a><a id="Finding-a-ground-state-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-ground-state" title="Permalink"></a></h2><p>While we will be using Langevin integration to generate sample spin configurations, it is also a powerful tool for optimization, as will now be demonstrated.</p><pre><code class="language-julia hljs">E0 = 2.165        # Largest energy scale in the Hamiltonian
Δt = 0.05/E0      # Safe choice for integration step size
kT = 10.0         # Temperature in meV
λ = 0.1           # Magnitude of coupling to thermal bath
langevin = Langevin(Δt, kT, λ);</code></pre><p>The following function will perform simulated annealing according to a list of temperatures and a number of time steps per temperature,</p><pre><code class="language-julia hljs">function anneal!(sys, langevin, nsteps, kTs)
      Es = zeros(length(kTs))           # Buffer to record energy
      for (i, kT) in enumerate(kTs)
            langevin.kT = kT            # Set the temperature
            for _ in 1:nsteps           # Advance the state nsteps
                step!(sys, langevin)
            end
            Es[i] = energy(sys)         # Record the energy
      end
      return Es
end</code></pre><pre><code class="nohighlight hljs">anneal! (generic function with 1 method)</code></pre><p>Finally we perform the annealing.</p><pre><code class="language-julia hljs">kT = 10.0                        # Starting temp in meV
kTs = [kT*0.9^k for k in 0:100]  # Temperature schedule
nsteps = round(Int, 30.0/Δt)     # Set nsteps to 30.0 meV⁻¹
randomize_spins!(sys_small)      # Set random (infinite temperature) initial condition

Es = anneal!(sys_small, langevin, nsteps, kTs)

for _ in 1:nsteps                # Run at T=0 for a short period
    step!(sys_small, langevin)
end</code></pre><p>Plotting the energies recorded during the annealing process will help us determined whether the process has converged.</p><pre><code class="language-julia hljs">fig = Figure()
idxs = 1:10:length(kTs)
xticks = (idxs, [format(&quot;{:.3f}&quot;,  kTs[i]) for i in idxs])
ax = Axis(fig[1,1];
    xlabel = &quot;Temperature (meV)&quot;,
    ylabel = &quot;Total Energy (meV)&quot;,
    xticks
)
lines!(ax, Es)
fig</code></pre><p><img src="../fei2_tutorial-27.png" alt/></p><p>It appears that the system has reached at least a local minimum. We will use the function <code>plot_spins</code> to examine if the spin configuration matches our prior ideas about what the ground state looks like.</p><pre><code class="language-julia hljs">plot_spins(sys_small; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)</code></pre><p><img src="../fei2_tutorial-29.png" alt/></p><p>This is correct, but our spin system is quite small. Because the calculation will be performed on a finite lattice, our resolution in momentum space will be limited by the system size. We will therefore extend the system periodically into a larger <code>System</code>:</p><pre><code class="language-julia hljs">sys = extend_periodically(sys_small, (4,4,1))  # Multiply 1st and 2nd lattice dimensions by 4
plot_spins(sys; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)</code></pre><p><img src="../fei2_tutorial-31.png" alt/></p><h2 id="Calculating-the-structure-factor"><a class="docs-heading-anchor" href="#Calculating-the-structure-factor">Calculating the structure factor</a><a id="Calculating-the-structure-factor-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-structure-factor" title="Permalink"></a></h2><p>To get a good equilibrium sample, we will next thermalize the system at a low temperature, again using the Langevin dynamics. The parameters we select below are known to be effective for this model but will need to be determined for each specific case.</p><pre><code class="language-julia hljs">decorrelation_time = 2.0                    # Time in meV⁻¹ required to get an uncorrelated sample
nsteps = round(Int, decorrelation_time/Δt)  # Convert to number of time steps
kT = 0.5 * Sunny.meV_per_K                  # Set temperature meV equivalent of 0.5 K
langevin = Langevin(Δt, kT, λ)              # Build Langevin integrator with these parameters

for _ in 1:5nsteps                          # Run for sufficient time to thermalize
    step!(sys, langevin)
end;</code></pre><p>The spins in our system should now represent a good sample at 0.5 K. We can proceed with the calculation by calling <code>DynamicStructureFactor</code>. Three keyword parameters are required to determine the ω information that will be calculated: an integration step size, the number of ωs to resolve, and the maximum ω to resolve. For the time step, twice the value used for the Langevin integrator is usually a good choice.</p><pre><code class="language-julia hljs">sf = DynamicStructureFactor(sys; Δt=2Δt, nω=120, ωmax=7.5);</code></pre><p><code>sf</code> currently contains dynamical structure data generated from a single sample. Additional samples can be added by generating a new spin configuration and calling <code>add_sample!</code>:</p><pre><code class="language-julia hljs">for _ in 1:2
    for _ in 1:nsteps            # Generate a new sample spin configuration
        step!(sys, langevin)
    end
    add_sample!(sf, sys)         # Accumulate the sample into `sf`
end;</code></pre><h2 id="Accessing-structure-factor-data"><a class="docs-heading-anchor" href="#Accessing-structure-factor-data">Accessing structure factor data</a><a id="Accessing-structure-factor-data-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-structure-factor-data" title="Permalink"></a></h2><p>The basic function for accessing intensity data is <code>intensities</code>, which, in addition to the structure factor data itself, takes a list of wave vectors and a mode parameter. The options for the mode parameter are <code>:trace</code>, <code>:perp</code> and <code>:full</code> which return, respectively, the trace, the unpolarized intensity, and the full set of matrix elements (correlations of spin components) at the specified wave vectors. For example, we can plot two single-Q slices as follows.</p><pre><code class="language-julia hljs">qs = [[0, 0, 0], [0.5, 0.5, 0.5]]
is = intensities(sf, qs, :trace; kT)

fig = Figure()
ax = Axis(fig[1,1]; xlabel=&quot;meV&quot;, ylabel=&quot;Intensity&quot;)
l1 = lines!(ax, ωs(sf), is[1,:])
l2 = lines!(ax, ωs(sf), is[2,:])
Legend(fig[1,2], [l1, l2], [&quot;(0,0,0)&quot;, &quot;(π,π,π)&quot;])
fig</code></pre><p><img src="../fei2_tutorial-39.png" alt/></p><p>Note that we provided the optional keyword <code>kT</code> to <code>intensities</code> to enable Sunny to apply a classical-to-quantum rescaling of intensities.</p><p>Frequently we want to extract energy intensities along lines that connect special wave vectors. Sunny provides a function <code>connected_path</code> to makes this easy. The density of sample points can be tuned with a density argument.</p><pre><code class="language-julia hljs">points = [[0.0, 0.0, 0.0],  # List of wave vectors that define a path
          [1.0, 0.0, 0.0],
          [0.0, 1.0, 0.0],
          [0.5, 0.0, 0.0],
          [0.0, 1.0, 0.0],
          [0.0, 0.0, 0.0]]
formfactors = [FormFactor(1, &quot;Fe2&quot;; g_lande=3/2)]  # Ion information for each site to
                                                   # retrieve form factor correction parameters
density = 40
path, markers = connected_path(points, density)

is = intensities(sf, path, :perp;
    interpolation = :linear,       # Interpolate between available wave vectors
    kT,                            # Temperature for intensity correction
    formfactors,                   # Form factor information
)

fig = Figure()
labels = [&quot;($(p[1]),$(p[2]),$(p[3]))&quot; for p in points]
ax = Axis(fig[1,1];
    ylabel = &quot;meV&quot;,
    xticks = (markers, labels),
    xticklabelrotation=π/8,
    xticklabelsize=12,
)
heatmap!(ax, 1:size(is,1), ωs(sf), is; colorrange=(0.0, 0.5))
fig</code></pre><p><img src="../fei2_tutorial-41.png" alt/></p><p>Often it is useful to plot cuts across multiple wave vectors but at a single energy.</p><pre><code class="language-julia hljs">npoints = 60
qvals = range(-2.0, 2.0, length=npoints)
qs = [[a, b, 0.0] for a in qvals, b in qvals]
forfactors = [FormFactor(1, &quot;Fe2&quot;)]

is = intensities(sf, qs, :perp;
    interpolation = :linear,
    kT,
    formfactors,
);

ωidx = 30
ω = ωs(sf)[ωidx]
fig = Figure()
ax = Axis(fig[1,1]; title=&quot;ω=$ω meV&quot;, aspect=true)
hidedecorations!(ax); hidespines!(ax)
hm = heatmap!(ax, is[:,:,ωidx])
Colorbar(fig[1,2], hm)
fig</code></pre><p><img src="../fei2_tutorial-43.png" alt/></p><p>Note that Brillouin zones appear &quot;skewed&quot;. This is a consequence of the fact that our reciprocal lattice vectors are not orthogonal. It is often useful to express our wave vectors in terms of an orthogonal basis, where each basis element is specified as a linear combination of reciprocal lattice vectors. For our crystal, with reciprocal vectors <span>$a^*$</span>, <span>$b^*$</span> and <span>$c^*$</span>, we can define an orthogonal basis by taking <span>$\hat{a}^* = 0.5(a^* + b^*)$</span>, <span>$\hat{b}^*=a^* - b^*$</span>, and <span>$\hat{c}^*=c^*$</span>. Below, we map <code>qs</code> to wavevectors <code>ks</code> in the new coordinate system and get their intensities.</p><pre><code class="language-julia hljs">A = [0.5  1.0 0.0;
     0.5 -1.0 0.0;
     0.0  0.0 1.0]
ks = [A*q for q in qs]

@time is_ortho = intensities(sf, ks, :perp;
    interpolation = :linear,
    kT,
    formfactors,
);

fig = Figure()
ax = Axis(fig[1,1]; title=&quot;ω=$ω meV&quot;, aspect=true)
hidedecorations!(ax); hidespines!(ax)
hm = heatmap!(ax, is_ortho[:,:,ωidx])
Colorbar(fig[1,2], hm)
fig</code></pre><p><img src="../fei2_tutorial-45.png" alt/></p><p>Finally, we note that static structure factor data can be obtained from a dynamic structure factor with <code>static_intensities</code>:</p><pre><code class="language-julia hljs">is_static = static_intensities(sf, ks, :perp;
    interpolation = :linear,
    kT,
    formfactors,
)

fig = Figure()
ax = Axis(fig[1,1]; title=&quot;Static Structure Factor&quot;, aspect=true)
hidedecorations!(ax); hidespines!(ax)
hm = heatmap!(ax, is_static)
Colorbar(fig[1,2], hm)
fig</code></pre><p><img src="../fei2_tutorial-47.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../quick-start/">« Quick Start</a><a class="docs-footer-nextpage" href="../../library/">Library API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 February 2023 17:49">Friday 3 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
