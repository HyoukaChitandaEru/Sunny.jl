var documenterSearchIndex = {"docs":
[{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"EditURL = \"../../../examples/powder_averaging.jl\"","category":"page"},{"location":"examples/powder_averaging/#Powder-Averaging","page":"Powder Averaging","title":"Powder Averaging","text":"","category":"section"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"This tutorial illustrates the calculation of the powder-averaged structure factor by performing an orientational average. We consider a simple model of the diamond-cubic crystal CoRh_2O_4, with parameters extracted from Ge et al., Phys. Rev. B 96, 064413 (https://doi.org/10.1103/PhysRevB.96.064413).","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"using Sunny, GLMakie","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Construct a diamond Crystal in the conventional (non-primitive) cubic unit cell. Sunny will populate all eight symmetry-equivalent sites when given the international spacegroup number 227 (\"Fd-3m\") and the appropriate setting. For this spacegroup, there are two conventional translations of the unit cell, and it is necessary to disambiguate through the setting keyword argument. Try omitting the setting argument and see how Sunny responds.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"a = 8.5031 # (√Ö)\nlatvecs = lattice_vectors(a, a, a, 90, 90, 90)\ncrystal = Crystal(latvecs, [[0,0,0]], 227, setting=\"1\")","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Construct a System with an antiferromagnetic nearest neighbor interaction J. Because the diamond crystal is bipartite, the ground state will have unfrustrated N√©el order. Selecting latsize=(1,1,1) is sufficient because the ground state is periodic over each cubic unit cell. By passing an explicit seed, the system's random number generator will give repeatable results.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"latsize = (1,1,1)\nseed = 0\nS = 3/2\nJ = 7.5413*meV_per_K # (meV)\nsys = System(crystal, latsize, [SpinInfo(1; S, g=2)], :dipole; seed=0)\nset_exchange!(sys, J, Bond(1, 3, [0,0,0]))","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"The ground state is non-frustrated. Each spin should be exactly anti-aligned with its 4 nearest-neighbors, such that every bond contributes an energy of -JS^2. This gives an energy per site of -2JS^2. In this calculation, a factor of 1/2 is necessary to avoid double-counting the bonds. Given the small magnetic supercell (which includes only one unit cell), direct energy minimization is successful in finding the ground state.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"randomize_spins!(sys)\nminimize_energy!(sys)\n\nenergy_per_site = energy(sys) / length(all_sites(sys))\n@assert energy_per_site ‚âà -2J*S^2","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Plotting the spins confirms the expected N√©el order. Note that the overall, global rotation of dipoles is arbitrary.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"plot_spins(sys; arrowlength=1.0, linewidth=0.4, arrowsize=0.5)","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"We can now estimate ùíÆ(ùê™œâ) with SpinWaveTheory and intensity_formula. The mode :perp contracts with a dipole factor to return the unpolarized intensity. We will also apply broadening with the lorentzian kernel.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"swt = SpinWaveTheory(sys)\nŒ∑ = 0.3 # (meV)\nformula = intensity_formula(swt, :perp, kernel=lorentzian(Œ∑)) # TODO: formfactors=[FormFactor(1, \"Co2\")]","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"First, we consider the \"single crystal\" results. Use connected_path_from_rlu to construct a path that connects high-symmetry points in reciprocal space. The intensities_broadened function collects intensities along this path for the given set of energy (ƒßœâ) values.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"qpoints = [[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [0.5, 0.5, 0.0], [0.0, 0.0, 0.0]]\npath, xticks = connected_path_from_rlu(crystal, qpoints, 50)\nenergies = collect(0:0.01:6)\nis = intensities_broadened(swt, path, energies, formula)","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Plot the results","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"fig = Figure()\nax = Axis(fig[1,1]; aspect=1.4, ylabel=\"œâ (meV)\", xlabel=\"ùê™ (RLU)\",\n          xticks, xticklabelrotation=œÄ/10)\nheatmap!(ax, 1:size(is, 1), energies, is, colormap=:gnuplot2)\nfig","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"To compare with experimental measurements on a crystal powder, we should average over all possible crystal orientations. For this, consider a sequence of radii rs (units of inverse √Ö) that define spherical shells in reciprocal space. The function spherical_shell selects points on these shells that are approximately equidistant. For each shell, again call intensities_broadened, and average over the energy index. The result is a powder averaged intensity.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"rs = 0.01:0.02:3 # (1/√Ö)\noutput = zeros(Float64, length(rs), length(energies))\nfor (i, r) in enumerate(rs)\n    qs = spherical_shell(r; minpoints=300)\n    is = intensities_broadened(swt, qs, energies, formula)\n    output[i, :] = sum(is, dims=1) / size(is, 1)\nend\n\nempty!(fig)\nax = Axis(fig[1,1]; xlabel=\"|Q| (√Ö‚Åª¬π)\", ylabel=\"œâ (meV)\")\nheatmap!(ax, rs, energies, output, colormap=:gnuplot2)\nfig","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"This result can be compared to experimental neutron scattering data from Ge et al.","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/CoRh2O4_intensity.jpg\">","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"","category":"page"},{"location":"examples/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"This page was generated using Literate.jl.","category":"page"},{"location":"versions/#Version-0.5.0","page":"Version History","title":"Version 0.5.0","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"New features.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Support for Linear Spin Wave Theory in :dipole and :SUN modes. (Thanks Hao Zhang!)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"New function minimize_energy! to efficiently find an optimal configuration of spin dipoles or SU(N) coherent states.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Major refactors and enhancements to intensity calculations. This new interface allows unification between LSWT and classical spin dynamics calculations. This interface allows: Custom observables as local quantum operators, better support for linebroadening, and automatic binning to facilitate comparison with experimental data. See intensity_formula for documentation. Use load_nxs to load experimental neutron scattering data.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Breaking changes.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Replace set_anisotropy! with a new function set_onsite_coupling! (and similarly set_onsite_coupling_at!). The latter expects an explicit matrix representation for the local Hamiltonian. This can be constructed, e.g., as a linear combination of stevens_operators, or as a polynomial of spin_operators. To understand the mapping between these two, the new function print_stevens_expansion acts on an arbitrary local operator.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Remove set_biquadratic!. Instead, use an optional keyword argument biquad to set_exchange!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename DynamicStructureFactor to dynamical_correlations. Similarly, replace InstantStructureFactor with instant_correlations. The return type has been renamed SampledCorrelations to emphasize that the object may be holding thermodynamic samples, which are collected using add_sample!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Remove intensities function. Instead, use one of intensities_interpolated or intensities_binned. These will require an intensity_formula, which defines a calculator (e.g., LSWT).","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Sunny now expects all wavevectors in units of inverse Angstrom (1/‚Ñ´). This facilitates orientational averaging. Replace connected_path with connected_path_from_rlu, which returns wavevectors in 1/‚Ñ´. Now spherical_shell needs one fewer argument, and returns wavevectors in 1/‚Ñ´.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename polarize_spin! to set_dipole! for consistency with set_coherent!. The behavior of the former function is unchanged: the spin at a given site will still be polarized along the provided direction.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename reshape_geometry to reshape_supercell, which is the fundamental reshaping function. Rename resize_periodically to resize_supercell.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The constructor SpinInfo now requires a g-factor or tensor as a named argument.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Symbolic representations of operators are now hidden unless the external package DynamicPolynomials.jl is explicitly loaded by the user. The functionality of print_anisotropy_as_stevens has been replaced with print_classical_stevens_expansion, while print_anisotropy_as_classical_spins has become print_classical_spin_polynomial.","category":"page"},{"location":"versions/#Version-0.4.3","page":"Version History","title":"Version 0.4.3","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Experimental support for linear SpinWaveTheory, implemented in SU(N) mode. This module may evolve rapidly.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Implement renormalization of single-ion anisotropy and biquadratic interactions when in :dipole mode. This makes the model more faithful to the quantum mechanical Hamiltonian, but is also a breaking change.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Various improvements and bugfixes for to_inhomogeneous. Setting inhomogeneous interactions via set_exchange_at! should now infer the correct bond offset direction, or will report an ambiguity error. Ambiguities can be resolved by passing an explicit offset.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The function remove_periodicity! disables periodicity along specified dimensions.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename StaticStructureFactor to InstantStructureFactor.","category":"page"},{"location":"versions/#Version-0.4.2","page":"Version History","title":"Version 0.4.2","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Introduce LocalSampler, a framework for MCMC sampling with local spin updates.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename print_dominant_wavevectors to print_wrapped_intensities to reduce confusion with the physical instantaneous intensities.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The function spherical_shell now takes a radius in physical units of inverse √Ö.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"New exported functions global_position, magnetic_moment, all_sites.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Remove all uses of Base.deepcopy which resolves crashes.","category":"page"},{"location":"versions/#Version-0.4.1","page":"Version History","title":"Version 0.4.1","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The function to_inhomogeneous creates a system that supports inhomogeneous interactions, which can be set using set_exchange_at!, etc.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"set_biquadratic! replaces set_exchange_with_biquadratic!.","category":"page"},{"location":"versions/#Version-0.4.0","page":"Version History","title":"Version 0.4.0","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"This update includes many breaking changes, and is missing some features of 0.3.0.","category":"page"},{"location":"versions/#Creating-a-spin-System","page":"Version History","title":"Creating a spin System","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Rename SpinSystem to System. Its constructor now has the form,","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"System(crystal, latsize, infos, mode)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter infos is now a list of SpinInfo objects. Each defines spin angular momentum S = frac12 1 frac32 , and an optional g-factor or tensor.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter mode is one of :SUN or :dipole.","category":"page"},{"location":"versions/#Setting-interactions","page":"Version History","title":"Setting interactions","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Interactions are now added mutably to an existing System using the following functions: set_external_field!, set_exchange!, set_onsite_coupling!, enable_dipole_dipole!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"As a convenience, one can use dmvec(D) to convert a DM vector to a 33 antisymmetric exchange matrix.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Fully general single-ion anisotropy is now possible. The function set_onsite_coupling! expects the single ion anisotropy to be expressed as a polynomial in symbolic spin operators ùíÆ, or as a linear combination of symbolic Stevens operators ùí™. For example, an easy axis anisotropy in the direction n may be written D*(ùíÆ‚ãÖn)^2.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Stevens operators ùí™[k,q] admit polynomial expression in spin operators ùíÆ[Œ±]. Conversely, a polynomial of spin operators can be expressed as a linear combination of Stevens operators. To see this expansion use print_anisotropy_as_stevens.","category":"page"},{"location":"versions/#Inhomogeneous-field","page":"Version History","title":"Inhomogeneous field","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"An external field can be applied to a single site with set_external_field_at!. ","category":"page"},{"location":"versions/#Structure-factor-rewrite","page":"Version History","title":"Structure factor rewrite","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The calculation of structure factors has been completely rewritten. For the new interface, see the Structure Factor Calculations page.","category":"page"},{"location":"versions/#Various","page":"Version History","title":"Various","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The \"Sampler\" interface is in flux. Langevin replaces both LangevinHeunP and LangevinSampler. Local spin-flip Monte Carlo sampling methods are temporarily broken.\nrepeat_periodically replaces extend_periodically.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Additional related functions include resize_periodically and reshape_geometry, the latter being fundamental.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"print_symmetry_table replaces print_bond_table().","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The new function includes the list of symmetry-allowed single ion anisotropies in addition to exchange interactions.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"When reading CIF files, the field _atom_site_label is now used in place of the field _atom_site_type_symbol.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"This is required for correctness. The field _atom_site_label is guaranteed to be present, and is guaranteed to be a distinct label for each symmetry-inequivalent site. Code that explicitly referred to site labels (e.g. in calls to subcrystal) will need to be updated to use the new label.","category":"page"},{"location":"library/#Library-API","page":"Library API","title":"Library API","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter ? at the Julia command prompt).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Modules = [Sunny]\nPrivate = false","category":"page"},{"location":"library/#Sunny.Site","page":"Library API","title":"Sunny.Site","text":"(cell1, cell2, cell3, i) :: Site\n\nFour indices identifying a single site in a System. The first three indices select the lattice cell and the last selects the sublattice (i.e., the atom within the unit cell).\n\nThis object can be used to index dipoles and coherents fields of a System. A Site is also required to specify inhomogeneous interactions via functions such as set_external_field_at! or set_exchange_at!.\n\nNote that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the Site using position_to_site, which always takes a position in fractional coordinates of the original lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Units","page":"Library API","title":"Sunny.Units","text":"Units.meV\nUnits.theory\n\nThe unit system is implicitly determined by the definition of two physical constants: the vacuum permeability Œº‚ÇÄ and the Bohr magneton Œº_B. Temperatures are effectively measured in units of energy (k_B = 1) and time is effectively measured in units of inverse energy (ƒß = 1). The default unit system, Units.meV, employs (meV, ‚Ñ´, tesla). Select alternatively Units.theory for a units system defined so that Œº‚ÇÄ = Œº_B = 1.\n\nSee also meV_per_K\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.meV_per_K","page":"Library API","title":"Sunny.meV_per_K","text":"meV_per_K = 0.086173332621451774\n\nA physical constant. Useful for converting kelvin into the default energy units, meV.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.ùí™","page":"Library API","title":"Sunny.ùí™","text":"ùí™[k,q]\n\nAbstract symbols for the Stevens operators. Linear combinations of these can be used to define a single-ion anisotropy.\n\nBecomes available after explicitly loading DynamicPolynomials.jl, e.g., using DynamicPolynomials.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.ùíÆ","page":"Library API","title":"Sunny.ùíÆ","text":"ùíÆ[1], ùíÆ[2], ùíÆ[3]\n\nAbstract symbols for the spin operators. Polynomials of these can be used to define a single-ion anisotropy.\n\nBecomes available after explicitly loading DynamicPolynomials.jl, e.g., using DynamicPolynomials.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.BinningParameters","page":"Library API","title":"Sunny.BinningParameters","text":"BinningParameters(binstart,binend,binwidth;covectors = I(4))\nBinningParameters(binstart,binend;numbins,covectors = I(4))\n\nDescribes a 4D parallelepided histogram in a format compatible with experimental Inelasitic Neutron Scattering data. See generate_mantid_script_from_binning_parameters to convert BinningParameters to a format understandable by the Mantid software, or load_nxs to load BinningParameters from a Mantid .nxs file.\n\nThe coordinates of the histogram axes are specified by multiplication  of (k,œâ) with each row of the covectors matrix, with k given in absolute units. Since the default covectors matrix is the identity matrix, the default axes are (kx,ky,kz,œâ) in absolute units.\n\nThe convention for the binning scheme is that:\n\nThe left edge of the first bin starts at binstart\nThe bin width is binwidth\nThe last bin contains binend\nThere are no \"partial bins;\" the last bin may contain values greater than binend. C.f. count_bins.\n\nA value can be binned by computing its bin index:\n\ncoords = covectors * value\nbin_ix = 1 .+ floor.(Int64,(coords .- binstart) ./ binwidth)\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Bond","page":"Library API","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal","page":"Library API","title":"Sunny.Crystal","text":"An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:\n\nCrystal(filename; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.  The optional parameter symprec controls the precision tolerance for spacegroup symmetries.\n\nCrystal(latvecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, with coordinates (between 0 and 1) in units of lattice vectors latvecs. Spacegroup symmetry information is automatically inferred. The optional parameter types is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.\n\nCrystal(latvecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)\n\nBuilds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional setting string will disambiguate between unit cell conventions.\n\nCurrently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a .cif file or from the full specification of the unit cell.\n\nExamples\n\n# Read a Crystal from a .cif file\nCrystal(\"filename.cif\")\n\n# Build an FCC crystal using the primitive unit cell. The spacegroup number\n# 225 is inferred.\nlatvecs = [1 1 0;\n            1 0 1;\n            0 1 1] / 2\npositions = [[0, 0, 0]]\nCrystal(latvecs, positions)\n\n# Build a CsCl crystal (two cubic sublattices). By providing distinct type\n# strings, the spacegroup number 221 is inferred.\nlatvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[0,0,0], [0.5,0.5,0.5]]\ntypes = [\"Na\", \"Cl\"]\ncryst = Crystal(latvecs, positions; types)\n\n# Build a diamond cubic crystal from its spacegroup number 227. This\n# spacegroup has two possible settings (\"1\" or \"2\"), which determine an\n# overall unit cell translation.\nlatvecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[1, 1, 1] / 4]\ncryst = Crystal(latvecs, positions, 227; setting=\"1\")\n\nSee also lattice_vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}","page":"Library API","title":"Sunny.FormFactor","text":"FormFactor(atom::Int64, elem::String; g_lande=nothing)\n\nBasic type for specifying form factor parameters. Must be provided a site within the unit cell (atom) and a string specifying the element name. This used when creating an intensity_formula, which accepts a list of FormFactorss. Note that these corrections assume S(q,œâ) is being calculated in the dipole approximation; they may not be appropriate for a general SU(N) system.\n\nA list of supported element names is available at:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\n\nThe Land√© g-factor may also be specified. \n\nIn more detail, the data stored in a FormFactor will be used to compute the form factor for each momentum space magnitude |k|, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor f is returned. If the keyword g_lande is given a numerical value, then a second order form factor F is returned.\n\nIt is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable s = k4œÄ, where k can be interpreted as the magnitude of momentum transfer.\n\nThe Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation\n\nlangle j_l(s) rangle = A e^-as^2 + B e^-bs^2 + Ce^-cs^2 + D\n\nwhere coefficients A B C D a b c are obtained from semi-empirical fits, depending on the orbital angular momentum index l = 0 2. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.\n\nA first approximation to the magnetic form factor is\n\nf(s) = langle j_0(s) rangle\n\nA second order correction is given by\n\nF(s) = frac2-gg langle j_2(s) rangle s^2 + f(s), where g is the Land√© g-factor.  \n\nDigital tables are available at:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\n\nAdditional references are:\n\nMarshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)\nClementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)\nFreeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)\nDescleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.ImplicitMidpoint","page":"Library API","title":"Sunny.ImplicitMidpoint","text":"ImplicitMidpoint(Œît::Float64; atol=1e-12) where N\n\nEnergy-conserving spin dynamics. One call to the step! function will advance a System by Œît units of time.\n\nUses the spherical midpoint integration scheme for dipole systems and the Schr√∂dinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic, and therefore avoid energy drift over long periods of simulation time.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Langevin","page":"Library API","title":"Sunny.Langevin","text":"Langevin(Œît::Float64; Œª::Float64, kT::Float64)\n\nSpin dynamics with coupling to a Langevin thermostat, which includes damping and noise terms. One call to the step! function will advance a System by Œît units of time.\n\nAssuming ergodicity, the Langevin dynamics will sample from thermal equilibrium for the target temperature kT. The empirical parameter Œª determines the strength of the coupling to the thermal bath. In other words, 1/Œª is the decorrelation time-scale. If Œª = 0, then the spin dynamics coincides with ImplicitMidpoint.\n\nAn alternative approach to sampling is LocalSampler, which may be preferred when the allowed spin values become effective discrete (e.g. Ising spins).\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LocalSampler","page":"Library API","title":"Sunny.LocalSampler","text":"LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)\n\nMonte Carlo simulation involving Metropolis updates to individual spins. One call to the step! function will perform nsweeps of MCMC sampling for a provided System. The default value of 1.0 means that step! performs, on average, one trial update per spin.\n\nAssuming ergodicity, the LocalSampler will sample from thermal equilibrium for the target temperature kT. \n\nThe trial spin updates are sampled using the propose function. Built-in options include propose_uniform, propose_flip, and propose_delta. Multiple proposals can be mixed with the macro @mix_proposals.\n\nThe returned object stores fields ŒîE and Œîs, which represent the cumulative change to the net energy and dipole, respectively.\n\nAn alternative approach to sampling is Langevin, which may be preferred for simulating continuous spins, especially in the presence of long-range dipole-dipole interactions (cf. enable_dipole_dipole!).\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SampledCorrelations","page":"Library API","title":"Sunny.SampledCorrelations","text":"SampledCorrelations\n\nBasic data type for storing sampled correlation data. A SampleCorrelations is initialized by calling either dynamical_correlations or instant_correlations.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinInfo","page":"Library API","title":"Sunny.SpinInfo","text":"SpinInfo(atom::Int; S, g=2)\n\nCharacterizes the spin at a given atom index within the crystal unit cell. S is an integer multiple of 1/2 and gives the spin angular momentum in units of ƒß. g is the g-factor or tensor, such that an angular momentum dipole s produces a magnetic moment g s in units of the Bohr magneton.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinWaveTheory","page":"Library API","title":"Sunny.SpinWaveTheory","text":"SpinWaveTheory(sys, energy_œµ::Float64=1e-8, energy_tol=1e-6)\n\nConstructs an object to perform linear spin wave theory. Use it with dispersion and dssf functions.\n\nThe optional parameter energy_œµ adds a small positive shift to the diagonal of the dynamical matrix D to avoid numerical issues with zero-energy quasi-particle modes. The optional parameter energy_tol relaxes the check on the imaginary part of the eigenvalues.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}","page":"Library API","title":"Sunny.System","text":"System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)\n\nConstruct a System of spins for a given Crystal symmetry. The latsize parameter determines the number of unit cells in each lattice vector direction. The infos parameter is a list of SpinInfo objects, which determine the magnitude S and g-tensor of each spin.\n\nThe three possible options for mode are :SUN, :dipole, and :large_S. The most variationally accurate choice is :SUN, in which each spin-S degree of freedom is described as an SU(N) coherent state, where N = 2S + 1. Note that an SU(N) coherent state fully describes any local spin state; this description includes expected dipole components S·µÖ, quadrupole components S·µÖS·µù+S·µùS·µÖ, etc.\n\nThe mode :dipole projects the SU(N) dynamics onto the space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but all single-ion anisotropy and biquadratic exchange interactions will be automatically renormalized for maximum accuracy.\n\nTo disable such renormalization, e.g. to reproduce results using the historical large-S classical limit, use the experimental mode :large_S. Modes :SUN or :dipole are strongly preferred for the development of new models.\n\nThe default units system of (meV, ‚Ñ´, tesla) can be overridden by with the units parameter; see Units. \n\nAn optional seed may be provided to achieve reproducible random number generation.\n\nAll spins are initially polarized in the z-direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.add_sample!-Tuple{SampledCorrelations, System}","page":"Library API","title":"Sunny.add_sample!","text":"add_sample!(sc::SampledCorrelations, sys::System)\n\nadd_trajectory uses the spin configuration contained in the System to generate a correlation data and accumulate it into sc. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculating in time and accumulated into sc. \n\nThis function will change the state of sys when calculating dynamical structure factor data. To preserve the initial state of sys, it must be saved separately prior to calling add_sample!. Alternatively, the initial spin configuration may be copied into a new System and this new System can be passed to add_sample!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_exact_wave_vectors-Tuple{SampledCorrelations}","page":"Library API","title":"Sunny.all_exact_wave_vectors","text":"all_exact_wave_vectors(sc::SampledCorrelations; bzsize=(1,1,1))\n\nReturns all wave vectors for which sc contains exact values. bsize specifies the number of Brillouin zones to be included.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_sites-Tuple{System}","page":"Library API","title":"Sunny.all_sites","text":"all_sites(sys::System)\n\nAn iterator over all Sites in the system. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.axes_bincenters-Tuple{Any, Any, Any}","page":"Library API","title":"Sunny.axes_bincenters","text":"axes_bincenters(params::BinningParameters)\n\nReturns tick marks which label the bins of the histogram described by BinningParameters by their bin centers.\n\nThe following alternative syntax can be used to compute bin centers for a single axis:\n\naxes_bincenters(binstart,binend,binwidth)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.broaden_energy-Tuple{SampledCorrelations, Any, Function}","page":"Library API","title":"Sunny.broaden_energy","text":"broaden_energy(sc::SampledCorrelations, vals, kernel::Function; negative_energies=false)\n\nPerforms a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by intensities_interpolated. kernel must be a function that takes two numbers: kernel(œâ, œâ‚ÇÄ), where œâ is a frequency, and œâ‚ÇÄ is the center frequency of the kernel. Sunny provides lorentzian for the most common use case:\n\nnewvals = broaden_energy(sc, vals, (œâ, œâ‚ÇÄ) -> lorentzian(œâ-œâ‚ÇÄ, 0.2))\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.browser-Tuple{String}","page":"Library API","title":"Sunny.browser","text":"browser(html_str; dir)\n\nLaunch a system browser to display the provided HTML string or SunnyViewer. If a directory dir is provided, an HTML file will be written at that location.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.connected_path_bins-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Library API","title":"Sunny.connected_path_bins","text":"connected_path_bins(sc,qs,density,args...;kwargs...)\n\nTakes a list of wave vectors, qs, and builds a series of histogram BinningParameters whose first axis traces a path through the provided points. The second and third axes are integrated over according to the args and kwargs, which are passed through to slice_2D_binning_parameters.\n\nAlso returned is a list of marker indices corresponding to the input points, and a list of ranges giving the indices of each histogram x-axis within a concatenated histogram. The density parameter is given in samples per reciprocal lattice unit (R.L.U.).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.connected_path_from_rlu-Tuple{Crystal, Vector, Any}","page":"Library API","title":"Sunny.connected_path_from_rlu","text":"connected_path_from_rlu(cryst, qs_rlu, density)\n\nReturns a pair (path, xticks). The first return value is a path in reciprocal space that samples linearly between the wavevectors in qs_rlu. The elements in qs_rlu are defined in reciprocal lattice units (RLU) associated with the reciprocal_lattice_vectors for cryst. The sampling density between elements of qs has units of inverse length.\n\nThe second return value xticks can be used for plotting. The xticks object is itself a pair (numbers, labels), which give the locations of the interpolating q-points and labels as pretty-printed strings.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.count_bins-Tuple{Any, Any, Any}","page":"Library API","title":"Sunny.count_bins","text":"count_bins(binstart,binend,binwidth)\n\nReturns the number of bins in the binning scheme implied by binstart, binend, and binwidth. To count the bins in a BinningParameters, use params.numbins.\n\nThis function defines how partial bins are handled, so it should be used preferentially over computing the number of bins manually.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dispersion-Tuple{SpinWaveTheory, Any}","page":"Library API","title":"Sunny.dispersion","text":"dispersion(swt::SpinWaveTheory, qs)\n\nExperimental. Computes the spin excitation energy dispersion relations given a SpinWaveTheory and an array of wave vectors qs. Each element q of qs must be a 3-vector in units of reciprocal lattice units. I.e., q·µ¢ is given in 2œÄa·µ¢ with a·µ¢ the lattice constant of the chemical lattice.\n\nThe first indices of the returned array correspond to those of qs. A final index, corresponding to mode, is added to these. Each entry of the array is an energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dmvec-Tuple{Any}","page":"Library API","title":"Sunny.dmvec","text":"dmvec(D)\n\nAntisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,\n\n  [  0    D[3] -D[2]\n   -D[3]   0    D[1]\n    D[2] -D[1]   0  ]\n\nUseful in the context of set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dssf-Tuple{SpinWaveTheory, Any}","page":"Library API","title":"Sunny.dssf","text":"dssf(swt::SpinWaveTheory, qs)\n\nGiven a SpinWaveTheory object, computes the dynamical spin structure factor,\n\n    ùíÆ^Œ±Œ≤(ùê§ œâ) = 1(2œÄN)dt _ùê´ expi(œât - ùê§ùê´) S^Œ±(ùê´ t)S^Œ≤(0 0)\n\nusing the result from linear spin-wave theory,\n\n    ùíÆ^Œ±Œ≤(ùê§ œâ) = _n A_n^Œ±Œ≤(ùê§)^2 Œ¥œâ-œâ_n(ùê§)\n\nqs is an array of wave vectors of arbitrary dimension. Each element q of qs must be a 3-vector in reciprocal lattice units (RLU), i.e., in the basis of reciprocal lattice vectors.\n\nThe first indices of the returned array correspond to those of qs. A final index, corresponding to mode, is added to these. Each entry of this array is a tensor (3√ó3 matrix) corresponding to the indices Œ± and Œ≤.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dynamical_correlations-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.dynamical_correlations","text":"dynamical_correlations(sys::System; Œît, nœâ, œâmax, \n    process_trajectory=:none, observables=nothing, correlations=nothing)\n\nCreates a SampledCorrelations for calculating and storing ùíÆ(ùê™œâ) data. This information will be obtained by running dynamical spin simulations on equilibrium snapshots and measuring pair-correlations. The ùíÆ(ùê™œâ) data can be retrieved by calling intensities_interpolated. Alternatively, instant_intensities_interpolated will integrate out œâ to obtain ùíÆ(ùê™), optionally applying classical-to-quantum correction factors.\n\nThe SampleCorrelations that is returned will contain no correlation data. Samples are generated and accumulated by calling add_sample!(sc, sys) where sc is a SampleCorrelations and sys is an appropriately equilibrated System. Note that the sys should be thermalized before each call of add_sample! such that the spin configuration in the system represents a new (fully decorrelated) sample.\n\nThree keywords are required to specify the dynamics used for the trajectory calculation.\n\nŒît: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an ImplicitMidpoint integrator.\nœâmax: The maximum energy, œâ, that will be resolved.\nnœâ: The number of energy bins to calculated between 0 and œâmax.\n\nAdditional keyword options are the following:\n\nprocess_trajectory: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are :none and   :symmetrize. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.\nobservables: Allows the user to specify custom observables. The   observables must be given as a list of complex N√óN matrices or   LinearMaps. It's recommended to name each observable, for example:   observables = [:A => a_observable_matrix, :B => b_map, ...]. By default,   Sunny uses the 3 components of the dipole, :Sx, :Sy and :Sz.\ncorrelations: Specify which correlation functions are calculated, i.e. which   matrix elements Œ±Œ≤ of ùíÆ^Œ±Œ≤(qœâ) are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all observables. To retain only the xx and   xy correlations, one would set correlations=[(:Sx,:Sx), (:Sx,:Sy)] or   correlations=[(1,1),(1,2)].\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.enable_dipole_dipole!","text":"enable_dipole_dipole!(sys::System)\n\nEnables long-range dipole-dipole interactions,\n\n    -(Œº_04œÄ) _ij  (3 (ùêå_jùê´_ij)(ùêå_iùê´_ij) - ùêå_iùêå_j)  ùê´_ij^3\n\nwhere the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and ùêí_i is the spin angular momentum dipole in units of ƒß. The Bohr magneton Œº_B and vacuum permeability Œº_0 are physical constants, with numerical values determined by the unit system.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.energy","text":"energy(sys::System)\n\nComputes the total system energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.export_vtk-Tuple{Any, BinningParameters, Any}","page":"Library API","title":"Sunny.export_vtk","text":"export_vtk(filename,params::BinningParameters,data)\n\nExport a VTK-compatible file to filename (do not include file extension when specifying the file name) which contains the data as VTK Cell Data on a grid parameterized by params.\n\nAt least one axis of the BinningParameters must be integrated over, since VTK does not support 4D data. See integrate_axes!.\n\nBecomes available after explicitly loading VTKExport.jl, e.g., using VTKExport.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.generate_mantid_script_from_binning_parameters-Tuple{Any}","page":"Library API","title":"Sunny.generate_mantid_script_from_binning_parameters","text":"generate_mantid_script_from_binning_parameters(params::BinningParameters)\n\nGenerate a Mantid script which bins data according to the  given BinningParameters.\n\nwarning: Units\nTake care to ensure the units are correct (R.L.U. or absolute). You may want to call Sunny.bin_rlu_as_absolute_units! or Sunny.bin_absolute_units_as_rlu! first.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.global_position-Tuple{System, Any}","page":"Library API","title":"Sunny.global_position","text":"global_position(sys::System, site::Site)\n\nPosition of a Site in global coordinates.\n\nTo precompute a full list of positions, one can use all_sites as below:\n\npos = [global_position(sys, site) for site in all_sites(sys)]\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.instant_correlations-Tuple{System}","page":"Library API","title":"Sunny.instant_correlations","text":"instant_correlations(sys::System; process_trajectory=:none, observables=nothing, correlations=nothing)\n\nCreates a SampledCorrelations object for calculating and storing instantaneous structure factor intensities ùíÆ(ùê™). This data will be calculated from the spin-spin correlations of equilibrium snapshots, absent any dynamical information. ùíÆ(ùê™) data can be retrieved by calling instant_intensities_interpolated.\n\nImportant note: When dealing with continuous (non-Ising) spins, consider creating using dynamical_correlations instead of  instant_correlations. The former will provide full ùíÆ(ùê™œâ) data, from which ùíÆ(ùê™) can be obtained by integrating out œâ. During this integration step, Sunny can incorporate temperature- and œâ-dependent classical-to-quantum correction factors to produce more accurate ùíÆ(ùê™) estimates. See instant_intensities_interpolated for more information.\n\nPrior to calling instant_correlations, ensure that sys represents a good equilibrium sample. Additional sample data may be accumulated by calling add_sample!(sc, sys) with newly equilibrated sys configurations.\n\nThe following optional keywords are available:\n\nprocess_trajectory: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are :none and   :symmetrize. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.\nobservables: Allows the user to specify custom observables. The   observables must be given as a list of complex N√óN matrices or   LinearMaps. It's recommended to name each observable, for example:   observables = [:A => a_observable_matrix, :B => b_map, ...]. By default,   Sunny uses the 3 components of the dipole, :Sx, :Sy and :Sz.\ncorrelations: Specify which correlation functions are calculated, i.e. which   matrix elements Œ±Œ≤ of ùíÆ^Œ±Œ≤(qœâ) are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by all observables. To retain only the xx and   xy correlations, one would set correlations=[(:Sx,:Sx), (:Sx,:Sy)] or   correlations=[(1,1),(1,2)].\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.instant_intensities_interpolated-Tuple{SampledCorrelations, Any}","page":"Library API","title":"Sunny.instant_intensities_interpolated","text":"instant_intensities_interpolated(sc::SampledCorrelations, qs; kwargs...)\n\nReturn ùíÆ(ùê™) intensities at wave vectors qs. The functionality is very similar to intensities_interpolated, except the returned array has dimensions identical to qs. If called on a SampledCorrelations with dynamical information, i.e., ùíÆ(ùê™œâ), the œâ information is integrated out.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.integrate_axes!-Tuple{BinningParameters}","page":"Library API","title":"Sunny.integrate_axes!","text":"integrate_axes!(params::BinningParameters; axes)\n\nIntegrate over one or more axes of the histogram by setting the number of bins in that axis to 1. Examples:\n\nintegrate_axes!(params; axes = [2,3])\nintegrate_axes!(params; axes = 2)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.integrated_lorentzian-Tuple{Float64}","page":"Library API","title":"Sunny.integrated_lorentzian","text":"integrated_lorentzian(Œ∑)\n\nReturns x mapsto atan(xŒ∑)œÄ for use with intensities_binned.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_bands-Tuple{SpinWaveTheory, Any}","page":"Library API","title":"Sunny.intensities_bands","text":"dispersion, intensities = intensities_bands(swt::SpinWaveTheory, qs; [formula])\n\nComputes the scattering intensities at each energy band for each q in qs, according to Linear Spin Wave Theory and the given intensity formula. The optional formula must have a delta-function kernel, e.g.:\n\nformula = intensity_formula(swt; kernel = delta_function_kernel)\n\nor else the bands will be broadened, and their intensity can not be computed.\n\nThe outputs will be arrays with indices identical to qs, with the last index giving the band index. dispersions reports the energy of each band, while intensities reports the scattering intensity.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_binned-Tuple{SampledCorrelations, BinningParameters}","page":"Library API","title":"Sunny.intensities_binned","text":"intensity, counts = intensities_binned(sc::SampledCorrelations, params::BinningParameters; formula, integrated_kernel)\n\nGiven correlation data contained in a SampledCorrelations and BinningParameters describing the shape of a histogram, compute the intensity and normalization for each histogram bin using a given intensity_formula, or intensity_formula(sc,:perp) by default.\n\nThe BinningParameters are expected to accept (k,œâ) in absolute units.\n\nThis is an alternative to intensities_interpolated which bins the scattering intensities into a histogram instead of interpolating between them at specified qs values. See unit_resolution_binning_parameters for a reasonable default choice of BinningParameters which roughly emulates intensities_interpolated with interpolation = :round.\n\nIf a function integrated_kernel(Œîœâ) is passed, it will be used as the CDF of a kernel function for energy broadening. For example, integrated_kernel = Œîœâ -> atan(Œîœâ/Œ∑)/pi (c.f. integrated_lorentzian implements Lorentzian broadening with parameter Œ∑. Currently, energy broadening is only supported if the BinningParameters are such that the first three axes are purely spatial and the last (energy) axis is [0,0,0,1].\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_broadened-Tuple{SpinWaveTheory, Any, Any, Any}","page":"Library API","title":"Sunny.intensities_broadened","text":"intensities_broadened(swt::SpinWaveTheory, qs, œâvals, formula)\n\nComputes the scattering intensities at each (Q,œâ) according to Linear Spin Wave Theory and the given intensity formula. The required formula must have a non-delta-function kernel, e.g.:\n\nformula = intensity_formula(swt; kernel = lorentzian(0.05))\n\nor else the intensity at œâvals which are not exactly on the dispersion curve can not be calculated.\n\nThe intensity is computed at each wave vector in qs and each energy in œâvals. The output will be an array with indices identical to qs, with the last index matching œâvals.\n\nNote that qs is an array of wave vectors of arbitrary dimension. Each element q of qs must be a 3-vector in reciprocal lattice units. I.e., q·µ¢ is given in 2œÄa·µ¢ with a·µ¢ the lattice constant of the chemical lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities_interpolated-Tuple{SampledCorrelations, Any}","page":"Library API","title":"Sunny.intensities_interpolated","text":"intensities_interpolated(sc::SampledCorrelations, qs; interpolation=nothing,\n                         formula=intensity_formula(sc,:perp), negative_energies=false)\n\nThe basic function for retrieving ùíÆ(ùê™œâ) information from a SampledCorrelations. Maps an array of wave vectors qs to an array of structure factor intensities, including an additional energy index. The values of œâ associated with the energy index can be retrieved by calling œâs. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.\n\ninterpolation: Since ùíÆ(ùê™ œâ) is calculated on a finite lattice, data   is only available at discrete wave vectors. By default, Sunny will round a   requested q to the nearest available wave vector. Linear interpolation can   be applied by setting interpolation=:linear.\nnegative_energies: If set to true, Sunny will return the periodic   extension of the energy axis. Most users will not want this.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, AbstractVector{Int64}}","page":"Library API","title":"Sunny.intensity_formula","text":"formula = intensity_formula(sc::SampledCorrelations)\n\nEstablish a formula for computing the intensity of the discrete scattering modes (q,œâ) using the correlation data ùíÆ^Œ±Œ≤(qœâ) stored in the SampledCorrelations. The formula returned from intensity_formula can be passed to intensities_interpolated or intensities_binned.\n\nintensity_formula(sc,...; kT = Inf, formfactors = ...)\n\nThere are keyword arguments providing temperature and form factor corrections:\n\nkT: If a temperature is provided, the intensities will be rescaled by a   temperature- and œâ-dependent classical-to-quantum factor. kT should be   specified when making comparisons with spin wave calculations or   experimental data. If kT is not specified, infinite temperature (no   correction) is assumed.\nformfactors: To apply form factor corrections, provide this keyword with a   vector of FormFactors, one for each unique site in the unit cell. The form factors   will be symmetry propagated to all equivalent sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{Function, SampledCorrelations, Any}","page":"Library API","title":"Sunny.intensity_formula","text":"A custom intensity formula can be specifed by providing a function intensity = f(q,œâ,correlations) and specifying which correlations it requires:\n\nintensity_formula(f,sc::SampledCorrelations, required_correlations; kwargs...)\n\nThe function is intended to be specified using do notation. For example, this custom formula sums the off-diagonal correlations:\n\nrequired = [(:Sx,:Sy),(:Sy,:Sz),(:Sx,:Sz)]\nintensity_formula(sc,required,return_type = ComplexF64) do k, œâ, off_diagonal_correlations\n    sum(off_diagonal_correlations)\nend\n\nIf your custom formula returns a type other than Float64, use the return_type keyword argument to flag this.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{SpinWaveTheory, Symbol}","page":"Library API","title":"Sunny.intensity_formula","text":"intensity_formula([swt or sc], contraction_mode::Symbol)\n\nSunny has several built-in formulas that can be selected by setting contraction_mode to one of these values:\n\n:perp (default), which contracts ùíÆ^Œ±Œ≤(qœâ) with the dipole factor Œ¥_Œ±Œ≤ - q_Œ±q_Œ≤, returning the unpolarized intensity.\n:trace, which yields operatornametr ùíÆ(qœâ) = _Œ± ùíÆ^Œ±Œ±(qœâ)\n:full, which will return all elements ùíÆ^Œ±Œ≤(ùê™œâ) without contraction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_formula-Tuple{SpinWaveTheory}","page":"Library API","title":"Sunny.intensity_formula","text":"formula = intensity_formula(swt::SpinWaveTheory; kernel = ...)\n\nEstablish a formula for computing the scattering intensity by diagonalizing the hamiltonian H(q) using Linear Spin Wave Theory.\n\nIf kernel = delta_function_kernel, then the resulting formula can be used with intensities_bands.\n\nIf kernel is a broadening kernel function, then the resulting formula can be used with intensities_broadened.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Library API","title":"Sunny.lattice_params","text":"lattice_params(latvecs::Mat3)\n\nCompute the lattice parameters (a b c Œ± Œ≤ Œ≥) for the three lattice vectors provided as columns of latvecs. The inverse mapping is lattice_vectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_vectors-NTuple{6, Any}","page":"Library API","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Œ± Œ≤ Œ≥) in degrees. The inverse mapping is lattice_params.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.load_nxs-Tuple{Any}","page":"Library API","title":"Sunny.load_nxs","text":"params, signal = load_nxs(filename)\n\nGiven the name of a Mantid-exported MDHistoWorkspace file, load the BinningParameters and the signal from that file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lorentzian-Tuple{Any, Any}","page":"Library API","title":"Sunny.lorentzian","text":"lorentzian(x, Œ∑)\n\nReturns Œ∑(œÄ(x^2 + Œ∑^2)).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.magnetic_moment-Tuple{System, Any}","page":"Library API","title":"Sunny.magnetic_moment","text":"magnetic_moment(sys::System, site::Site)\n\nGet the magnetic moment for a Site. This is the spin dipole multiplied by the Bohr magneton and the local g-tensor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.merge!-Tuple{SampledCorrelations, Vararg{Any}}","page":"Library API","title":"Sunny.merge!","text":"merge!(sc::SampledCorrelations, others...)\n\nAccumulate the samples in others (one or more SampledCorrelations) into sc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.minimize_energy!-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.minimize_energy!","text":"minimize_energy!(sys::System{N}; maxiters=100, subiters=20,\n                 method=Optim.ConjugateGradient(), kwargs...) where N\n\nOptimizes the spin configuration in sys to minimize energy. A total of maxiters iterations will be attempted, with restarts after every subiters iterations. The remaining kwargs will be forwarded to the optimize method of the Optim.jl package.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.plot_spins-Tuple{System}","page":"Library API","title":"Sunny.plot_spins","text":"plot_spins(sys::System; linecolor=:grey, arrowcolor=:red, linewidth=0.1,\n                            arrowsize=0.3, arrowlength=1.0, kwargs...)\n\nPlot the spin configuration defined by sys. kwargs are passed to Makie.arrows.   \n\nBecomes available after explicitly loading Makie, e.g., using GLMakie or using WGLMakie.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.polarize_spins!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.polarize_spins!","text":"polarize_spins!(sys::System, dir)\n\nPolarize all spins in the system along the direction dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.position_to_site-Tuple{System, Any}","page":"Library API","title":"Sunny.position_to_site","text":"position_to_site(sys::System, r)\n\nConverts a position r to four indices of a Site. The coordinates of r are given in units of the lattice vectors for the original crystal. This function can be useful for working with systems that have been reshaped using reshape_supercell.\n\nExample\n\n# Find the `site` at the center of a unit cell which is displaced by four\n# multiples of the first lattice vector\nsite = position_to_site(sys, [4.5, 0.5, 0.5])\n\n# Print the dipole at this site\nprintln(sys.dipoles[site])\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.powder_average_binned-Tuple{SampledCorrelations, Any}","page":"Library API","title":"Sunny.powder_average_binned","text":"powder_average_binned(sc::SampledCorrelations, radial_binning_parameters; formula\n                     œâ_binning_parameters, integrated_kernel = nothing, bzsize = nothing)\n\nThis function emulates the experimental situation of \"powder averaging,\" where only the magnitude (and not the direction) of the momentum transfer is resolvable. The intensities are binned similarly to intensities_binned, but the histogram x-axis is |k| in absolute units, which is a nonlinear function of kx,ky,kz. The y-axis is energy.\n\nRadial binning parameters are specified as tuples (start,end,bin_width), e.g. radial_binning_parameters = (0,6œÄ,6œÄ/55).\n\nEnergy broadening is supported in the same way as intensities_binned, and this function accepts the same kind of intensity_formula.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_bond-Tuple{Crystal, Bond}","page":"Library API","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)\n\nPrints symmetry information for bond bond. A symmetry-equivalent reference bond b_ref can optionally be provided to fix the meaning of the coefficients A, B, ...\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_classical_spin_polynomial-Tuple{Any}","page":"Library API","title":"Sunny.print_classical_spin_polynomial","text":"function print_classical_spin_polynomial(op)\n\nPrints an operator (e.g., a linear combination of Stevens operators ùí™) as a polynomial in the classical dipole components.\n\nThis function works in the \"large-S\" classical limit, which corresponds to replacing each spin operator with its expected dipole. There are ambiguities in defining this limit at sub-leading order in S. The procedure in Sunny is as follows: First, uniquely decompose op as a linear combination of Stevens operators, each of which is defined as a polynomial in the spin operators. To take the large-S limit, Sunny replaces each Stevens operator with a corresponding polynomial in the expected dipole components, keeping only leading order terms in S. The resulting \"classical Stevens functions\" are essentially the spherical harmonics Y·µê‚Çó, up to m- and l- dependent scaling factors.\n\nExample\n\nusing DynamicPolynomials, Sunny\n\nprint_classical_spin_polynomial((1/4)ùí™[4,4] + (1/20)ùí™[4,0] + (3/5)*(ùíÆ'*ùíÆ)^2)\n# Prints: ùíÆ‚ÇÅ‚Å¥ + ùíÆ‚ÇÇ‚Å¥ + ùíÆ‚ÇÉ‚Å¥\n\nSee also print_classical_stevens_expansion for the inverse mapping.\n\nBecomes available after explicitly loading DynamicPolynomials.jl, e.g., using DynamicPolynomials.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_classical_stevens_expansion-Tuple{Any}","page":"Library API","title":"Sunny.print_classical_stevens_expansion","text":"function print_classical_stevens_expansion(op)\n\nPrints an operator (e.g. a polynomial of the spin operators ùíÆ) as a linear combination of Stevens operators. This function works in the large-S classical limit, as described in the documentation for print_classical_spin_polynomial.\n\nIn the output, the symbol X denotes the spin magnitude squared, which can be entered symbolically as ùíÆ'*ùíÆ.\n\nExamples\n\nusing DynamicPolynomials, Sunny\n\nprint_classical_stevens_expansion(ùíÆ[1]^4 + ùíÆ[2]^4 + ùíÆ[3]^4)\n# Prints: (1/20)ùí™‚ÇÑ‚ÇÄ + (1/4)ùí™‚ÇÑ‚ÇÑ + (3/5)X¬≤\n\nSee also print_classical_spin_polynomial for the inverse mapping.\n\nThe function print_stevens_expansion is analogous to this one, but expects a quantum operator in a finite-S representation.\n\nBecomes available after explicitly loading DynamicPolynomials.jl, e.g., using DynamicPolynomials.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_site-Tuple{Any, Any}","page":"Library API","title":"Sunny.print_site","text":"print_site(cryst, i; R=I)\n\nPrint symmetry information for the site i, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix R can be provided to define the reference frame for expression of the anisotropy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_stevens_expansion-Tuple{Matrix{ComplexF64}}","page":"Library API","title":"Sunny.print_stevens_expansion","text":"function print_stevens_expansion(op)\n\nPrints a local Hermitian operator as a linear combination of Stevens operators. This function works on explicit matrix representations. The analogous function in the large-S classical limit is print_classical_stevens_expansion.\n\nExamples\n\nS = spin_matrices(N=5)\nprint_stevens_expansion(S[1]^4 + S[2]^4 + S[3]^4)\n# Prints: (1/20)ùí™‚ÇÑ‚ÇÄ + (1/4)ùí™‚ÇÑ‚ÇÑ + 102/5\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_suggested_frame-Tuple{Crystal, Int64}","page":"Library API","title":"Sunny.print_suggested_frame","text":"print_suggested_frame(cryst, i; digits=4)\n\nPrint a suggested reference frame, as a rotation matrix R, that can be used as input to print_site(). This is useful to simplify the description of allowed anisotropies.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_symmetry_table-Tuple{Crystal, Any}","page":"Library API","title":"Sunny.print_symmetry_table","text":"print_symmetry_table(cryst::Crystal, max_dist)\n\nPrint symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist), where Bond(i, i, [0,0,0]) refers to a single site i.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_wrapped_intensities-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.print_wrapped_intensities","text":"print_wrapped_intensities(sys::System; nmax=10)\n\nFor Bravais lattices: Prints up to nmax wavevectors according to their instantaneous (static) structure factor intensities, listed in descending order. For non-Bravais lattices: Performs the same analysis for each spin sublattice independently; the output weights are na√Øvely averaged over sublattices, without incorporating phase shift information. Only wavevectors within the first Brillouin zone are printed. Wavevector coordinates are given in reciprocal lattice units, such that each coordinate is between -12 and 12.  The output from this function will typically be used as input to suggest_magnetic_supercell.\n\nBecause this function does not incorporate phase information in its averaging over sublattices, the printed weights are not directly comparable with experiment. For that purpose, use instant_correlations instead.\n\nThe weights printed by print_wrapped_intensities may be given a physical interpretation as follows: All possible q-vectors are periodically wrapped into the first Brillouin zone, and the average over their corresponding instantaneous structure factor intensities produce the output weights.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_delta-Tuple{Any}","page":"Library API","title":"Sunny.propose_delta","text":"propose_delta(magnitude)\n\nGenerate a proposal function that adds a Gaussian perturbation to the existing spin state. In :dipole mode, the procedure is to first introduce a random three-vector perturbation ùê¨ = ùê¨ + ùê¨ Œæ and then return the properly normalized spin ùê¨ (ùê¨ùê¨). Each component of the random vector Œæ is Gaussian distributed with a standard deviation of magnitude; the latter is dimensionless and typically smaller than one. \n\nIn :SUN mode, the procedure is analogous, but now involving Gaussian perturbations to each of the N complex components of an SU(N) coherent state.\n\nIn the limit of very large magnitude, this function coincides with propose_uniform.\n\nFor use with LocalSampler.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.propose_flip","text":"propose_flip\n\nFunction to propose pure spin flip updates in the context of a LocalSampler. Dipoles are flipped as ùê¨  -ùê¨. SU(N) coherent states are flipped using the time-reversal operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_uniform","page":"Library API","title":"Sunny.propose_uniform","text":"propose_uniform\n\nFunction to propose a uniformly random spin update in the context of a LocalSampler. In :dipole mode, the result is a random three-vector with appropriate normalization. In :SUN mode, the result is a random SU(N) coherent state with appropriate normalization.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.randomize_spins!-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.randomize_spins!","text":"randomize_spins!(sys::System)\n\nRandomizes all spins under appropriate the uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reciprocal_lattice_vectors-Tuple{Crystal}","page":"Library API","title":"Sunny.reciprocal_lattice_vectors","text":"reciprocal_lattice_vectors(cryst::Crystal)\n\nReturns the 33 matrix (ùêõ‚ÇÅùêõ‚ÇÇùêõ‚ÇÉ) with columns ùêõ·µ¢ as reciprocal lattice vectors. These are defined to satisfy ùêõ·µ¢ùêö‚±º = 2œÄŒ¥·µ¢‚±º, where (ùêö‚ÇÅùêö‚ÇÇùêö‚ÇÉ) are the lattice vectors used to construct cryst.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reference_bonds-Tuple{Crystal, Float64}","page":"Library API","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.remove_periodicity!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.remove_periodicity!","text":"remove_periodicity!(sys::System, dims)\n\nRemove periodic interactions along the dimensions where dims is true. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nExample\n\n# Remove periodic boundaries along the 1st and 3rd dimensions\nremove_periodicity!(sys::System, (true, false, true))\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.repeat_periodically","text":"repeat_periodically(sys::System{N}, counts) where N\n\nCreates a System identical to sys but repeated a given number of times in each dimension, specified by the tuple counts.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reshape_supercell-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.reshape_supercell","text":"reshape_supercell(sys::System, A)\n\nMaps an existing System to a new one that has the shape and periodicity of a requested supercell. The columns of the 33 integer matrix A represent the supercell lattice vectors measured in units of the original crystal lattice vectors.\n\nThe crystal unit cell may also need to be reshaped to achieve the desired periodicity of the requested supercell. If this is the case, the returned System object will be missing symmetry information. Consequently, certain operations will be unavailable for this system, e.g., setting interactions by symmetry propagation. In practice, one can set all interactions using the original system, and then reshape as a final step.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.resize_supercell-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.resize_supercell","text":"resize_supercell(sys::System{N}, latsize) where N\n\nCreates a System identical to sys but enlarged to a given number of unit cells in each lattice vector direction.\n\nAn error will be thrown if sys is incommensurate with latsize. Use reshape_supercell instead to reduce the volume, or to perform an incommensurate reshaping.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.rotate_operator-Tuple{Matrix, Any}","page":"Library API","title":"Sunny.rotate_operator","text":"rotate_operator(A, R)\n\nRotates the local quantum operator A according to the 33 rotation matrix R.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_coherent!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N","page":"Library API","title":"Sunny.set_coherent!","text":"set_coherent!(sys::System, Z, site::Site)\n\nSet a coherent spin state at a Site using the N complex amplitudes in Z.\n\nFor a standard SpinInfo, these amplitudes will be interpreted in the eigenbasis of ùíÆ·∂ª. That is, Z[1] represents the amplitude for the basis state fully polarized along the z-direction, and subsequent components represent states with decreasing angular momentum along this axis (m = S S-1  -S).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_dipole!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N","page":"Library API","title":"Sunny.set_dipole!","text":"set_dipole!(sys::System, dir, site::Site)\n\nPolarize the spin at a Site along the direction dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N","page":"Library API","title":"Sunny.set_exchange!","text":"set_exchange!(sys::System, J, bond::Bond; biquad=0.)\n\nSets a 3√ó3 spin-exchange matrix J along bond, yielding a pairwise interaction energy ùêí_iJ ùêí_j. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter bond has the form Bond(i, j, offset), where i and j are atom indices within the unit cell, and offset is a displacement in unit cells.\n\nThe parameter J may be scalar or matrix-valued. As a convenience, dmvec(D) can be used to construct the antisymmetric part of the exchange, where D is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be ùêÉ(ùêí_iùêí_j).\n\nThe optional parameter biquad defines the strength b for scalar biquadratic interactions of the form b (ùêí_iùêí_j)¬≤ For systems restricted to dipoles, b will be automatically renormalized for maximum consistency with the more variationally accurate SU(N) mode. This renormalization introduces also a correction to the quadratic part of the exchange.\n\nExamples\n\nusing Sunny, LinearAlgebra\n\n# An explicit exchange matrix\nJ1 = [2 3 0;\n     -3 2 0;\n      0 0 2]\nset_exchange!(sys, J1, bond)\n\n# An equivalent Heisenberg + DM exchange \nJ2 = 2*I + dmvec([0,0,3])\nset_exchange!(sys, J2, bond)\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Union{NTuple{4, Int64}, CartesianIndex{4}}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N","page":"Library API","title":"Sunny.set_exchange_at!","text":"set_exchange_at!(sys::System, J, site1::Site, site2::Site; biquad=0., offset=nothing)\n\nSets the exchange interaction along the single bond connecting two Sites, ignoring crystal symmetry. The system must support inhomogeneous interactions via to_inhomogeneous.\n\nIf the system is relatively small, the direction of the bond can be ambiguous due to possible periodic wrapping. Resolve this ambiguity by passing an explicit offset vector, in multiples of unit cells.\n\nSee also set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field!-Tuple{System, Any}","page":"Library API","title":"Sunny.set_external_field!","text":"set_external_field!(sys::System, B::Vec3)\n\nSets the external field B that couples to all spins.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field_at!-Tuple{System, Any, Any}","page":"Library API","title":"Sunny.set_external_field_at!","text":"set_external_field_at!(sys::System, B::Vec3, site::Site)\n\nSets a Zeeman coupling between a field B and a single spin. Site includes a unit cell and a sublattice index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_onsite_coupling!-Union{Tuple{N}, Tuple{System{N}, Matrix{ComplexF64}, Int64}} where N","page":"Library API","title":"Sunny.set_onsite_coupling!","text":"set_onsite_coupling!(sys::System, op::Matrix{ComplexF64}, i::Int)\n\nSet the single-ion anisotropy for the ith atom of every unit cell, as well as all symmetry-equivalent atoms. The local operator op may be constructed using spin_operators or stevens_operators.\n\nFor systems restricted to dipoles, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(N) mode.\n\nExamples\n\n# An easy axis anisotropy in the z-direction\nS = spin_operators(sys, i)\nset_onsite_coupling!(sys, -D*S[3]^3, i)\n\n# The unique quartic single-ion anisotropy for a site with cubic point group\n# symmetry\nO = stevens_operators(sys, i)\nset_onsite_coupling!(sys, O[4,0] + 5*O[4,4], i)\n\n# An equivalent expression of this quartic anisotropy, up to a constant shift\nset_onsite_coupling!(sys, 20*(S[1]^4 + S[2]^4 + S[3]^4), i)\n\nSee also spin_operators.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_onsite_coupling_at!-Union{Tuple{N}, Tuple{System{N}, Matrix{ComplexF64}, Union{NTuple{4, Int64}, CartesianIndex{4}}}} where N","page":"Library API","title":"Sunny.set_onsite_coupling_at!","text":"set_onsite_coupling_at!(sys::System, op::Matrix{ComplexF64}, site::Site)\n\nSets the single-ion anisotropy operator op for a single Site, ignoring crystal symmetry.  The system must support inhomogeneous interactions via to_inhomogeneous.\n\nSee also set_onsite_coupling!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.set_vacancy_at!","text":"set_vacancy_at!(sys::System, site::Site)\n\nMake a single site nonmagnetic. Site includes a unit cell and a sublattice index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.slice_2D_binning_parameters-Tuple{Vector{Float64}, Any, Any, Int64, Any}","page":"Library API","title":"Sunny.slice_2D_binning_parameters","text":"slice_2D_binning_parameter(sc::SampledCorrelations, cut_from_q, cut_to_q, cut_bins::Int64, cut_width::Float64; plane_normal = [0,0,1],cut_height = cutwidth)\n\nCreates BinningParameters which make a 1D cut in Q-space.\n\nThe x-axis of the resulting histogram consists of cut_bins-many bins ranging from cut_from_q to cut_to_q. The orientation of the binning in the transverse directions is determined automatically using plane_normal. The width of the bins in the transverse direciton is controlled by cut_width and cut_height.\n\nIf the cut is too narrow, there will be very few scattering vectors per bin, or the number per bin will vary substantially along the cut. If the output appears under-resolved, try increasing cut_width.\n\nThe four axes of the resulting histogram are:\n\nAlong the cut\nFist transverse Q direction\nSecond transverse Q direction\nEnergy\n\nThis function can be used without reference to a SampledCorrelations using this alternate syntax to manually specify the bin centers for the energy axis:\n\nslice_2D_binning_parameter(œâ_bincenters, cut_from, cut_to,...)\n\nwhere œâ_bincenters specifies the energy axis, and both cut_from and cut_to are arbitrary covectors, in any units.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.spherical_shell-Tuple{Any}","page":"Library API","title":"Sunny.spherical_shell","text":"spherical_shell(radius; density=0.0, minpoints=0, maxpoints=typemax(Int64))\n\nSample points on a sphere of given radius, with given sample density. Bounds on the number of sample points may be provided with minpoints and maxpoints.\n\nThe points are generated by mapping a Fibonacci lattice onto a sphere. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.spin_matrices-Tuple{}","page":"Library API","title":"Sunny.spin_matrices","text":"spin_matrices(; N)\n\nConstructs the three spin operators, i.e. the generators of SU(2), in the N-dimensional irrep. See also spin_operators, which determines the appropriate value of N for a given site index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.spin_operators-Union{Tuple{N}, Tuple{System{N}, Int64}} where N","page":"Library API","title":"Sunny.spin_operators","text":"spin_operators(sys, i::Int)\nspin_operators(sys, site::Int)\n\nReturns the three spin operators appropriate to an atom or Site index. Each is an NN matrix of appropriate dimension N.\n\nSee also print_stevens_expansion.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.step!","page":"Library API","title":"Sunny.step!","text":"step!(sys::System, dynamics)\n\nAdvance the spin configuration one dynamical time-step. The dynamics object may be a continuous spin dynamics, such as Langevin or ImplicitMidpoint, or it may be a discrete Monte Carlo sampling scheme such as LocalSampler.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.stevens_operators-Union{Tuple{N}, Tuple{System{N}, Int64}} where N","page":"Library API","title":"Sunny.stevens_operators","text":"stevens_operators(sys, i::Int)\nstevens_operators(sys, site::Int)\n\nReturns a generator of Stevens operators appropriate to an atom or Site index. The return value O can be indexed as O[k,q], where 0  k  6 labels an irrep and q = -k  k. This will produce an NN matrix of appropriate dimension N.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N","page":"Library API","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}","page":"Library API","title":"Sunny.suggest_magnetic_supercell","text":"suggest_magnetic_supercell(qs, latsize)\n\nSuggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors in qs. An upper bound for the supercell is given by latsize, which is measured in units of lattice vectors, and must be commensurate with the wavevectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.symmetry_equivalent_bonds-Tuple{System, Bond}","page":"Library API","title":"Sunny.symmetry_equivalent_bonds","text":"symmetry_equivalent_bonds(sys::System, bond::Bond)\n\nGiven a Bond for the original (unreshaped) crystal, return all symmetry equivalent bonds in the System. Each returned bond is represented as a pair of Sites, which may be used as input to set_exchange_at!. Reverse bonds are not included (no double counting).\n\nExample\n\nfor (site1, site2, offset) in symmetry_equivalent_bonds(sys, bond)\n    @assert site1 < site2\n    set_exchange_at!(sys, J, site1, site2; offset)\nend\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.to_inhomogeneous","text":"to_inhomogeneous(sys::System)\n\nReturns a copy of the system that allows for inhomogeneous interactions, which can be set using set_onsite_coupling_at!, set_exchange_at!, and set_vacancy_at!.\n\nInhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.unit_resolution_binning_parameters-Tuple{Any, Any, Vararg{Any}}","page":"Library API","title":"Sunny.unit_resolution_binning_parameters","text":"unit_resolution_binning_parameters(sc::SampledCorrelations)\n\nCreate BinningParameters which place one histogram bin centered at each possible (q,œâ) scattering vector of the crystal. This is the finest possible binning without creating bins with zero scattering vectors in them.\n\nThis function can be used without reference to a SampledCorrelations using an alternate syntax to manually specify the bin centers for the energy axis and the lattice size:\n\nunit_resolution_binning_parameters(œâ_bincenters,latsize,[reciprocal lattice vectors])\n\nThe last argument may be a 3x3 matrix specifying the reciprocal lattice vectors, or any of these objects:\n\nCrystal\nSystem\nSampledCorrelations\nSpinWaveTheory\n\nLastly, binning parameters for a single axis may be specifed by their bin centers:\n\n(binstart,binend,binwidth) = unit_resolution_binning_parameters(bincenters::Vector{Float64})\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.view_crystal-Tuple{Crystal, Real}","page":"Library API","title":"Sunny.view_crystal","text":"view_crystal(crystal::Crystal, max_dist::Real)\n\nCreate and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using browser().\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.œâs-Tuple{SampledCorrelations}","page":"Library API","title":"Sunny.œâs","text":"œâs(sc::SampledCorrelations; negative_energies=false)\n\nReturn the œâ values for the energy index of a SampledCorrelations. By default, only returns values for non-negative energies, which corresponds to the default output of intensities. Set negative_energies to true to retrieve all œâ values.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.@mix_proposals-Tuple","page":"Library API","title":"Sunny.@mix_proposals","text":"@mix_proposals weight1 propose1 weight2 propose2 ...\n\nMacro to generate a proposal function that randomly selects among the provided functions according to the provided probability weights. For use with LocalSampler.\n\nExample\n\n# A proposal function that proposes a spin flip 40% of the time, and a\n# Gaussian perturbation 60% of the time.\n@mix_proposals 0.4 propose_flip 0.6 propose_delta(0.2)\n\n\n\n\n\n","category":"macro"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/#Overview","page":"Structure Factor Calculations","title":"Overview","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The dynamical structure factor is of fundamental importance for characterizing a magnetic system, and facilitates quantitative comparison between theory and experimental scattering data.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider, for example, a two-point dynamical spin correlation function, s^Œ±(ùê±+Œîùê± t+Œît) s^Œ≤(ùê± t). Here s^Œ±(ùê± t) represents the time dynamics of a spin dipole component Œ± at position ùê±, and brackets represent an average over equilibrium initial conditions and over (ùê± t). The dynamical structure factor is defined as the Fourier transform of this two-point correlation in both space and time, up to an overall scaling factor. Using the convolution theorem, the result is,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = frac1V s^Œ±(ùê™ œâ)^ast s^Œ≤(ùê™ œâ) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"with V the system volume. We will restrict attention to lattice systems with periodic boundaries.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider a crystal unit cell defined by three lattice vectors ùêö_1 ùêö_2 ùêö_3, and linear system sizes L_1 L_2 L_3 measured in unit cells. The allowed momentum vectors take on discrete values ùê™ = sum_Œ±=1^3 m_Œ± ùêõ_Œ±  L_Œ±, where m_Œ± are an integers and the reciprocal lattice vectors ùêõ_Œ± are defined to satisfy ùêö_Œ±  ùêõ_Œ≤ = 2œÄ Œ¥_Œ±Œ≤. For a Bravais lattice, ùê™ will be periodic in the first Brillouin zone, i.e., under any shift ùê™  ùê™  ùêõ_Œ±. More generally, consider a non-Bravais lattice such that each unit cell may contain multiple spins. By partitioning spins s_j(ùê±t) according to their sublattice index j, the relevant momenta ùê™ remain discretized as above, but now periodicity in the first Brillouin zone is lost. The structure factor may be written as a phase-average over the displacements between sublattices ùê´_jk,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = _jk e^i ùê´_jk  ùê™ ùíÆ^Œ±Œ≤_jk(ùê™ œâ) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"From a theoretical perspective, the quantity","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = frac1V s_j^Œ±(ùê™ œâ)^ast s_k^Œ≤(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"is fundamental. For each sublattice j, the data s_j^Œ±(ùê™ œâ) can be efficiently obtained by fast Fourier tranformation of a real space configuration s_j^Œ±(ùê± t). Internally, Sunny will calculate and store the discrete ùíÆ^Œ±Œ≤_jk(ùê™ œâ) correlation data, and use this to construct ùíÆ^Œ±Œ≤(ùê™œâ) intensities that can be compared with experiment.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Calculating this structure factor involves several steps, with various possible settings. Sunny provides a number of tools to facilitate this calculation and to extract information from the results. These tools are briefly outlined below. Please see the Examples for a \"real life\" use case. Detailed function information is available in the Library API.","category":"page"},{"location":"structure-factor/#Estimating-stucture-factors-with-classical-dynamics","page":"Structure Factor Calculations","title":"Estimating stucture factors with classical dynamics","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Classical dynamics may be used to estimate structure factor data by analyzing the spin-spin correlations of dynamical trajectories. This is fundamentally a Monte Carlo approach, as the trajectories must be started from an initial spin configuration that is sampled at thermal equilibrium. (Note that it is not possible to estimate a true T=0 dynamical structure factor using this method, but the temperature may be very low.) Samples are accumulated into a SampledCorrelations, from which intensity information may be extracted. The user does not typically build their own SampledCorrelations but instead initializes one by calling either dynamical_correlations or instant_correlations, as described below.","category":"page"},{"location":"structure-factor/#Estimating-a-dynamical-structure-factor:-ùíÆ(ùê™,œâ)","page":"Structure Factor Calculations","title":"Estimating a dynamical structure factor: ùíÆ(ùê™œâ)","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A SampledCorrelations for estimating the dynamical structure factor, ùíÆ^Œ±Œ≤(ùê™œâ), may be created by calling dynamical_correlations. This requires three keyword arguments. These will determine the dynamics used to calculate samples and, consequently, the œâ information that will be available. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Œît: Determines the step size used for simulating the dynamics. A smaller number will require proportionally more calculation time. While a smaller Œît will enable the resolution of higher energies, Œît is typically selected to ensure numerical stability rather than to maximize the largest œâ value. A safe choice is to use the smaller value of Œît = 0.1/(J* S^2) or Œît = 0.1/(D * S), where S is magnetic moment of the largest local spin (as specified in SpinInfo), J is the parameter governing the largest bilinear interaction (e.g. exchange), and D is the parameter governing the largest single-site term of the Hamiltonian (e.g., anisotropy or Zeeman term).\nœâmax: Sets the maximum resolved energy. Note that this is not independent of Œît. If œâmax too large, Sunny will throw an error and ask you to choose a smaller Œît. \nnœâ: Determines the number of energy bins to resolve. A larger number will require more calculation time.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A sample may be added by calling add_sample!(sc, sys). The input sys must be a spin configuration in good thermal equilibrium, e.g., using the continuous Langevin dynamics or using single spin flip trials with LocalSampler. The statistical quality of the ùíÆ^Œ±Œ≤(ùê™œâ) can be improved by repeatedly generating decorrelated spin configurations in sys and calling add_sample! on each configuration.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The outline of typical use case might look like this:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"# Make a `SampledCorrelations`\nsc = dynamical_correlations(sys; Œît=0.05, œâmax=10.0, nœâ=100) \n\n# Add samples\nfor _ in 1:nsamples\n   decorrelate_system(sys) # Perform some type of Monte Carlo simulation\n   add_sample!(sc, sys)    # Use spins to calculate trajectory and accumulate new sample of ùíÆ(ùê™,œâ)\nend","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The calculation may be configured in a number of ways; see the dynamical_correlations documentation for a list of all keywords.","category":"page"},{"location":"structure-factor/#Estimating-an-instantaneous-(\"static\")-structure-factor:-ùíÆ(ùê™)","page":"Structure Factor Calculations","title":"Estimating an instantaneous (\"static\") structure factor: ùíÆ(ùê™)","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Sunny provides two methods for calculating instantaneous, or static, structure factors: ùíÆ^Œ±Œ≤(ùê™). The first involves calculating spatial spin-spin correlations at single time slices. The second involves calculating a dynamic structure factor first and integrating out the œâ information. The advantage of the latter approach is that it enables application of an œâ-dependent classical-to-quantum rescaling of structure factor intensities, a method that should be preferred whenever comparing results to experimental data or spin wave calculations. A disadvantage of this approach is that it is computationally more expensive. There are also many cases when it is not straightforward to calculate a meaningful dynamics, as when working with Ising spins. In this section we will discuss how to calculate instantaneous structure factors from static spin configurations. Information about calculating instantaneous data from a dynamical correlations can be found in the following section.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic usage for the instantaneous case is very similar to the dynamic case, except one calls instant_correlations instead of dynamical_correlations to configure a SampledCorrelations. Note that there are no required keywords as there is no need to specify any dynamics. instant_correlations will return a SampledCorrelations containing no data. Samples may be added by calling add_sample!(sc, sys), where sc is the SampledCorrelations. When performing a finite-temperature calculation, it is important to ensure that the spin configuration in the sys represents a good equilibrium sample, as in the dynamical case. Note, however, that we recommend calculating instantaneous correlations at finite temperature calculations by using full dynamics (i.e., using dynamical_correlations) and then integrating out the energy axis. An approach to doing this is described in the next section.","category":"page"},{"location":"structure-factor/#Extracting-information-from-correlation-data","page":"Structure Factor Calculations","title":"Extracting information from correlation data","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic function for extracting information from a SampledCorrelations at a particular wave vector, ùê™, is intensities_interpolated. It takes a SampledCorrelations and a list of wave vectors. For example, intensities_interpolated(sf, [[0.0, 0.5, 0.5]]) will calculate intensities for the wavevector ùê™ = (ùêõ_2 + ùêõ_3)2. The keyword argument formula can be used to specify an intensity_formula for greater control over the intensity calculation. The default formula performs a contraction of ùíÆ^Œ±Œ≤(ùê™œâ) that includes polarization corrections. intensities_interpolated returns a list of nœâ elements at each wavevector. The corresponding œâ values can be retrieved by calling œâs on sf.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Since Sunny currently only calculates the structure factor on a finite lattice, it is important to realize that exact information is only available at a discrete set of wave vectors. Specifically, for each axis index i, we will get information at q_i = fracnL_i, where n runs from (frac-L_i2+1) to fracL_i2 and L_i is the linear dimension of the lattice used for the calculation. If you request a wave vector that does not fall into this set, Sunny will automatically round to the nearest ùê™ that is available. If intensities_interpolated is given the keyword argument interpolation=:linear, Sunny will use trilinear interpolation to determine a result at the requested wave vector. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve the intensities at all wave vectors for which there is exact data, first call the function all_exact_wave_vectors to generate a list of qs. This takes an optional keyword argument bzsize, which must be given a tuple of three integers specifying the number of Brillouin zones to calculate, e.g., bzsize=(2,2,2). The resulting list of wave vectors may then be passed to intensities_interpolated.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Alternatively, intensities_binned can be used to place the exact data into histogram bins for comparison with experiment.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The convenience function connected_path_from_rlu returns a list of wavevectors sampled along a path that connects specified ùê™ points. This list can be used as an input to intensities. Another convenience method, spherical_shell will provide a list of wave vectors on a sphere of a specified radius. This is useful for powder averaging. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A number of arguments for intensity_formula are available which modify the calculation of structure factor intensity. It is generally recommended to provide a value of kT corresponding to the temperature of sampled configurations. Given kT, Sunny will include an energy- and temperature-dependent classical-to-quantum  rescaling of intensities in the formula.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve intensity data from a instantaneous structure factor, use instant_intensities_interpolated, which accepts similar arguments to intensities_interpolated. This function may also be used to calculate instantaneous information from a dynamical structure factor, i.e. from a SampledCorrelations created with dynamical_correlations. Note that it is important to supply a value to kT to reap the benefits of this approach over simply calculating a static structure factor at the outset. ","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"EditURL = \"../../../examples/fei2_tutorial.jl\"","category":"page"},{"location":"examples/fei2_tutorial/#Case-Study:-FeI_{2}","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"FeI_2 is an effective spin-1 material with strong single-ion anisotropy. Quadrupolar fluctuations give rise to a single-ion bound state that cannot be described by a dipole-only model. This tutorial illustrates how to use the classical dynamics of SU(N) coherent state to model the magnetic behavior in FeI_2. The original study was performed in Bai et al., Nature Physics 17, 467‚Äì472 (2021).","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_crystal.jpg\" style=\"float: left;\" width=\"400\">","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The Fe atoms are arranged in stacked triangular layers. The effective spin interactions include various anisotropic exchange interactions, and a strong single-ion anisotropy:","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"mathcalH=sum_(ij) J^alphabeta_ij S^alpha_i S^beta_j - Dsum_i left(S^zright)^2","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"We will formulate this Hamiltonian in Sunny and then calculate its dynamic structure factor.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Begin by importing Sunny and GLMakie, a plotting package.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"using Sunny, GLMakie","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"If you see an error Package <X> not found in current path, add the package by typing ] add <X> at the Julia prompt.","category":"page"},{"location":"examples/fei2_tutorial/#Crystals-and-symmetry-analysis","page":"Case Study: FeI_2","title":"Crystals and symmetry analysis","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A Crystal describes the crystallographic unit cell and will usually be loaded from a .cif file. Here, we instead build a crystal by listing all atoms and their types.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"a = b = 4.05012  # Lattice constants for triangular lattice\nc = 6.75214      # Spacing in the z-direction\n\nlatvecs = lattice_vectors(a, b, c, 90, 90, 120) # A 3x3 matrix of lattice vectors that\n                                                 # define the conventional unit cell\npositions = [[0,0,0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]  # Positions of atoms in fractions\n                                                         # of lattice vectors\ntypes = [\"Fe\", \"I\", \"I\"]\nFeI2 = Crystal(latvecs, positions; types)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Observe that Sunny inferred the space group, 'P -3 m 1' (164) and labeled the atoms according to their point group symmetries.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Only the Fe atoms are magnetic, so we discard the I ions using subcrystal.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"cryst = subcrystal(FeI2, \"Fe\")","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Importantly, cryst retains the spacegroup symmetry of the full FeI_2 crystal. This information will be used, for example, to propagate exchange interactions between symmetry-equivalent bonds.","category":"page"},{"location":"examples/fei2_tutorial/#Spin-systems","page":"Case Study: FeI_2","title":"Spin systems","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"To simulate a system of many spins, construct a System.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys = System(cryst, (4,4,4), [SpinInfo(1, S=1, g=2)], :SUN, seed=2)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The system includes 444 unit cells, i.e. 64 Fe atoms, each with spin S=1 and a g-factor of 2. Quantum mechanically, spin S=1 involves a superposition of 2S+1=3 distinct angular momentum states. In :SUN mode, this superposition will be modeled explicitly using the formalism of SU(3) coherent states, which captures both dipolar and quadrupolar fluctuations. For the more traditional dipole dynamics, use :dipole mode instead.","category":"page"},{"location":"examples/fei2_tutorial/#Interactions-and-anisotropies","page":"Case Study: FeI_2","title":"Interactions and anisotropies","text":"","category":"section"},{"location":"examples/fei2_tutorial/#Symmetry-analysis","page":"Case Study: FeI_2","title":"Symmetry analysis","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The next step is to add interactions to the system. The command print_symmetry_table shows all symmetry-allowed interactions up to a cutoff distance.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"print_symmetry_table(cryst, 8.0)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The allowed g-tensor is expressed as a 3√ó3 matrix in the free coefficients A, B, ... The allowed single-ion anisotropy is expressed as a linear combination of Stevens operators. The latter correspond to polynomials of the spin operators, as we will describe below.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The allowed exchange interactions are given as a 3√ó3 matrix for representative bonds. The notation Bond(i, j, n) indicates a bond between atom indices i and j, with cell offset n. In the general case, it will be necessary to associate atom indices with their positions in the unit cell; these can be viewed with display(cryst). Note that the order of the pair (i j) is significant if the exchange tensor contains antisymmetric Dzyaloshinskii‚ÄìMoriya (DM) interactions.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In the case of FeI_2, Bond(1, 1, [1,0,0]) is one of the 6 nearest-neighbor Fe-Fe bonds on a triangular lattice layer, and Bond(1, 1, [0,0,1]) is an Fe-Fe bond between layers.","category":"page"},{"location":"examples/fei2_tutorial/#Assigning-interactions-and-anisotropies","page":"Case Study: FeI_2","title":"Assigning interactions and anisotropies","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function set_exchange! assigns an exchange interaction to a bond, and will propagate the interaction to all symmetry-equivalent bonds in the unit cell. The FeI_2 interactions below follow Bai et al.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"J1pm   = -0.236\nJ1pmpm = -0.161\nJ1zpm  = -0.261\nJ2pm   = 0.026\nJ3pm   = 0.166\nJ‚Ä≤0pm  = 0.037\nJ‚Ä≤1pm  = 0.013\nJ‚Ä≤2apm = 0.068\n\nJ1zz   = -0.236\nJ2zz   = 0.113\nJ3zz   = 0.211\nJ‚Ä≤0zz  = -0.036\nJ‚Ä≤1zz  = 0.051\nJ‚Ä≤2azz = 0.073\n\nJ1xx = J1pm + J1pmpm\nJ1yy = J1pm - J1pmpm\nJ1yz = J1zpm\n\nset_exchange!(sys, [J1xx   0.0    0.0;\n                    0.0    J1yy   J1yz;\n                    0.0    J1yz   J1zz], Bond(1,1,[1,0,0]))\nset_exchange!(sys, [J2pm   0.0    0.0;\n                    0.0    J2pm   0.0;\n                    0.0    0.0    J2zz], Bond(1,1,[1,2,0]))\nset_exchange!(sys, [J3pm   0.0    0.0;\n                    0.0    J3pm   0.0;\n                    0.0    0.0    J3zz], Bond(1,1,[2,0,0]))\nset_exchange!(sys, [J‚Ä≤0pm  0.0    0.0;\n                    0.0    J‚Ä≤0pm  0.0;\n                    0.0    0.0    J‚Ä≤0zz], Bond(1,1,[0,0,1]))\nset_exchange!(sys, [J‚Ä≤1pm  0.0    0.0;\n                    0.0    J‚Ä≤1pm  0.0;\n                    0.0    0.0    J‚Ä≤1zz], Bond(1,1,[1,0,1]))\nset_exchange!(sys, [J‚Ä≤2apm 0.0    0.0;\n                    0.0    J‚Ä≤2apm 0.0;\n                    0.0    0.0    J‚Ä≤2azz], Bond(1,1,[1,2,1]))","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function set_onsite_coupling! assigns a single-ion anisotropy operator. It can be constructed, e.g., from the matrices given by spin_operators or stevens_operators. Here we construct an easy-axis anisotropy along the direction hatz.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"D = 2.165\nS = spin_operators(sys, 1)\nset_onsite_coupling!(sys, -D*S[3]^2, 1)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Any anisotropy operator can be converted to a linear combination of Stevens operators with print_stevens_expansion.","category":"page"},{"location":"examples/fei2_tutorial/#Calculating-structure-factor-intensities","page":"Case Study: FeI_2","title":"Calculating structure factor intensities","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In the remainder of this tutorial, we will examine Sunny's tools for calculating the dynamical structure factor using a generalization of linear spin wave theory that captures quasi-particle excitations that include coupled dipolar and quadrupolar fluctuations.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A review of the quantum theory is provided in https://arxiv.org/abs/1307.7731. The same theory can alternatively be viewed as the quantization of a classical dynamics on SU(N) coherent states, https://arxiv.org/abs/2106.14125. Although outside the scope of this tutorial, Sunny provides support for simulating the classical SU(N) spin dynamics via a Langevin equation that generalizes the stochastic Landau-Lifshitz equation, https://arxiv.org/abs/2209.01265. This Langevin equation can be used to study equilibrium thermal fluctuations of classical SU(N) coherent states, or their non-equilibrium dynamics. Examples of the latter include relaxation of a spin glass, or the driven-dissipative dynamics of topological magnetic textures. To learn more, see the other Sunny documentation examples.","category":"page"},{"location":"examples/fei2_tutorial/#Finding-the-ground-state","page":"Case Study: FeI_2","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Begin with a random configuration and use minimize_energy! to find a configuration of the SU(3) coherent states (i.e. spin dipoles and quadrupoles) that locally minimizes energy.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"randomize_spins!(sys)\nminimize_energy!(sys);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The expected ground state for FeI_2 is an antiferrogmanetic striped phase with a period of four spins (two up, two down). Visualizing the result of optimization, however, may indicate the system got stuck in a local minimum with defects.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"plot_spins(sys; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A better understanding of the magnetic ordering can often be obtained by moving to Fourier space. The 'instant' structure factor ùíÆ(ùê™) is an experimental observable. To investigate ùíÆ(ùê™) as true 3D data, Sunny provides instant_correlations and related functions. Here, however, we will use the lighter weight function print_wrapped_intensities to get a quick understanding of the periodicities present in the spin configuration.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"print_wrapped_intensities(sys)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The precise output may vary with Sunny version due to, e.g., different floating point roundoff effects. Very likely, however, the result will be approximately consistent with the known zero-field energy-minimizing magnetic structure of FeI_2, which is single-Q. Mathematically, spontaneous symmetry breaking should select one of Q = 0 -14 14, 14 0 14, or -141414, associated with the three-fold rotational symmetry of the crystal spacegroup. In practice, however, one will frequently encounter competing \"domains\" associated with the three possible orientations of the ground state.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"If the desired ground state is already known, as with FeI_2, it could be entered by hand using set_dipole!. Alternatively, in the case of FeI_2, we could repeatedly employ the above randomization and minimization procedure until a defect-free configuration is found. Some systems will have more complicated ground states, which can be much more challenging to find. For this, Sunny provides experimental support for powerful simulated annealing via parallel tempering, but that is outside the scope of this tutorial.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Here, let's break the three-fold symmetry of FeI_2 by hand. Given one or more desired Q modes, Sunny can suggest a magnetic supercell with appropriate periodicity. Let's arbitrarily select one of the three possible ordering wavevectors, Q = 0 -14 14. Sunny suggest a corresponding magnetic supercell in units of the crystal lattice vectors.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"suggest_magnetic_supercell([[0, -1/4, 1/4]], sys.latsize)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function reshape_supercell allows an arbitrary reshaping of the system's supercell. We select the supercell appropriate to the broken-symmetry ground-state, which makes optimization much easier.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys_min = reshape_supercell(sys, [1 0 0; 0 1 -2; 0 1 2])\nrandomize_spins!(sys_min)\nminimize_energy!(sys_min)\nplot_spins(sys_min; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)","category":"page"},{"location":"examples/fei2_tutorial/#Linear-spin-wave-theory","page":"Case Study: FeI_2","title":"Linear spin wave theory","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Now that we have found the ground state for a magnetic supercell, we can immediately proceed to perform zero-temperature calculations using linear spin wave theory. We begin by instantiating a SpinWaveTheory type using the supercell.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"swt = SpinWaveTheory(sys_min);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Select a sequence of wavevectors that will define a piecewise linear interpolation in reciprocal lattice units (RLU).","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"points_rlu = [[0,0,0], [1,0,0], [0,1,0], [1/2,0,0], [0,1,0], [0,0,0]]","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function connected_path_from_rlu will linearly sample between the provided q-points with a given density. The path return value is a list of wavevectors in absolute units (inverse ‚Ñ´). The xticks return value keeps track of the locations of the special ùê™-points, and provides human-readable labels for use in plotting.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"density = 50\npath, xticks = connected_path_from_rlu(cryst, points_rlu, density);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The dispersion function defines the quasiparticle excitation energies œâ_i(ùê™) for each point ùê™ along the reciprocal space path.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"disp = dispersion(swt, path);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In addition to the band energies œâ_i(ùê™), Sunny can calculate the inelastic neutron scattering intensity I_i(ùê™) for each band i according to an intensity_formula. The default formula applies a polarization correction (1 - ùê™ùê™). Selecting delta_function_kernel specifies that we want the energy and intensity of each band individually.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"formula = intensity_formula(swt; kernel=delta_function_kernel)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function intensities_bands uses linear spin wave theory to calculate both the dispersion and intensity data for the provided path.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"disp, intensity = intensities_bands(swt, path; formula);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"These can be plotted in GLMakie.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"fig = Figure()\nax = Axis(fig[1,1]; xlabel=\"ùê™\", ylabel=\"Energy (meV)\", xticks, xticklabelrotation=œÄ/6)\nylims!(ax, 0.0, 7.5)\nxlims!(ax, 1, size(disp, 1))\nfor i in axes(disp)[2]\n    lines!(ax, 1:length(disp[:,i]), disp[:,i]; color=intensity[:,i])\nend\nfig","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"To make comparisons with inelastic neutron scattering (INS) data, it is helpful to employ an empirical broadening kernel, e.g., a lorentzian.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Œ≥ = 0.15 # width in meV\nbroadened_formula = intensity_formula(swt; kernel=lorentzian(Œ≥))","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The intensities_broadened function requires an energy range in addition to the ùê™-space path.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"energies = collect(0:0.01:10)  # 0 < œâ < 10 (meV).\nis1 = intensities_broadened(swt, path, energies, broadened_formula);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A real FeI_2 sample will exhibit competing magnetic domains associated with spontaneous symmetry breaking of the 6-fold rotational symmetry of the triangular lattice. Note that the wavevectors ùê™ and -ùê™ are equivalent in the structure factor, which leaves three distinct domain orientations, which are related by 120¬∞ rotations. Rather than rotating the spin configuration directly, on can rotate the ùê™-space path. Below, we collect and plot intensity data that is averaged over all three possible orientations.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sŒ∏, cŒ∏ = sincos(2œÄ/3)\nR = [cŒ∏ -sŒ∏ 0; sŒ∏ cŒ∏ 0; 0  0 1]  # 120¬∞ rotation about the zÃÇ axis\n\nis2 = intensities_broadened(swt, [R*q for q in path], energies, broadened_formula)\nis3 = intensities_broadened(swt, [R*R*q for q in path], energies, broadened_formula)\nis_averaged = (is1 + is2 + is3) / 3\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel=\"(H,0,0)\", ylabel=\"Energy (meV)\", xticks, xticklabelrotation=œÄ/6)\nheatmap!(ax, 1:size(is_averaged, 1), energies, is_averaged)\nfig","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"This result can be directly compared to experimental neutron scattering data from Bai et al.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/FeI2_intensity.jpg\">","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(The publication figure accidentally used a non-standard coordinate system to label the wave vectors.)","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"To get this agreement, the use of SU(3) coherent states is essential (in other words, we needed a theory of multi-flavored bosons). The lower band has large quadrupolar character, and arises from the strong easy-axis anisotropy of FeI_2. By setting mode = :SUN, the calculation captures this coupled dipole-quadrupole dynamics.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"An interesting exercise is to repeat the same study, but using mode = :dipole instead of :SUN. That alternative choice would constrain the coherent state dynamics to the space of dipoles only.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The full dynamical spin structure factor (DSSF) can be retrieved as a 33 matrix with the dssf function, for a given path of ùê™-vectors.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"disp, is = dssf(swt, path);\nnothing #hide","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The first output disp is identical to that obtained from dispersion. The second output is contains a list of 33 matrix of intensities. For example, is[q,n][2,3] yields the (yz) component of the structure factor intensity for nth mode at the qth wavevector in the path.","category":"page"},{"location":"examples/fei2_tutorial/#What's-next?","page":"Case Study: FeI_2","title":"What's next?","text":"","category":"section"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Sunny provides much more than just linear spin wave theory. Please explore the other examples in the documentation for more details. Sunny's capability to simulate the classical Langevin dynamics of SU(N) coherent states allows to incorporate finite-temperature spin fluctuations into the dynamical structure factor calculation, or to study systems under highly non-equilibrium conditions. Sunny also supports the construction of inhomogeneous systems (e.g., systems with quenched disorder) via to_inhomogeneous.","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"","category":"page"},{"location":"examples/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"This page was generated using Literate.jl.","category":"page"},{"location":"writevtk/#Volumetric-Rendering-with-ParaView","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"The 4D correlation data produced by Sunny is too high-dimensional to visualize directly. This page describes how to export 3D slices of correlation data from Sunny to the Visual ToolKit (VTK) format, which is compatible with the ParaView visualization software. ParaView supports volumetric rendering:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewrender.jpg\" style=\"margin: 30px; \" width=\"400\">","category":"page"},{"location":"writevtk/#Simulation-data","page":"Volumetric Rendering with ParaView","title":"Simulation data","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"First, generate some correlation data in Sunny. We will use a 2D lattice, since the correlation data S(Q_xQ_yomega) is  3D and can be exported in its entirety. The following code sets up the system, thermalizes it, and records the correlation data in a SampledCorrelations called dsf.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"using Sunny\n\n# Single layer 12x12 periodic square lattice\nlatsize = (12,12,1);\n\nlatvecs = lattice_vectors(8.,8.,12.,90,100,90)\npositions = [[0,0,0]]\ntypes = [\"Cu\"]\nformfactors  = [FormFactor(1,\"Cu2\")]\nxtal = Crystal(latvecs,positions;types);\n\nsys = System(xtal, latsize, [SpinInfo(1, S=1/2, g=2)], :SUN; seed=1);\n\nJ = 10.\nset_exchange!(sys,J,Bond(1,1,[1,0,0]))\nset_exchange!(sys,J,Bond(1,1,[0,1,0]))\n\nŒît = 0.01\nkT = 0.5\nlangevin = Langevin(Œît; Œª=0.5, kT=kT)\nrandomize_spins!(sys);\nfor i in 1:10_000 # Long enough to reach equilibrium\n    step!(sys, langevin)\nend \n\nœâmax=10.\n\ndsf = dynamical_correlations(sys\n                             ;Œît=Œît\n                             ,nœâ=48\n                             ,œâmax=œâmax\n                             ,process_trajectory=:symmetrize)\n\nnsamples = 10\nfor _ in 1:nsamples\n    for _ in 1:1000 \n        step!(sys, langevin)\n    end\n    add_sample!(dsf, sys)\nend","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"The default histogram BinningParameters are already integrated over the z direction because the system is 2D:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"unit_resolution_binning_parameters(dsf)","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"‚ä°    12 bins from -0.042 to +0.958 along [+1.27 dx] (Œî = 0.065)\n‚ä°    12 bins from -0.042 to +0.958 along [+1.27 dy] (Œî = 0.065)\n‚à´ Integrated from +0.000 to +0.000 along [-0.33 dx +1.88 dz] (Œî = 0.524)\n‚ä°    48 bins from -0.107 to +10.134 along [+1.00 dE] (Œî = 0.213)","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"The histogram is very oblong; it's approximately 1x1x10. To make it a nicer shape, we will rescale the energy axis to be be fractions of œâmax:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"params = unit_resolution_binning_parameters(dsf)\nscale_factor = œâmax\nparams.binend[4] /= scale_factor\nparams.binstart[4] /= scale_factor\nparams.binwidth[4] /= scale_factor\nparams.covectors[4,:] ./= scale_factor","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Doing this changes the last axis of the histogram to fit in [0,1]:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"‚ä°    49 bins from -0.011 to +1.013 along [+0.10 dE] (Œî = 0.213)","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Now that our histogram is a cube, we compute the intensity in the histogram bins using the usual intensities_binned:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"formula = intensity_formula(dsf,:trace)\nsignal, counts = intensities_binned(dsf, params; formula)\nintensity = signal ./ counts","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Now that we have our intensity data and the binning parameters, we can export to VTK format using export_vtk and move to ParaView for the visualization.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"# Importing WriteVTK enables Sunny's export-to-VTK functions\nimport WriteVTK\n\n# [1,2,4] specifies that the (x,y,z) axes in ParaView are (Qx,Qy,œâ)\nexport_vtk(\"square_lattice\", params, intensity; dims_kept = [1,2,4])\n# Writes a file square_lattice.vti in the current directory","category":"page"},{"location":"writevtk/#Loading-in-ParaView","page":"Volumetric Rendering with ParaView","title":"Loading in ParaView","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"In ParaView, use File > Open to open square_lattice.vti. This will add the file to the Pipeline Browser with a closed eye icon, indicating that the data is ready to be loaded.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"In the Properties panel, both bin_centers and data will be selected for import by default. Uncheck bin_centers because we don't need that information for the visualization. Click the green Apply button to load the data.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"By default, only the outline of the data is shown in the 3D viewport. Since we adjusted the energy axis, the outline is a 1x1x1 cube. Optionally enable the axes grid under \"View\", and customize using the adjacent edit button.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewimport.png\" style=\"margin: 30px;\" width=\"200\">","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"To enable the volumetric render:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Select \"Volume\" from the \"Representation\" drop-down menu under \"Display\".\nThe \"Coloring\" drop-down should automatically select data because it's the only data loaded.\nOpen the Color Map Editor to adjust the opacity of the fog, which may be too faint to see by default.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewvolume.png\" style=\"margin: 30px; \" width=\"400\">","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Depending on your computer and your dataset size, the volumetric rendering may be slow, but our dataset is relatively small, so the render should be fast.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"If nothing shows up at first, don't despair. Often, there are Bragg-like peaks in the correlation data which outshine everything else. To see this, enable Display Data Histogram in the Color Map Editor panel. To zoom in on the lower-intensity data, click and drag the right side handle of the opacity transfer function box to the middle a few times.","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewcolormap.png\" style=\"margin: 30px; \" width=\"200\">","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"After suitable color mapping, the dispersion curve should become visible:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"<img src=\"https://raw.githubusercontent.com/SunnySuite/Sunny.jl/main/docs/src/assets/paraviewrender.jpg\" style=\"margin: 30px; \" width=\"400\">","category":"page"},{"location":"writevtk/#Experiment-data","page":"Volumetric Rendering with ParaView","title":"Experiment data","text":"","category":"section"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"Note that since only the data and binning parameters are required for exporting to VTK, experiment data can be exported in the same way. For example, to visualize S(Q_xQ_yQ_z), do this:","category":"page"},{"location":"writevtk/","page":"Volumetric Rendering with ParaView","title":"Volumetric Rendering with ParaView","text":"# Load 4D histogram data from Mantid\nparams, signal = load_nxs(\"experiment_data.nxs\")\n\n# Integrate out the energy axis so we are 3D\nintegrate_axes!(params; axes = 4)\nsignal = sum(signal; dims = 4)\n\n# Export to ParaView\nexport_vtk(\"experiment_data_as_vtk\", params, signal)","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"EditURL = \"../../../examples/binning_tutorial.jl\"","category":"page"},{"location":"examples/binning_tutorial/#Histogram-Binning-Tutorial","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"","category":"section"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"using Sunny, GLMakie","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"This Tutorial demonstrates how to use Sunny's histogram binning capabilities (via intensities_binned). This functionality allows the simulation data produced by Sunny to be compared to experimental data produced by Inelastic Neutron Scattering (INS) in an apples-to-apples fashion. Experimental data can be loaded from a MDHistoWorkspace stored in a .nxs file by the Mantid software using load_nxs.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"For this example, we will examine the CTFD compound, which is crystallographically approximately a square lattice. We specify the crystal lattice structure of CTFD using the lattice parameters specified by","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"W Wan et al 2020 J. Phys.: Condens. Matter 32 374007 DOI 10.1088/1361-648X/ab757a","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"latvecs = lattice_vectors(8.113,8.119,12.45,90,100,90)\npositions = [[0,0,0]]\ntypes = [\"Cu\"]\nformfactors  = [FormFactor(1,\"Cu2\")]\nxtal = Crystal(latvecs,positions;types);\nnothing #hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"We will use a somewhat small periodic lattice size of 6x6x4 in order to showcase the effect of a finite lattice size.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"latsize = (6,6,4);\nnothing #hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"In this system, the magnetic lattice is the same as the chemical lattice, and there is a spin-1/2 dipole on each site.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"magxtal = xtal;\nvalS = 1/2;\nsys = System(magxtal, latsize, [SpinInfo(1, S=valS, g=2)], :dipole; seed=1);\nnothing #hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Quoted value of J = +6.19(2) meV (antiferromagnetic) between nearest neighbors on the square lattice","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"J = 6.19 # meV\ncharacteristic_energy_scale = abs(J * valS)\nset_exchange!(sys,J,Bond(1,1,[1,0,0]))\nset_exchange!(sys,J,Bond(1,1,[0,1,0]))","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Thermalize the system using the Langevin intergator. The timestep and the temperature are roughly based off the characteristic energy scale of the problem.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Œît = 0.05 / characteristic_energy_scale\nkT = 0.01 * characteristic_energy_scale\nlangevin = Langevin(Œît; Œª=0.1, kT=kT)\nrandomize_spins!(sys);\nfor i in 1:10_000 # Long enough to reach equilibrium\n    step!(sys, langevin)\nend","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"The neutron spectrometer used in the experiment had an incident neutron energy of 36.25 meV. Since this is the most amount of energy that can be deposited by the neutron into the sample, we don't need to consider energies higher than this.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"œâmax = 36.25;\nnothing #hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"We choose the resolution in energy (specified by the number of nœâ modes resolved) to be ‚âà20√ó better than the experimental resolution in order to demonstrate the effect of over-resolving in energy.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"nœâ = 480;\nsc = dynamical_correlations(sys; Œît=Œît, nœâ=nœâ, œâmax=œâmax, process_trajectory=:symmetrize)\nadd_sample!(sc, sys)","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"We re-sample from the thermal equilibrium distribution several times to increase our sample size","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"nsamples = 3\nfor _ in 1:nsamples\n    for _ in 1:8000\n        step!(sys, langevin)\n    end\n    add_sample!(sc, sys)\nend","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Since the SU(N)NY crystal has only finitely many lattice sites, there are finitely many ways for a neutron to scatter off of the sample. We can visualize this discreteness by plotting each possible Qx and Qz, for example:","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"params = unit_resolution_binning_parameters(sc)#hide\nbin_rlu_as_absolute_units!(params,sc)#hide\nlower_aabb_q, upper_aabb_q = Sunny.binning_parameters_aabb(params)#hide\nlower_aabb_cell = floor.(Int64,lower_aabb_q .* latsize .+ 1)#hide\nupper_aabb_cell = ceil.(Int64,upper_aabb_q .* latsize .+ 1)#hide\n\nQx = zeros(Float64,0)#hide\nQz = zeros(Float64,0)#hide\nfor cell in CartesianIndices(Tuple(((:).(lower_aabb_cell,upper_aabb_cell))))#hide\n    q = (cell.I .- 1) ./ latsize # q is in R.L.U.#hide\n    push!(Qx,q[1])#hide\n    push!(Qz,q[3])#hide\nend#hide\nfig = Figure()#hide\nax = Axis(fig[1,1];xlabel=\"Qx [r.l.u]\",ylabel=\"Qz [r.l.u.]\")#hide\n# Compute some scattering vectors at and around the first BZ...\nscatter!(ax,Qx,Qz)\nfig#hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"One way to display the structure factor is to create a histogram with one bin centered at each discrete scattering possibility using unit_resolution_binning_parameters to create a set of BinningParameters.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"params = unit_resolution_binning_parameters(sc)","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Since this is a 4D histogram, it further has to be integrated over two of those directions in order to be displayed. Here, we integrate over Qy and Energy using integrate_axes!:","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"integrate_axes!(params;axes = [2,4]) # Integrate over Qy (2) and E (4)","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Now that we have parameterized the histogram, we can bin our data. In addition to the BinningParameters, an intensity_formula needs to be provided to specify which dipole, temperature, and atomic form factor corrections should be applied during the intensity calculation.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"formula = intensity_formula(sc, :perp; kT, formfactors)\nintensity,counts = intensities_binned(sc, params; formula)\nnormalized_intensity = intensity ./ counts;\nnothing #hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"With the data binned, we can now plot it. The axes labels give the bin centers of each bin, as given by axes_bincenters.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"function plot_data(params) #hide\nintensity,counts = intensities_binned(sc, params; formula)#hide\nnormalized_intensity = intensity ./ counts;#hide\nbin_centers = axes_bincenters(params);\n\nfig = Figure()#hide\nax = Axis(fig[1,1];xlabel=\"Qx [r.l.u]\",ylabel=\"Qz [r.l.u.]\")#hide\nheatmap!(ax,bin_centers[1],bin_centers[3],normalized_intensity[:,1,:,1])\nscatter!(ax,Qx,Qz)\nxlims!(ax,params.binstart[1],params.binend[1])\nylims!(ax,params.binstart[3],params.binend[3])\nreturn fig#hide\n\nend#hide\n\nplot_data(params)#hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Note that some bins have no scattering vectors at all when the bin size is made too small:","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"params = unit_resolution_binning_parameters(sc)#hide\nintegrate_axes!(params;axes = [2,4])#hide\nparams.binwidth[1] /= 1.2\nparams.binwidth[3] /= 2.5\nplot_data(params)#hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Conversely, making the bins bigger doesn't break anything, but loses resolution:","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"params = unit_resolution_binning_parameters(sc)#hide\nintegrate_axes!(params;axes = [2,4])#hide\nparams.binwidth[1] *= 2\nparams.binwidth[3] *= 2\nplot_data(params)#hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Recall that while we under-resolved in Q by choosing a small lattice, we over-resolved in energy:","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"x = zeros(Float64,0)#hide\ny = zeros(Float64,0)#hide\nfor omega = œâs(sc), qx = unique(Qx)#hide\n    push!(x,qx)#hide\n    push!(y,omega)#hide\nend#hide\nax = Axis(fig[1,1];xlabel=\"Qx [r.l.u]\",ylabel=\"Energy [meV]\")#hide\nscatter!(ax,x,y)","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"Let's make a new histogram which includes the energy axis. The x-axis of the histogram will be a 1D cut from Q = [0,0,0] to Q = [1,1,0]. See slice_2D_binning_parameters.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"x_axis_bin_count = 10\ncut_width = 0.3\nparams = slice_2D_binning_parameters(sc,[0,0,0],[1,1,0],x_axis_bin_count,cut_width)","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"There are no longer any scattering vectors exactly in the plane of the cut. Instead, as described in the BinningParameters output above, the transverse Q directions are integrated over, so slightly out of plane points are included.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"We plot the intensity on a log-scale to improve visibility.","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"intensity,counts = intensities_binned(sc, params; formula)\nlog_intensity = log10.(intensity ./ counts);\nbin_centers = axes_bincenters(params);#hide\nfig = Figure()#hide\nax = Axis(fig[1,1];xlabel=\"Progress along cut [r.l.u]\",ylabel=\"Energy [meV]\")#hide\nheatmap!(ax,bin_centers[1],bin_centers[4],log_intensity[:,1,1,:])\nxlims!(ax,params.binstart[1],params.binend[1])#hide\nylims!(ax,params.binstart[4],params.binend[4])#hide\nfig#hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"By reducing the number of energy bins to be closer to the number of bins on the x-axis, we can make the dispersion curve look nicer:","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"params.binwidth[4] *= 20\nintensity,counts = intensities_binned(sc, params; formula)#hide\nlog_intensity = log10.(intensity ./ counts);#hide\nbin_centers = axes_bincenters(params);#hide\nfig = Figure()#hide\nax = Axis(fig[1,1];xlabel=\"Progress along cut [r.l.u]\",ylabel=\"Energy [meV]\")#hide\nheatmap!(ax,bin_centers[1],bin_centers[4],log_intensity[:,1,1,:])\nxlims!(ax,params.binstart[1],params.binend[1])#hide\nylims!(ax,params.binstart[4],params.binend[4])#hide\nfig#hide","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"","category":"page"},{"location":"examples/binning_tutorial/","page":"Histogram Binning Tutorial","title":"Histogram Binning Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Sunny.jl","page":"Overview","title":"Sunny.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Sunny is a package for simulating classical spin systems, including the Landau-Lifshitz dynamics of spin dipoles and its generalization to multipolar spin components. The latter is especially powerful for modeling magnetic compounds with strong single-ion anisotropy interactions.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Sunny provides the following features:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Generalized spin dynamics using SU(N) coherent states.\nAbility specify a crystal by a .cif file, or using its spacegroup symmetry.\nSymmetry analysis to classify allowed interaction terms, and to propagate them by symmetry.\nSingle-ion anisotropy at arbitrary order, which can be specified using Stevens operators or as a polynomial of spin operators.\nMonte Carlo sampling of spin configurations in thermal equilibrium.\nEwald summation for long-range dipole-dipole interactions, accelerated with the fast Fourier transform (FFT).\nEstimation of the mathcalS(mathbfq omega) dynamical structure factor data, with options for various corrections (form factor, classical-to-quantum factors, ...)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Work in progress includes:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Linear spin wave theory and its generalization to SU(N) coherent states.\nInteractive visualizations of the 3D crystals and structure factor data.\nMPI-distributed Monte Carlo sampling, including parallel tempering.","category":"page"},{"location":"quick-start/#Install-Julia-and-Sunny","page":"Quick Start","title":"Install Julia and Sunny","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Download Julia 1.8 or later. Run the Julia executable, which should open a terminal with the prompt: julia>. Load Sunny with the command:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using Sunny","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"If Sunny has not yet been installed, Julia will ask your permission to download and install it within the Julia environment.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To learn more about Julia, read our Getting Started with Julia wiki page.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For an interactive, notebook-like experience, we recommend the Julia extension for VSCode. Alternatively, the IJulia package provides Julia-enabled Jupyter notebooks.","category":"page"},{"location":"quick-start/#Example-usage","page":"Quick Start","title":"Example usage","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"At the Julia prompt, create a diamond cubic crystal using the Crystal constructor:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"crystal = Crystal(lattice_vectors(1, 1, 1, 90, 90, 90), [[0,0,0]], 227; setting=\"1\")","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The first argument defines a unit cell via the convenience function lattice_vectors. The second argument is a list of basis atom positions. The third, optional argument specifies an international spacegroup number (if it's missing, Sunny will infer a spacegroup). Arguments appearing after the semicolon ; are named. Here, we are selecting the first (out of two) setting conventions for spacegroup 227.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny outputs:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Crystal\nHM symbol 'F d -3 m' (227)\nLattice params a=1, b=1, c=1, Œ±=90¬∞, Œ≤=90¬∞, Œ≥=90¬∞\nCell volume 1\nWyckoff 8a (point group '-43m'):\n   1. [0, 0, 0]\n   2. [0.5, 0.5, 0]\n   3. [0.25, 0.25, 0.25]\n   4. [0.75, 0.75, 0.25]\n   5. [0.5, 0, 0.5]\n   6. [0, 0.5, 0.5]\n   7. [0.75, 0.25, 0.75]\n   8. [0.25, 0.75, 0.75]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Observe that Sunny filled all eight symmetry-equivalent atom positions for the diamond cubic unit cell. The coordinates are measured in units of the lattice vectors.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Alternatively, Sunny can read the crystal structure from a .cif file. Or, if a complete list of atoms is provided, Sunny can infer the spacegroup symmetry using spglib.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The crystal object can be used as an argument to other Sunny functions. For example, print_symmetry_table lists all symmetry-allowed exchange interactions up to a maximum distance,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"print_symmetry_table(crystal, 0.8)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"which prints,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Atom 1\nPosition [0, 0, 0], multiplicity 8\nAllowed g-tensor: | A  0  0 |\n                  | 0  A  0 |\n                  | 0  0  A |\nAllowed anisotropy in Stevens operators ùí™[k,q]:\n    c‚ÇÅ*(ùí™[4,0]+5ùí™[4,4]) +\n    c‚ÇÇ*(ùí™[6,0]-21ùí™[6,4])\n\nBond(1, 3, [0, 0, 0])\nDistance 0.433, coordination 4\nConnects [0, 0, 0] to [0.25, 0.25, 0.25]\nAllowed exchange matrix: | A  B  B |\n                         | B  A  B |\n                         | B  B  A |\n\nBond(1, 2, [0, 0, 0])\nDistance 0.7071, coordination 12\nConnects [0, 0, 0] to [0.5, 0.5, 0]\nAllowed exchange matrix: | A  C -D |\n                         | C  A -D |\n                         | D  D  B |\nAllowed DM vector: [-D D 0]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny reported that a single-ion anisotropy is only allowed at quartic and hexic orders, which is consistent with the cubic point group symmetry. Additionally, Sunny reported the allowed forms of nearest and next-nearest neighbor interaction.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The next steps are typically the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Build a System which contains spins on a finite size lattice of crystal unit cells.\nAdd interactions to the system using functions like set_external_field!, set_exchange!, and set_onsite_coupling!.\nPerform Monte Carlo simulation to equilibrate the spin configuration. Options include the continuous Langevin dynamics, or single-spin flip updates with LocalSampler. The former can efficiently handle long-range dipole-dipole interactions, while the latter may be better in the presence of strong anisotropy (e.g., the Ising limit).\nMeasure the static or dynamical structure factor. For details, see the page Structure Factor Calculations.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"EditURL = \"../../../examples/ising2d.jl\"","category":"page"},{"location":"examples/ising2d/#Classical-Ising-model","page":"Classical Ising model","title":"Classical Ising model","text":"","category":"section"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"This tutorial illustrates simulation of the classical 2D Ising model.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"using Sunny, Plots","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Sunny expects a 3D Crystal unit cell. To model a square lattice, we create an orthogonal unit cell where the z-spacing is distinct from the x and y spacing.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"a = 1\nlatvecs = lattice_vectors(a,a,10a,90,90,90)\ncrystal = Crystal(latvecs, [[0,0,0]])","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Create a System of spins with linear size L in the x and y directions, and only one layer in the z direction. The option :dipole means that the system will store Heisenberg spins, as opposed to SU(N) coherent states. Polarize the initial spin configuration using polarize_spins!. Following the Ising convention, we will restrict these spins to the z-axis and give them magnitude S=1.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"By default, Sunny uses physical units, e.g. magnetic field in tesla. Here we specify an alternative Units system, so that the Zeeman coupling between the spin dipole ùê¨ and an external field ùêÅ has the dimensionless form -ùêÅùê¨.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"L = 128\nsys = System(crystal, (L,L,1), [SpinInfo(1, S=1, g=1)], :dipole, units=Units.theory, seed=0)\npolarize_spins!(sys, (0,0,1))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Use set_exchange! to include a ferromagnetic Heisenberg interaction along nearest-neighbor bonds. The Bond below connects two spins displaced by one lattice constant in the x-direction. This interaction will be propagated to all nearest-neighbors bonds in the system, consistent with the symmetries of the square lattice.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"set_exchange!(sys, -1.0, Bond(1,1,(1,0,0)))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"If an external field is desired, it can be set using set_external_field!.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"B = 0\nset_external_field!(sys, (0,0,B))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"The critical temperature for the Ising model is known analytically.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Tc = 2/log(1+‚àö2)","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Use a LocalSampler to perform nsweeps Monte Carlo sweeps. A sweep consists of, on average, one trial update per spin in the system. Each proposed update is accepted or rejected according to the Metropolis acceptance probability. As its name suggests, the propose_flip function will only propose pure spin flips, ùê¨ rightarrow -ùê¨.","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"nsweeps = 4000\nsampler = LocalSampler(kT=Tc, propose=propose_flip)\nfor i in 1:nsweeps\n    step!(sys, sampler)\nend","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"Plot the Ising spins by extracting the z-component of the dipoles","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"heatmap(reshape([s.z for s in sys.dipoles], (L,L)))","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"","category":"page"},{"location":"examples/ising2d/","page":"Classical Ising model","title":"Classical Ising model","text":"This page was generated using Literate.jl.","category":"page"}]
}
