var documenterSearchIndex = {"docs":
[{"location":"versions/#Version-0.4","page":"Version History","title":"Version 0.4","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"This update includes many breaking changes.","category":"page"},{"location":"versions/#Creating-a-spin-System","page":"Version History","title":"Creating a spin System","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"SpinSystem has been renamed System. Its constructor now has the form,","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"System(crystal, latsize, infos, mode)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter infos is now a list of SpinInfo objects. Each defines spin angular momentum S = frac12 1 frac32 , and an optional g-factor or tensor.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter mode is one of :SUN, :dipole, or :large_S. ","category":"page"},{"location":"versions/#Setting-interactions","page":"Version History","title":"Setting interactions","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Interactions are now added mutably to an existing System using the following functions: set_external_field!, set_exchange!, set_exchange_with_biquadratic!, set_anisotropy!, enable_dipole_dipole!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"As a convenience, one can use dmvec(D) to convert a DM vector to a 33 antisymmetric exchange matrix.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Fully general single-ion anisotropy is now possible. The function set_anisotropy! expects the single ion anisotropy to be expressed as a polynomial in symbolic spin operators ùíÆ, or as a linear combination of symbolic Stevens operators ùí™. For example, an easy axis anisotropy in the direction n may be written D*(ùíÆ‚ãÖn)^2.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Stevens operators ùí™[k,q] admit polynomial expression in spin operators ùíÆ[Œ±]. Conversely, a polynomial of spin operators can be expressed as a linear combination of Stevens operators. To see this expansion use print_anisotropy_as_stevens.","category":"page"},{"location":"versions/#Inhomogeneous-interactions","page":"Version History","title":"Inhomogeneous interactions","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Vacancies can be introduced with set_vacancy_at!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"An external field can be applied to a single site with set_external_field_at!. ","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Support for inhomogeneous exchange interactions is planned. One will first call enable_inhomogeneous_exchange!, allowing subsequent use of set_exchange_at!.","category":"page"},{"location":"versions/#Structure-factor-rewrite","page":"Version History","title":"Structure factor rewrite","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The calculation of structure factors has been completely rewritten. For the new interface, see the Structure Factor Calculations page.","category":"page"},{"location":"versions/#Various","page":"Version History","title":"Various","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"repeat_periodically() replaces extend_periodically.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Additional related functions include resize_periodically and reshape_geometry, the latter being fundamental.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"print_symmetry_table() replaces print_bond_table().","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The new function includes the list of symmetry-allowed single ion anisotropies in addition to exchange interactions.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"When reading CIF files, the field _atom_site_label is now used in place of the field _atom_site_type_symbol.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"This is required for correctness. The field _atom_site_label is guaranteed to be present, and is guaranteed to be a distinct label for each symmetry-inequivalent site. Code that explicitly referred to site labels (e.g. in calls to subcrystal()) will need to be updated to use the new label.","category":"page"},{"location":"library/#Library-API","page":"Library API","title":"Library API","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter ? at the Julia command prompt).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Modules = [Sunny]\nPrivate = false","category":"page"},{"location":"library/#Sunny.Units","page":"Library API","title":"Sunny.Units","text":"Units.meV\nUnits.theory\n\nThe unit system is implicitly determined by the definition of two physical constants: the vacuum permeability Œº‚ÇÄ and the Bohr magneton Œº_B. Temperatures are effectively measured in units of energy (k_B = 1) and time is effectively measured in units of inverse energy (ƒß = 1). The default unit system, Units.meV, employs (meV, ‚Ñ´, tesla). Select alternatively Units.theory for a units system defined so that Œº‚ÇÄ = Œº_B = 1.\n\nSee also meV_per_K\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.meV_per_K","page":"Library API","title":"Sunny.meV_per_K","text":"meV_per_K = 0.086173332621451774\n\nA physical constant. Useful for converting kelvin into the default energy units, meV.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.ùí™","page":"Library API","title":"Sunny.ùí™","text":"ùí™[k,q]\n\nAbstract symbols for the Stevens operators. Linear combinations of these can be used to define a single-ion anisotropy.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.ùíÆ","page":"Library API","title":"Sunny.ùíÆ","text":"ùíÆ[1], ùíÆ[2], ùíÆ[3]\n\nAbstract symbols for the spin operators. Polynomials of these can be used to define a single-ion anisotropy.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.Bond","page":"Library API","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal","page":"Library API","title":"Sunny.Crystal","text":"An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:\n\nCrystal(filename; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.  The optional parameter symprec controls the precision tolerance for spacegroup symmetries.\n\nCrystal(lat_vecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, with coordinates (between 0 and 1) in units of lattice vectors lat_vecs. Spacegroup symmetry information is automatically inferred. The optional parameter types is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.\n\nCrystal(lat_vecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)\n\nBuilds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional setting string will disambiguate between unit cell conventions.\n\nCurrently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a .cif file or from the full specification of the unit cell.\n\nExamples\n\n# Read a Crystal from a .cif file\nCrystal(\"filename.cif\")\n\n# Build an FCC crystal using the primitive unit cell. The spacegroup number\n# 225 is inferred.\nlat_vecs = [1 1 0;\n            1 0 1;\n            0 1 1] / 2\npositions = [[0, 0, 0]]\nCrystal(lat_vecs, positions)\n\n# Build a CsCl crystal (two cubic sublattices). By providing distinct type\n# strings, the spacegroup number 221 is inferred.\nlat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[0,0,0], [0.5,0.5,0.5]]\ntypes = [\"Na\", \"Cl\"]\ncryst = Crystal(lat_vecs, positions; types)\n\n# Build a diamond cubic crystal from its spacegroup number 227. This\n# spacegroup has two possible settings (\"1\" or \"2\"), which determine an\n# overall unit cell translation.\nlat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[1, 1, 1] / 4]\ncryst = Crystal(lat_vecs, positions, 227; setting=\"1\")\n\nSee also lattice_vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}","page":"Library API","title":"Sunny.FormFactor","text":"FormFactor(atom::Int64, elem::String; g_lande=nothing)\n\nBasic type for specifying form factor parameters. Must be provided a site within the unit cell (atom) and a string specifying the element name. This used when calling intensities, which requires a list of FormFactorss.\n\nA list of supported element names is available at:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\n\nThe Land√© g-factor may also be specified. \n\nIn more detail, the data stored in a FormFactor will be used to compute the form factor for each momentum space magnitude |k|, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor f is returned. If the keyword g_lande is given a numerical value, then a second order form factor F is returned.\n\nIt is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable s = k4œÄ, where k can be interpreted as the magnitude of momentum transfer.\n\nThe Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation\n\nlangle j_l(s) rangle = A e^-as^2 + B e^-bs^2 + Ce^-cs^2 + D\n\nwhere coefficients A B C D a b c are obtained from semi-empirical fits, depending on the orbital angular momentum index l = 0 2. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.\n\nA first approximation to the magnetic form factor is\n\nf(s) = langle j_0(s) rangle\n\nA second order correction is given by\n\nF(s) = frac2-gg langle j_2(s) rangle s^2 + f(s), where g is the Land√© g-factor.  \n\nDigital tables are available at:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\n\nAdditional references are:\n\nMarshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)\nClementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)\nFreeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)\nDescleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.ImplicitMidpoint","page":"Library API","title":"Sunny.ImplicitMidpoint","text":"ImplicitMidpoint(Œît::Float64; atol=1e-12) where N\n\nEnergy-conserving integrator for simulating dynamics without damping or noise. Use with the step! function to evolve a System forward by a time step of Œît:\n\nstep!(sys::System, integrator::ImplicitMidpoint)\n\nThe above function will use the spherical midpoint integration scheme for dipole systems and the Schrodinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic (energy-conserving) and are appropriate for simulating dissipationless dynamics over long periods of time.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Langevin","page":"Library API","title":"Sunny.Langevin","text":"Langevin(Œît::Float64, kT::Float64, Œª::Float64)\n\nProjected Heun integration scheme with noise and damping. Use with the step! function to evolve a System forward by a time step of Œît:\n\nstep!(sys::System, integrator::Langevin)\n\nIf kT > 0, this will simulate dynamics in the presence of a thermal bath. Œª is an empirical parameter that determines the strength of coupling to the thermal bath and sets a time scale for decorrelation, 1/Œª.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LocalSampler","page":"Library API","title":"Sunny.LocalSampler","text":"LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)\n\nMonte Carlo simulation involving Metropolis updates to individual spins. Use with the step! function.\n\nkT is the target temperature, and can be updated dynamically.\nnsweeps is the number of full-system MCMC sweeps, and may be fractional. The default value of 1.0 means that step! performs, on average, one trial update for every spin.\npropose is a function to generate new candidate spin states, which may be accepted or rejected. Options include propose_uniform, propose_flip, and propose_delta. Multiple proposals can be mixed with propose_mix.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinInfo","page":"Library API","title":"Sunny.SpinInfo","text":"SpinInfo(atom::Int; S, g=2)\n\nCharacterizes the spin at a given atom index within the crystal unit cell. S is an integer multiple of 1/2 and gives the spin angular momentum in units of ƒß. g is the g-factor or tensor, such that an angular momentum dipole s produces a magnetic moment g s in units of the Bohr magneton.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.StructureFactor","text":"StructureFactor(sys::System; Œît, nœâ, measperiod, apply_g = true, ops = nothing,\n                    matrix_elems = nothing, process_trajectory = :none)\n\nStructureFactor is the basic type for calculating ùíÆ(qœâ) or ùíÆ(q) data, storing the results, and retrieving intensity information. \n\nInstead of creating StructureFactor directly, one should call either either DynamicStructureFactor or StaticStructureFactor.\n\nData may be retrieved from a StructureFactor by calling intensities  or static_intensities. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}","page":"Library API","title":"Sunny.System","text":"System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)\n\nConstruct a System of spins for a given Crystal symmetry. The latsize parameter determines the number of unit cells in each lattice vector direction. The infos parameter is a list of SpinInfo objects, which determine the magnitude S and g-tensor of each spin.\n\nThe three possible options for mode are :SUN, :dipole, and :large_S. The most variationally accurate choice is :SUN, in which each spin-S degree of freedom is described as an SU(N) coherent state, where N = 2S + 1. Note that an SU(N) coherent state fully describes any local spin state; this description includes expected dipole components S·µÖ, quadrupole components S·µÖS·µù+S·µùS·µÖ, etc.\n\nClassical spin models have historically used the expected dipoles alone.  The choice mode=:dipole projects the SU(N) dynamics onto the space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but all single-ion anisotropy or biquadratic exchange interactions will be automatically renormalized to achieve maximum accuracy.\n\nTo disable such renormalization, e.g. to reproduce results collected using the historical large-S classical limit, use mode=:large_S. We emphasize, however, that mode=:SUN or mode=:dipole should be preferred for the development of new models.\n\nThe default units system of (meV, ‚Ñ´, tesla) can be overridden by with the units parameter; see Units. \n\nAn optional seed may be provided to achieve reproducible random number generation.\n\nAll spins are initially polarized in the z-direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.DynamicStructureFactor-Tuple{System}","page":"Library API","title":"Sunny.DynamicStructureFactor","text":"DynamicStructureFactor(sys::System; Œît, nœâ, œâmax, \n    apply_g=true, process_trajectory=:none, ops=nothing, matrix_elems=nothing)\n\nCreates a StructureFactor for calculating and storing ùíÆ(qœâ) data. When calculating a dynamic structure factor from classical dynamics, it is necessary to generate spin trajetories which are used to calculate correlations. The initial conditions for these trajectories must be sample spin configurations drawn from the equilibrium distribution at the desired temperature. One such trajectory is calculated immediately when initializing a DynamicStructureFactor, so the spins in the sys must represent a good sample before calling this function. Additional sample trajectories are created and accumulated into the DynamicStructureFactor by calling add_sample!(sf, sys). The spins in the sys should be set to new sample configurations before each call to add_sample!. This can be achieved, for example, with the Langevin dynamics.\n\nThree keywords are required to specify the dynamics used for the trajectory calculation.\n\nŒît: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an ImplicitMidpoint integrator.\nœâmax: The maximum energy, œâ, that will be resolved.\nnœâ: The number of energy bins to calculated between 0 and œâmax.\n\nAdditional keyword options are the following:\n\napply_g: Determines whether to apply the g-factor when calculating   trajectories.\nprocess_trajectory: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are :none and   :symmetrize. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.\nops: Enables an advanced feature for SU(N) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, ops must be given an N√óN√ónumops array, where the   final index is used to retrieve each N√óN operator.\nmatrix_elems: Specify which correlation functions are calculated, i.e. which   matrix elements Œ±Œ≤ of ùíÆ^Œ±Œ≤(qœâ) are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by the x, y, and z dipolar components (1, 2,   and 3 respectively). To retain only the xx and xy correlations, one would   set matrix_elems=[(1,1), (1,2)]. If custom observables (ops) are given,   the indices are ordered in the same manner as the final index of ops.\n\nThe ùíÆ(qœâ) data can be retrieved by calling intensities or static_intensities. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.Site-Tuple{CartesianIndex{4}}","page":"Library API","title":"Sunny.Site","text":"Site(n1, n2, n3, i)\n\nConstruct an index to a single site in a System via its unit cell (n1,n2,n3) and its atom i. Can be used to index dipoles and coherents fields of a System, or to set inhomogeneous interactions. This function is effectively an alias for the four-component CartesianIndex constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.StaticStructureFactor-Tuple{System}","page":"Library API","title":"Sunny.StaticStructureFactor","text":"StaticStructureFactor(sys::System; apply_g=true, process_trajectory=:none,\n                        ops=nothing, matrix_elems=nothing)\n\nCreates a StructureFactor for calculating and storing ùíÆ(q) data, i.e., spin-spin correlation data calculated at single time steps. An initial sample is generated from the spins in sys when calling StaticStructureFactor, so the spins should represent a good equilibrium sample before this function is called. Additional samples may be generated by calling add_sample!(sf, sys). The spins in the sys should be resampled before each call to add_sample!.\n\nThe the following optional keywords are available:\n\napply_g: Determines whether to apply the g-factor when calculating   trajectories.\nprocess_trajectory: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are :none and   :symmetrize. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.\nops: Enables an advanced feature for SU(N) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, ops must be given an N√óN√ónumops array, where the   final index is used to retrieve each N√óN operator.\nmatrix_elems: Specify which correlation functions are calculated, i.e. which   matrix elements Œ±Œ≤ of ùíÆ^Œ±Œ≤(qœâ) are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by the x, y, and z dipolar components (1, 2,   and 3 respectively). To retain only the xx and xy correlations, one would   set matrix_elems=[(1,1), (1,2)]. If custom observables (ops) are given,   the indices are ordered in the same manner as the final index of ops.\n\nùíÆ(ùê™) data can be retrieved by calling static_intensities.\n\nNOTE: It is often advisable to generate a static structure factor, ùíÆ(ùê™), from a dynamic structure factor, ùíÆ(ùê™œâ), by integrating out œâ, rather than calculating ùíÆ(ùê™) directly from spin-spin correlations at single instances of time. This approach makes it possible to apply a temperature- and œâ-dependent classical-to-quantum intensity rescaling to the results. This can be done in Sunny by calculating a DynamicStructureFactor and retrieving ùíÆ(ùê™) data with static_intensities, taking care to set the kT keyword to the appropriate value. static_intensities will then integrate the œâ information out after applying intensity corrections.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.add_sample!-Tuple{StructureFactor, System}","page":"Library API","title":"Sunny.add_sample!","text":"add_sample!(sf::StructureFactor, sys::System)\n\nadd_trajectory uses the spin configuration contained in the System to generate a correlation data and accumulate it into sf. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculating in time and accumulated into sf. \n\nThis function will change the state of sys when calculating dynamical structure factor data. To preserve the initial state of sys, it must be saved separately prior to calling add_sample!. Alternatively, the initial spin configuration may be copied into a new System and this new System can be passed to add_sample!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_exact_wave_vectors-Tuple{StructureFactor}","page":"Library API","title":"Sunny.all_exact_wave_vectors","text":"all_exact_wave_vectors(sf::StructureFactor; bzsize=(1,1,1))\n\nReturns all wave vectors for which sf contains exact values. bsize specifies the number of Brillouin zones to be included.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.anneal!-Union{Tuple{N}, Tuple{System{N}, Any, Any}} where N","page":"Library API","title":"Sunny.anneal!","text":"anneal!(sys::System, sampler, kTs)\n\nAnneals the system by repeated calling step!(sys, sampler) using a provided temperature schedule. Frequently the kTs will be constructed using temperature_schedule.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}","page":"Library API","title":"Sunny.broaden_energy","text":"broaden_energy(sf::StructureFactor, vals, kernel::Function; negative_energies=false)\n\nPerforms a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by intensities. kernel must be a function that takes two numbers: kernel(œâ, œâ‚ÇÄ), where œâ is a frequency, and œâ‚ÇÄ is the center frequency of the kernel. Sunny provides lorentzian for the most common use case:\n\nnewvals = broaden_energy(sf, vals, (œâ, œâ‚ÇÄ) -> lorentzian(œâ-œâ‚ÇÄ, 0.2))\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.browser-Tuple{String}","page":"Library API","title":"Sunny.browser","text":"browser(html_str; dir)\n\nLaunch a system browser to display the provided HTML string or SunnyViewer. If a directory dir is provided, an HTML file will be written at that location.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.connected_path-Tuple{Vector, Any}","page":"Library API","title":"Sunny.connected_path","text":"connected_path(qs::Vector, density)\n\nTakes a list of wave vectors, qs, and builds an expanded list of wave vectors that traces a path through the provided points. Also returned is a list of marker indices corresponding to the intput points. The density parameter controls the frequency of sampling.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dmvec-Tuple{Any}","page":"Library API","title":"Sunny.dmvec","text":"dmvec(D)\n\nAntisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,\n\n  [  0    D[3] -D[2]\n   -D[3]   0    D[1]\n    D[2] -D[1]   0  ]\n\nUseful in the context of set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.enable_dipole_dipole!-Tuple{System}","page":"Library API","title":"Sunny.enable_dipole_dipole!","text":"enable_dipole_dipole!(sys::System)\n\nEnables long-range dipole-dipole interactions,\n\n    -(Œº‚ÇÄ4œÄ) _ij  (3 (ùêå_jùê´_ij)(ùêå_iùê´_ij) - ùêå_iùêå_j)  ùê´_ij^3\n\nwhere the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and ùêí_i is the spin angular momentum dipole in units of ƒß. The Bohr magneton Œº_B and vacuum permeability Œº_0 are physical constants, with numerical values determined by the unit system.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.energy","text":"energy(sys::System)\n\nComputes the total system energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.forces","text":"forces(Array{Vec3}, sys::System)\n\nReturns the effective local field (force) at each site, ùêÅ = -Eùê¨.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensities-Tuple{StructureFactor, Any, Any}","page":"Library API","title":"Sunny.intensities","text":"intensities(sf::StructureFactor, qs, mode; interpolation = nothing,\n                kT = nothing, formfactors = nothing, negative_energies = false)\n\nThe basic function for retrieving ùíÆ(ùê™œâ) information from a StructureFactor. Maps an array of wave vectors qs to an array of structure factor intensities, including an additional energy index. The values of œâ associated with the energy index can be retrieved by calling œâs. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.\n\nmode: Should be one of :trace, :perp, or :full. Determines an optional   contraction on the indices Œ± and Œ≤ of ùíÆ^Œ±Œ≤(qœâ). Setting   trace yields _Œ± ùíÆ^Œ±Œ±(qœâ). Setting perp will employ a   polarization correction on the traced value. Setting full will return all   elements ùíÆ^Œ±Œ≤(ùê™œâ) with contraction.\ninterpolation: Since ùíÆ(ùê™ œâ) is calculated on a finite lattice, data is   only available at discrete wave vectors. By default, Sunny will round a   requested q to the nearest available wave vector. Linear interpolation can   be applied by setting interpolation=:linear.\nkT: If a temperature is provided, the intensities will be rescaled by a   temperature- and œâ-dependent classical-to-quantum factor. kT should be   specified when making comparisons with spin wave calculations or   experimental data.\nformfactors: To apply form factor corrections, provide this keyword with a   vector of FormFactors, one for each unique site in the unit cell. Sunny   will symmetry propagate the results to all equivalent sites.\nnegative_energies: If set to true, Sunny will return the periodic   extension of the energy axis. Most users will not want this.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Library API","title":"Sunny.lattice_params","text":"lattice_params(lat_vecs::Mat3)\n\nCompute the lattice parameters (a b c Œ± Œ≤ Œ≥) for the three lattice vectors provided as columns of lat_vecs. The inverse mapping is lattice_vectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_vectors-NTuple{6, Any}","page":"Library API","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Œ± Œ≤ Œ≥) in degrees. The inverse mapping is lattice_params.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lorentzian-Tuple{Any, Any}","page":"Library API","title":"Sunny.lorentzian","text":"lorentzian(x, Œ∑)\n\nReturns Œ∑^2(x^2 + Œ∑^2).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.plot_spins-Tuple{System}","page":"Library API","title":"Sunny.plot_spins","text":"plot_spins(sys::System; linecolor=:grey, arrowcolor=:red, linewidth=0.1,\n                            arrowsize=0.3, arrowlength=1.0, kwargs...)\n\nPlot the spin configuration defined by sys. kwargs are passed to GLMakie.arrows.        \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}","page":"Library API","title":"Sunny.print_anisotropy_as_classical_spins","text":"function print_anisotropy_as_classical_spins(p)\n\nPrints a quantum operator (e.g. linear combination of Stevens operators) as a polynomial of spin expectation values in the classical limit.\n\nSee also print_anisotropy_as_stevens.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_anisotropy_as_stevens-Tuple{Any}","page":"Library API","title":"Sunny.print_anisotropy_as_stevens","text":"function print_anisotropy_as_stevens(p; N)\n\nPrints a quantum operator (e.g. a polynomial of the spin operators ùíÆ) as a linear combination of Stevens operators. The parameter N specifies the dimension of the SU(N) representation, corresponding to quantum spin magnitude S = (N-1)2. The special value N = 0 indicates the large-S classical limit.\n\nIn the output, the symbol X denotes the spin operator magnitude squared. Quantum spin operators ùíÆ of any finite dimension satisfy X = ùíÆ^2 = S (S+1). To take the large-S limit, however, we keep only leading order powers of S, such that X = S^2.\n\nThis function can be useful for understanding the conversions performed internally by set_anisotropy!.\n\nFor the inverse mapping, see print_anisotropy_as_classical_spins.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_bond-Tuple{Crystal, Bond}","page":"Library API","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)\n\nPrints symmetry information for bond bond. A symmetry-equivalent reference bond b_ref can optionally be provided to fix the meaning of the coefficients A, B, ...\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_dominant_wavevectors-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.print_dominant_wavevectors","text":"print_dominant_wavevectors(sys::System; nmax=10)\n\nPrints a list of wavevectors according to their weights in the static structure factor. Coordinates are given in units of reciprocal lattice vectors. These dominant wavevectors may be used as input to suggest_magnetic_supercell.\n\nUnlike in static_intensities, here the structure factor weights do not incorporate phase averaging between sublattices. Instead, intensities are calculated for each sublattice independently, and na√Øvely summed. This means that wavevectors beyond the first Brillouin zone will be missing.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_site-Tuple{Any, Any}","page":"Library API","title":"Sunny.print_site","text":"print_site(cryst, i; R=I)\n\nPrint symmetry information for the site i, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix R can be provided to define the reference frame for expression of the anisotropy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_suggested_frame-Tuple{Crystal, Int64}","page":"Library API","title":"Sunny.print_suggested_frame","text":"print_suggested_frame(cryst, i; digits=4)\n\nPrint a suggested reference frame, as a rotation matrix R, that can be used as input to print_site(). This is useful to simplify the description of allowed anisotropies.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_symmetry_table-Tuple{Crystal, Any}","page":"Library API","title":"Sunny.print_symmetry_table","text":"print_symmetry_table(cryst::Crystal, max_dist)\n\nPrint symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist), where Bond(i, i, [0,0,0]) refers to a single site i.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_delta-Tuple{Any}","page":"Library API","title":"Sunny.propose_delta","text":"propose_delta(magnitude)\n\nGenerate a proposal function that adds a Gaussian perturbation to the existing spin. The magnitude is typically order one or smaller. For use with LocalSampler.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.propose_flip","text":"propose_flip\n\nFunction to propose Ising spin flip updates. For use with LocalSampler.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_mix-Tuple{Any, Any}","page":"Library API","title":"Sunny.propose_mix","text":"propose_mix(options, weights)\n\nGenerate a proposal function that randomly selects among all options, according to the probability weights. For use with LocalSampler.\n\nExample\n\npropose_mix([propose_flip, propose_delta(0.2)], [0.5, 0.5])\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.propose_uniform","page":"Library API","title":"Sunny.propose_uniform","text":"propose_uniform\n\nFunction to propose a uniformly random spin update. For use with LocalSampler.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.reference_bonds-Tuple{Crystal, Float64}","page":"Library API","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.repeat_periodically","text":"repeat_periodically(sys::System{N}, counts) where N\n\nCreates a System identical to sys but repeated a given number of times in each dimension, specified by the tuple counts.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.reshape_geometry","text":"reshape_geometry(sys::System, A)\n\nMaps an existing System to a new one that has the shape and periodicity of a requested supercell. The columns of the 33 integer matrix A represent the supercell lattice vectors measured in units of the original crystal lattice vectors.\n\nThe crystal unit cell may also need to be reshaped to achieve the desired periodicity of the requested supercell. If this is the case, the returned System object will be missing symmetry information. Consequently, certain operations will be unavailable for this system, e.g., setting interactions by symmetry propagation. In practice, one can set all interactions using the original system, and then reshape as a final step.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.resize_periodically","text":"resize_periodically(sys::System{N}, latsize) where N\n\nCreates a System identical to sys but enlarged to a given number of unit cells in each lattice vector direction.\n\nAn error will be thrown if sys is incommensurate with latvecs. Use reshape_geometry instead to reduce the volume, or to perform an incommensurate reshaping.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N","page":"Library API","title":"Sunny.set_anisotropy!","text":"set_anisotropy!(sys::System, op, i::Int)\n\nSet the single-ion anisotropy for the ith atom of every unit cell, as well as all symmetry-equivalent atoms. The parameter op may be a polynomial in symbolic spin operators ùíÆ[Œ±], or a linear combination of symbolic Stevens operators ùí™[k,q].\n\nThe characters ùíÆ and ùí™ can be copy-pasted from this help message, or typed at a Julia terminal using \\scrS or \\scrO followed by tab-autocomplete.\n\nFor systems restricted to dipoles, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(N) mode.\n\nExamples\n\n# An easy axis anisotropy in the z-direction\nset_anisotropy!(sys, -D*ùíÆ[3]^3, i)\n\n# The unique quartic single-ion anisotropy for a site with cubic point group\n# symmetry\nset_anisotropy!(sys, ùí™[4,0] + 5ùí™[4,4], i)\n\n# An equivalent expression of this quartic anisotropy, up to a constant shift\nset_anisotropy!(sys, 20*(ùíÆ[1]^4 + ùíÆ[2]^4 + ùíÆ[3]^4), i)\n\nSee also print_anisotropy_as_stevens.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N","page":"Library API","title":"Sunny.set_exchange!","text":"set_exchange!(sys::System, J, bond::Bond)\n\nSets a 3√ó3 spin-exchange matrix J along bond, yielding a pairwise interaction energy ùêí_iJ ùêí_j. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter bond has the form Bond(i, j, offset), where i and j are atom indices within the unit cell, and offset is a displacement in unit cells.\n\nScalar J implies a pure Heisenberg exchange.\n\nAs a convenience, dmvec(D) can be used to construct the antisymmetric part of the exchange, where D is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be ùêÉ(ùêí_iùêí_j).\n\nExamples\n\nusing Sunny, LinearAlgebra\n\n# An explicit exchange matrix\nJ1 = [2 3 0;\n     -3 2 0;\n      0 0 2]\nset_exchange!(sys, J1, bond)\n\n# An equivalent Heisenberg + DM exchange \nJ2 = 2*I + dmvec([0,0,3])\nset_exchange!(sys, J2, bond)\n\nSee also set_exchange_with_biquadratic!, dmvec.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N","page":"Library API","title":"Sunny.set_exchange_with_biquadratic!","text":"set_exchange_with_biquadratic!(sys::System, J1, J2, bond::Bond)\n\nSets both quadratic and biquadratic exchange interactions along bond, yielding a pairwise energy ùêí_iJ_1 ùêí_j + J_2 (ùêí_iùêí_j)¬≤. These interactions will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten.\n\nFor systems restricted to dipoles, the biquadratic interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(N) mode. This renormalization introduces a correction to the quadratic part of the exchange, which is why the two parts must be specified concurrently.\n\nSee also set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field!-Tuple{System, Any}","page":"Library API","title":"Sunny.set_external_field!","text":"set_external_field!(sys::System, B::Vec3)\n\nSets the external field B that couples to all spins.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field_at!-Tuple{System, Any, Any}","page":"Library API","title":"Sunny.set_external_field_at!","text":"set_external_field_at!(sys::System, B::Vec3, idx::Site)\n\nSets a Zeeman coupling between a field B and a single spin. Site includes a unit cell and a sublattice index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N","page":"Library API","title":"Sunny.set_vacancy_at!","text":"set_vacancy_at!(sys::System, idx::Site)\n\nMake a single site nonmagnetic. Site includes a unit cell and a sublattice index.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}","page":"Library API","title":"Sunny.spherical_shell","text":"spherical_shell(sf::StructureFactor, radius, density)\n\nReturns a set of wave vectors lying on a sphere of specified radius, where radius is given in √Ö^-1. density controls how many points to select per √Ö^-2. \n\nThe points are generated by mapping a Fibonacci lattice onto a sphere. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.static_intensities-Tuple{StructureFactor, Any, Any}","page":"Library API","title":"Sunny.static_intensities","text":"static_intensities(sf::StructureFactor, qs, mode; kwargs...)\n\nReturn the static structure factor intensities at wave vectors qs. The functionality is very similar to intensities, except the returned array has dimensions identical to qs. The energy axis has been integrated out.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.step!-Tuple{System{0}, Langevin}","page":"Library API","title":"Sunny.step!","text":"step!(sys::System, integrator)\n\nAdvance the spin dynamics one integration time-step. The integrator may be of type Langevin or ImplicitMidpoint.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N","page":"Library API","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}","page":"Library API","title":"Sunny.suggest_magnetic_supercell","text":"suggest_magnetic_supercell(qs, latsize)\n\nSuggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors in qs. An upper bound for the supercell is given by latsize, which is measured in units of lattice vectors, and must be commensurate with the wavevectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.temperature_schedule-Tuple{Any, Any, Any}","page":"Library API","title":"Sunny.temperature_schedule","text":"temperature_schedule(kT1, length; curvature=4.0)\n\nReturns an iterator that includes length temperatures that decay from kT1 to kT2. The optional parameter curvature controls the initial slope of the temperature decay.\n\nSee also anneal!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.view_crystal-Tuple{Crystal, Real}","page":"Library API","title":"Sunny.view_crystal","text":"view_crystal(crystal::Crystal, max_dist::Real)\n\nCreate and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using browser().\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.œâs-Tuple{StructureFactor}","page":"Library API","title":"Sunny.œâs","text":"œâs(sf::StructureFactor; negative_energies=false)\n\nReturn the œâ values for the energy index of a StructureFactor. By default, only returns values for non-negative energies, which corresponds to the default output of intensities. Set negative_energies to true to retrieve all œâ values.\n\n\n\n\n\n","category":"method"},{"location":"library/#Plotting","page":"Library API","title":"Plotting","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"To reduce package load times, certain plotting functions are only available when the user explicitly executes \"using GLMakie\".","category":"page"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/#Overview","page":"Structure Factor Calculations","title":"Overview","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The dynamical structure factor is of fundamental importance for characterizing a magnetic system, and facilitates quantitative comparison between theory and experimental scattering data.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider, for example, a two-point dynamical spin correlation function, s^Œ±(ùê±+Œîùê± t+Œît) s^Œ≤(ùê± t). Here s^Œ±(ùê± t) represents the time dynamics of a spin dipole component Œ± at position ùê±, and brackets represent an average over equilibrium initial conditions and over (ùê± t). The dynamical structure factor is defined as the Fourier transform of this two-point correlation in both space and time, up to an overall scaling factor. Using the convolution theorem, the result is,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = frac1V s^Œ±(ùê™ œâ)^ast s^Œ≤(ùê™ œâ) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"with V the system volume. We will restrict attention to lattice systems with periodic boundaries.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider a crystal unit cell defined by three lattice vectors ùêö_1 ùêö_2 ùêö_3, and linear system sizes L_1 L_2 L_3 measured in unit cells. The allowed momentum vectors take on discrete values ùê™ = sum_Œ±=1^3 m_Œ± ùêõ_Œ±  L_Œ±, where m_Œ± are an integers and the reciprocal lattice vectors ùêõ_Œ± are defined to satisfy ùêö_Œ±  ùêõ_Œ≤ = 2œÄ Œ¥_Œ±Œ≤. For a Bravais lattice, ùê™ will be periodic in the first Brillouin zone, i.e., under any shift ùê™  ùê™  ùêõ_Œ±. More generally, consider a non-Bravais lattice such that each unit cell may contain multiple spins. By partitioning spins s_j(ùê±t) according to their sublattice index j, the relevant momenta ùê™ remain discretized as above, but now periodicity in the first Brillouin zone is lost. The structure factor may be written as a phase-average over the displacements between sublattices ùê´_jk,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = _jk e^i ùê´_jk  ùê™ ùíÆ^Œ±Œ≤_jk(ùê™ œâ) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"From a theoretical perspective, the quantity","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = frac1V s_j^Œ±(ùê™ œâ)^ast s_k^Œ≤(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"is fundamental. For each sublattice j, the data s_j^Œ±(ùê™ œâ) can be efficiently obtained by fast Fourier tranformation of a real space configuration s_j^Œ±(ùê± t). Internally, Sunny will calculate and store the discrete ùíÆ^Œ±Œ≤_jk(ùê™ œâ) correlation data, and use this to construct ùíÆ^Œ±Œ≤(ùê™œâ) intensities that can be compared with experiment.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Calculating this structure factor involves several steps, with various possible settings. Sunny provides a number of tools to facilitate this calculation and to extract information from the results. These tools are briefly outlined below. \"Real life\" use cases can be found in our tutorials and detailed function information is available in the Library API.","category":"page"},{"location":"structure-factor/#Basic-Usage","page":"Structure Factor Calculations","title":"Basic Usage","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic data type for calculating, storing and retrieving structure factor data is StructureFactor. Rather than creating a StructureFactor directly, one should call either DynamicStructureFactor, for ùíÆ^Œ±Œ≤(ùê™œâ), or StaticStructureFactor, for ùíÆ^Œ±Œ≤(ùê™). These functions will configure and return an appropriate StructureFactor.","category":"page"},{"location":"structure-factor/#Calculating-a-dynamical-stucture-factor","page":"Structure Factor Calculations","title":"Calculating a dynamical stucture factor","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Calling DynamicStructureFactor(sys; Œît, œâmax, nœâ) will create a StructureFactor for the user and calculate an initial sample. There are three keywords that must be specified. These keywords will determine the dynamics used to calculate the sample and, consequently, the œâ information that will be available after the calculation has completed.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Œît: Determines the step size used for simulating the dynamics. A smaller number will require proportionally more calculation time. While a smaller Œît will enable the resolution of higher energies, Œît is typically selected to ensure numerical stability rather than to maximize the largest œâ value. A safe choice is to use the smaller value of Œît = 0.1/(J* S^2) or Œît = 0.1/(D * S), where S is magnetic moment of the largest local spin (as specified in SpinInfo), J is the parameter governing the largest bilinear interaction (e.g. exchange), and D is the parameter governing the largest single-site term of the Hamiltonian (e.g., anisotropy or Zeeman term).\nœâmax: Sets the maximum resolved energy. Note that this is not independent of Œît. If œâmax too large, Sunny will throw an error and ask you to choose a smaller Œît. \nnœâ: Determines the number of energy bins to resolve. A larger number will require more calculation time.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Upon constructing DynamicStructureFactor, classical spin dynamics will be performed, and spin correlation data will be accumulated into ùíÆ^Œ±Œ≤(ùê™œâ). The input sys must be a spin configuration in good thermal equilibrium, e.g., using the continuous Langevin dynamics or using single spin flip trials with LocalSampler. The statistical quality of the ùíÆ^Œ±Œ≤(ùê™œâ) can be improved by generating a decorrelated spin configuration in sys, and then calling add_sample!(structure_factor, sys).","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The outline of typical use case might look like this:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"# Make a `StructureFactor` and calculate an initial sample\nsf = DynamicStructureFactor(sys; Œît=0.05, œâmax=10.0, nœâ=100) \n\n# Add additional samples\nfor _ in 1:nsamples\n   decorrelate_system(sys) # Perform some type of Monte Carlo simulation\n   add_sample!(sf, sys)    # Use spins to calculate and accumulate new sample of ùíÆ(ùê™,œâ)\nend","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The calculation may be configured in a number of ways; see the DynamicStructureFactor documentation for a list of all keywords.","category":"page"},{"location":"structure-factor/#Calculating-a-static-structure-factor","page":"Structure Factor Calculations","title":"Calculating a static structure factor","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Sunny provides two methods for calculating static structure factors, ùíÆ^Œ±Œ≤(ùê™). The first involves calculating spin-spin correlations at single instances of time. The second involves calculating a dynamic structure factor first and integrating out the œâ information. The advantage of the latter approach is that it enables application of an œâ-dependent classical-to-quantum rescaling of structure factor intensities, a method that should be preferred whenever comparing results to experimental data or spin wave calculations. A disadvantage of this approach is that it is computationally more expensive. There are also many cases when it is not straightforward to calculate a meaningful dynamics, as when working with Ising spins. In this section we will discuss how to calculate static structure factors from static spin configurations. Information about calculating static data from a dynamic structure factor can be found in the following section.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic usage for the static case is very similar to the dynamic case, except one calls StaticStructureFactor(sys) instead of DynamicStructureFactor. Note that there are no required keywords as there is no need to specify any dynamics. StaticStructureFactor will immediately calculate a sample of ùíÆ(ùê™) using the spin configuration contained in sys. It is therefore important that  sys be properly thermalized before calling this function. Additional samples may be added with add_sample!(sf, sys), just as was done in the dynamic case. As was true there, it is important to ensure that the spins in sys represents a new equilibrium sample before calling add_sample!.","category":"page"},{"location":"structure-factor/#Extracting-information-from-structure-factors","page":"Structure Factor Calculations","title":"Extracting information from structure factors","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic function for extracting information from a dynamic StructureFactor at a particular wave vector, ùê™, is intensities. It takes a StructureFactor, a list of wave vectors, and a contraction mode. For example, intensities(sf, [[0.0, 0.5, 0.5]], :trace) will calculate intensities for the wavevector ùê™ = (ùêõ_2 + ùêõ_3)2. The option :trace will contract spin indices, returning ùíÆ^Œ±Œ±(ùê™œâ). The option :perp will instead perform a contraction that includes polarization corrections. The option :full will return data for the full tensor ùíÆ^Œ±Œ≤(ùê™œâ). intensities returns a list of nœâ elements. The corresponding œâ values are given by œâvals(sf), where sf is the StructureFactor.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Since Sunny currently only calculates the structure factor on a finite lattice, it is important to realize that exact information is only available at a discrete set of wave vectors. Specifically, for each axis index i, we will get information at q_i = fracnL_i, where n runs from (frac-L_i2+1) to fracL_i2 and L_i is the linear dimension of the lattice used for the calculation. If you request a wave vector that does not fall into this set, Sunny will automatically round to the nearest ùê™ that is available. If intensities is given the keyword argument interpolation=:linear, Sunny will use trilinear interpolation to determine the results at the requested wave vector. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve the intensities at all wave vectors for which there is exact data, first call the function all_exact_wave_vectors to generate a list of qs. This takes an optional keyword argument bzsize, which must be given a tuple of three integers specifying the number of Brillouin zones to calculate, e.g., bzsize=(2,2,2). The resulting list of wave vectors may then be passed to intensities.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The convenience function connected_path returns a list of wavevectors sampled along a path that connects specified ùê™ points. This list can be used as an input to intensities.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A number of keyword arguments are available which modify the calculation of structure factor intensity. See the documentation of intensities for a full list. It is generally recommended to provide a value to kT corresponding to the temperature of sampled configurations. Given kT, Sunny will apply an energy- and temperature-dependent classical-to-quantum rescaling of intensities. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve intensity data from a static structure factor, use static_intensities, which shares keyword arguments with intensities. This function may also be used to calculate static information from a dynamical structure factor. Note that it is important to supply a value to kT to reap the benefits of this approach over simply calculating a static structure factor at the outset. ","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"EditURL = \"https://github.com/SunnySuite/Sunny.jl/blob/main/examples/powder_averaging.jl\"","category":"page"},{"location":"literate_build/powder_averaging/#Powder-Averaging","page":"Powder Averaging","title":"Powder Averaging","text":"","category":"section"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"This tutorial gives a brief demonstration of how to calculate polycrystalline data using Sunny's structure factor tools.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"We begin by constructing a simple anti-ferromagnetic model on a diamond lattice.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"using Sunny, GLMakie\nusing Statistics: mean\n\ndims = (8,8,8)               # Lattice dimensions\nseed = 1                     # RNG seed for repeatable behavior\nJ = Sunny.meV_per_K*7.5413   # Nearest-neighbor exchange parameter\n\ncrystal = Sunny.diamond_crystal()\nsys = System(crystal, dims, [SpinInfo(1, S=3/2)], :dipole; seed)\nset_exchange!(sys, J, Bond(1, 3, [0,0,0]))","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"We next set up a Langevin integrator and thermalize the system.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Œît = 0.07                   # Step size for Langevin integrator\nkT = Sunny.meV_per_K * 2    # Temperature of simulation (2K)\nŒª = 0.1                     # Damping parameter\nintegrator = Langevin(kT, Œª, Œît);\n\nfor _ ‚àà 1:3000\n    step!(sys, integrator)\nend;","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"We can now calculate the structure factor. We will tell Sunny to symmetrize the sample trajectory along the time-axis to minimize Fourier artifacts.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"sf = DynamicStructureFactor(sys;\n    Œît=2Œît,\n    nœâ=100,\n    œâmax=5.5,\n    process_trajectory=:symmetrize\n);","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"To get some intuition about the expected results, we first look at the \"single crystal\" results along a high-symmetry path in the first Brillouin zone. While doing so, we will add some artificial broadening along the energy axis with broaden_energy. To use this function, it is necessary to define kernel function with the form, kernel(œâ, œâ‚ÇÄ), where œâ is energy and œâ‚ÇÄ is the center frequency of the kernel. In this example we apply some Lorentzian broadening using an anonymous function: (œâ, œâ‚ÇÄ) -> lorentzian(œâ-œâ‚ÇÄ, 0.1).","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"qpoints = [[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [0.5, 0.5, 0.0], [0.0, 0.0, 0.0]]\nqs, markers = connected_path(qpoints, 50)\n\nis = intensities(sf, qs, :trace; interpolation=:none)\nis_broad = broaden_energy(sf, is, (œâ, œâ‚ÇÄ) -> lorentzian(œâ-œâ‚ÇÄ, 0.1))\n\n# Plot results\nfig = Figure(; resolution=(1000,400))\nxticklabels = [string(tuple(qs[i]...)) for i in markers]\nplotparams = (;\n    aspect=1.4,\n    ylabel = \"œâ (meV)\",\n    xlabel = \"ùê™ (RLU)\",\n    xticks=(markers, xticklabels),\n    xticklabelrotation=œÄ/10,\n    xticklabelsize=14,\n)\ncolorrange = (0,0.5)\nax1 = Axis(fig[1,1]; title=\"No artificial broadening\", plotparams...)\nheatmap!(ax1, 1:size(is, 1), œâs(sf), is; colorrange)\nax2 = Axis(fig[1,2]; title=\"Lorentzian broadening (Œ∑=0.1)\", plotparams...)\nheatmap!(ax2, 1:size(is, 1), œâs(sf), is_broad; colorrange)\nfig","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"(Image: )","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"We next write a simple powder averaging function that takes a structure factor, a list of radius values (√Ö‚Åª¬π), and a density (√Ö‚Åª¬≤) to control the number of wave vectors to sample at each radius. For each radius r, the function will generate wavevectors on a sphere of this radius and retrieve their intensities. The results will then be averaged to produce a single vector of energy-intensities for that r. Note that our powder_average function passes most of its keywords through to intensities, so it can be given kT, formfactors, etc., and these parameters will be applied to the calculation.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"function powder_average(sf, rs, density; Œ∑=0.1, mode=:perp, kwargs...)\n    nœâ = length(œâs(sf))\n    output = zeros(Float64, length(rs), nœâ)\n\n    for (i, r) in enumerate(rs)\n        qs = spherical_shell(sf, r, density)  # Get points on a sphere of radius r\n        if length(qs) == 0\n            qs = [[0., 0., 0.]]  # If no points (r is too small), just look at 0 vector\n        end\n        vals = intensities(sf, qs, mode; kwargs...)  # Retrieve energy intensities\n        vals = broaden_energy(sf, vals, (œâ,œâ‚ÇÄ)->lorentzian(œâ-œâ‚ÇÄ, Œ∑))  # Apply Lorentzian broadening\n        output[i,:] = reshape(mean(vals, dims=1), (nœâ,))  # Average single radius results and save\n    end\n\n    return output\nend;","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Finally, we perform the calculation,","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"rs = range(0, 3.5, length=50)  # Set of radius values\nŒ∑ = 0.05                       # Lorentzian broadening parameter\ndensity = 4.0                  # Number of samples in √Ö‚Åª¬≤\n\npa = powder_average(sf, rs, density; Œ∑, kT);","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"and plot the results.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"fig = Figure()\nax = Axis(fig[1,1];\n    xlabel = \"|Q| (√Ö‚Åª¬π)\",\n    ylabel = \"œâ (meV)\",\n)\nheatmap!(ax, rs, œâs(sf), pa; colorrange=(0,5.0))\nfig","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"(Image: )","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"Note that the results approximately share the characteristic bandwidth already seen in the single crystal results.","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"","category":"page"},{"location":"literate_build/powder_averaging/","page":"Powder Averaging","title":"Powder Averaging","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"EditURL = \"https://github.com/SunnySuite/Sunny.jl/blob/main/examples/fei2_tutorial.jl\"","category":"page"},{"location":"literate_build/fei2_tutorial/#Case-Study:-FeI_{2}","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"FeI_2 is an effective spin-1 material with strong single-ion anisotropy, making it an excellent candidate for treatment with SU(3) spin dynamics. In particular, one of the elementary excitations of the system can only be captured clasically with an SU(3) treatment. A magnon, clearly visible in the experimental data, would simply be absent if we were to employ traditional Landau-Lifshitz dynamics or SU(2) spin wave theory. Full details about the model can be found in reference [1].","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The model contains a number of competing, anisotropic exchange interactions together with a strong single-ion anisotropy. Writing the exchange terms in the most general way, the Hamiltonian has the form:","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"mathcalH=sum_(ij) J^alphabeta_ij S^alpha_i S^beta_j - Dsum_i left(S^zright)^2","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"We will calculate a dynamic structure factor using this model. We begin by importing the required packages, starting with Sunny. We will also add GLMakie, a plotting package. If you see Package X not found in current path, you can install the package by entering using Pkg; pkg\"add X\" in the Julia REPL.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"using Sunny, LinearAlgebra, GLMakie","category":"page"},{"location":"literate_build/fei2_tutorial/#Crystals-and-symmetry-analysis","page":"Case Study: FeI_2","title":"Crystals and symmetry analysis","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A Crystal describes the crystallographic unit cell and will usually be loaded from a .cif file. Here, we instead build a crystal by listing all atoms in the conventional unit cell.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"a = b = 4.05012  # Lattice constants for triangular lattice\nc = 6.75214      # Spacing in the z-direction\n\nlat_vecs = lattice_vectors(a, b, c, 90, 90, 120) # A 3x3 matrix of lattice vectors that\n                                                 # define the conventional unit cell\nbasis_vecs = [[0,0,0], [1/3, 2/3, 1/4], [2/3, 1/3, 3/4]]  # Positions of atoms in fractions\n                                                          # of lattice vectors\ntypes = [\"Fe\", \"I\", \"I\"]\nFeI2 = Crystal(lat_vecs, basis_vecs; types)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Crystal\nHM symbol 'P -3 m 1' (164)\nLattice params a=4.05, b=4.05, c=6.752, Œ±=90¬∞, Œ≤=90¬∞, Œ≥=120¬∞\nCell volume 95.92\nType 'Fe', Wyckoff 1a (point group '-3m.'):\n   1. [0, 0, 0]\nType 'I', Wyckoff 2d (point group '3m.'):\n   2. [0.3333, 0.6667, 0.25]\n   3. [0.6667, 0.3333, 0.75]\n","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Observe that Sunny indentified the correct space group, 'P -3 m 1' (164).","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Only the Fe atoms are magnetic, so we discard the I ions using subcrystal.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"cryst = subcrystal(FeI2, \"Fe\")","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Crystal\nHM symbol 'P -3 m 1' (164)\nLattice params a=4.05, b=4.05, c=6.752, Œ±=90¬∞, Œ≤=90¬∞, Œ≥=120¬∞\nCell volume 95.92\nType 'Fe', Wyckoff 1a (point group '-3m.'):\n   1. [0, 0, 0]\n","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Importantly, cryst retains the spacegroup symmetry information for the full FeI2 crystal. This information will be used, for example, to propagate exchange interactions by symmetry.","category":"page"},{"location":"literate_build/fei2_tutorial/#Spin-systems","page":"Case Study: FeI_2","title":"Spin systems","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"To simulate a system of many spins, construct a System.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys = System(cryst, (4,4,4), [SpinInfo(1,S=1)], :SUN, seed=0)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"System [SU(3)]\nCell size 1, Lattice size (4, 4, 4)\n","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Our system includes 444 unit cells, i.e. 64 spin moments, each with spin S=1. The default g-factor is 2, but this could be overriden with an additional argument to SpinInfo. Each spin-1 has N=2S+1=3 distinct angular momentum states. In :SUN mode, these spins will be modeled using the dynamics of SU(3) coherent states, which includes both dipolar and quadrupolar fluctuations. For the more traditional dipole dynamics, use :dipole mode instead.","category":"page"},{"location":"literate_build/fei2_tutorial/#Interactions-and-anisotropies","page":"Case Study: FeI_2","title":"Interactions and anisotropies","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/#Symmetry-analysis","page":"Case Study: FeI_2","title":"Symmetry analysis","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The next step is to add interactions to the system. The command print_symmetry_table shows all symmetry-allowed interactions up to a distance cutoff.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"print_symmetry_table(cryst, 8.0)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Site 1\nType 'Fe', position [0, 0, 0], multiplicity 1\nAllowed g-tensor: | A  0  0 |\n                  | 0  A  0 |\n                  | 0  0  B |\nAllowed anisotropy in Stevens operators ùí™[k,q]:\n    c‚ÇÅ*ùí™[2,0] +\n    c‚ÇÇ*ùí™[4,-3] + c‚ÇÉ*ùí™[4,0] +\n    c‚ÇÑ*ùí™[6,-3] + c‚ÇÖ*ùí™[6,0] + c‚ÇÜ*ùí™[6,6]\n\nBond(1, 1, [1, 0, 0])\nDistance 4.05012, coordination 6\nConnects 'Fe' at [0, 0, 0] to 'Fe' at [1, 0, 0]\nAllowed exchange matrix: | A  0  0 |\n                         | 0  B  D |\n                         | 0  D  C |\n\nBond(1, 1, [0, 0, 1])\nDistance 6.75214, coordination 2\nConnects 'Fe' at [0, 0, 0] to 'Fe' at [0, 0, 1]\nAllowed exchange matrix: | A  0  0 |\n                         | 0  A  0 |\n                         | 0  0  B |\n\nBond(1, 1, [1, 2, 0])\nDistance 7.01501361675086, coordination 6\nConnects 'Fe' at [0, 0, 0] to 'Fe' at [1, 2, 0]\nAllowed exchange matrix: | A  0  0 |\n                         | 0  B  D |\n                         | 0  D  C |\n\nBond(1, 1, [1, 0, 1])\nDistance 7.8736818956572, coordination 12\nConnects 'Fe' at [0, 0, 0] to 'Fe' at [1, 0, 1]\nAllowed exchange matrix: | A  F  E |\n                         | F  B  D |\n                         | E  D  C |\n\n","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The allowed g-tensor is expressed as a 3√ó3 matrix in the free coefficients A, B, ... The allowed single-ion anisotropy is expressed as a linear combination of Stevens operators. The latter correspond to polynomials of the spin operators, as we will describe below.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The allowed exchange interactions are given as a 3√ó3 matrix for representative bonds. The notation Bond(i, j, n) indicates a bond between atom indices i and j, with cell offset n. In the general case, it will be necessary to associate atom indices with their positions in the unit cell; these can be viewed with display(cryst). Note that the order of the pair (i j) is significant if the exchange tensor contains antisymmetric Dzyaloshinskii‚ÄìMoriya (DM) interactions.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"As an example, Bond(1, 1, [1,0,0]) involves an offset of one unit cell in the direction of the first lattice vector. In the case of FeI2, this is one of the 6 nearest-neighbor Fe-Fe bonds on the triangular lattice.","category":"page"},{"location":"literate_build/fei2_tutorial/#Assigning-interactions-and-anisotropies","page":"Case Study: FeI_2","title":"Assigning interactions and anisotropies","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function set_exchange! assigns an exchange interaction to a bond, and will propagate the interaction to all symmetry-equivalent bonds in the unit cell. The FeI2 interactions below follow Ref. [1].","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"J1pm   = -0.236\nJ1pmpm = -0.161\nJ1zpm  = -0.261\nJ2pm   = 0.026\nJ3pm   = 0.166\nJ‚Ä≤0pm  = 0.037\nJ‚Ä≤1pm  = 0.013\nJ‚Ä≤2apm = 0.068\n\nJ1zz   = -0.236\nJ2zz   = 0.113\nJ3zz   = 0.211\nJ‚Ä≤0zz  = -0.036\nJ‚Ä≤1zz  = 0.051\nJ‚Ä≤2azz = 0.073\n\nJ1xx = J1pm + J1pmpm\nJ1yy = J1pm - J1pmpm\nJ1yz = J1zpm\n\nset_exchange!(sys, [J1xx   0.0    0.0;\n                    0.0    J1yy   J1yz;\n                    0.0    J1yz   J1zz], Bond(1,1,[1,0,0]))\nset_exchange!(sys, [J2pm   0.0    0.0;\n                    0.0    J2pm   0.0;\n                    0.0    0.0    J2zz], Bond(1,1,[1,2,0]))\nset_exchange!(sys, [J3pm   0.0    0.0;\n                    0.0    J3pm   0.0;\n                    0.0    0.0    J3zz], Bond(1,1,[2,0,0]))\nset_exchange!(sys, [J‚Ä≤0pm  0.0    0.0;\n                    0.0    J‚Ä≤0pm  0.0;\n                    0.0    0.0    J‚Ä≤0zz], Bond(1,1,[0,0,1]))\nset_exchange!(sys, [J‚Ä≤1pm  0.0    0.0;\n                    0.0    J‚Ä≤1pm  0.0;\n                    0.0    0.0    J‚Ä≤1zz], Bond(1,1,[1,0,1]))\nset_exchange!(sys, [J‚Ä≤2apm 0.0    0.0;\n                    0.0    J‚Ä≤2apm 0.0;\n                    0.0    0.0    J‚Ä≤2azz], Bond(1,1,[1,2,1]))","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function set_anisotropy! assigns a single-ion anisotropy. It takes an abstract operator and an atom index. The operator may be a polynomial of spin operators or a linear combination of Stevens operators. Sunny provides special symbols for their construction: ùíÆ is a vector of the three spin operators and ùí™ are the symbolic Stevens operators. Here we construct an easy-axis anisotropy.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"D = 2.165\nset_anisotropy!(sys, -D*ùíÆ[3]^2, 1)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Any ansotropy operator can be converted to a linear combination of Stevens operators with print_anisotropy_as_stevens.","category":"page"},{"location":"literate_build/fei2_tutorial/#Calculating-a-dynamical-spin-structure-factor","page":"Case Study: FeI_2","title":"Calculating a dynamical spin structure factor","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"In the remainder of this tutorial, we will examine Sunny's tools for calculating structure factors using generalized SU(N) classical dynamics. This will involve sampling of the spin configurations from the Boltzmann distribution at a finite temperature. Dynamical trajectories will then be used to estimate the finite-temperature structure factor mathcalS^alphabeta(mathbfqomega).","category":"page"},{"location":"literate_build/fei2_tutorial/#Simulated-annealing","page":"Case Study: FeI_2","title":"Simulated annealing","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The Langevin dynamics can be used to sample spin configurations in thermal equlibrium.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"E0 = 2.165        # Largest energy scale in the Hamiltonian\nŒît = 0.05/E0      # Safe choice for integration step size\nŒª = 0.1           # Magnitude of coupling to thermal bath\nlangevin = Langevin(Œît, 0, Œª);","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Search for a low-energy spin configuration by lowering the temperature from E0 to 0 over nsteps of Langevin dynamics.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"randomize_spins!(sys)\nnsteps = 10_000\nfor kT in range(E0, 0, nsteps)\n    langevin.kT = kT\n    step!(sys, langevin)\nend","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The annealed configuration can be visualized with plot_spins.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"plot_spins(sys; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The annealed magnetic order contains defects. To fix this, we could repeat the patient annealing procedure using many more time-steps. Instead, let's analyze the imperfect spin configuration stored in sys.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function print_dominant_wavevectors orders wavevectors by their contributions to the static structure factor intensity (1st BZ only).","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"print_dominant_wavevectors(sys)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Dominant wavevectors for spin sublattices:\n\n    [1/4, 0, 1/4]          24.06% weight\n    [-1/4, 0, -1/4]        24.06%\n    [1/4, 0, 1/2]           7.22%\n    [-1/4, 0, 1/2]          7.22%\n    [1/4, 0, 0]             5.05%\n    [-1/4, 0, 0]            5.05%\n    [0, -1/4, 1/4]          2.66%\n    [0, 1/4, -1/4]          2.66%\n    [0, 1/4, 1/4]           2.34%\n    [0, -1/4, -1/4]         2.34%\n    [-1/4, 1/4, 1/4]        1.97%\n    ...                     ...\n","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The above is consistent with known results. The zero-field energy-minimizing magnetic structure of FeI_2 is single-q. If annealing were perfect, then spontaneous symmetry breaking would select one of q = 0 -14 14, 14 0 14, or -141414.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Let's break the symmetry by hand. Given a list of q modes, Sunny can suggest a magnetic supercell with appropriate periodicity. The result is printed in units of the crystal lattice vectors.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"suggest_magnetic_supercell([[0, -1/4, 1/4]], sys.latsize)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Suggested magnetic supercell in multiples of lattice vectors:\n\n    A = [1 0 0; 0 1 -2; 0 1 2]\n\nfor wavevectors [[0, -1/4, 1/4]].\n","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The function reshape_geometry allows an arbitrary reshaping of the system. Using the supercell geometry makes it much easier to find the energy-minimizing spin configuration.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys_supercell = reshape_geometry(sys, [1 0 0; 0 1 -2; 0 1 2])\n\nlangevin.kT = 0\nfor i in 1:10_000\n    step!(sys_supercell, langevin)\nend\n\nplot_spins(sys_supercell; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"We can now resize the magnetic supercell to a much larger simulation volume, provided as multiples of the original unit cell.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sys_large = resize_periodically(sys_supercell, (16,16,4))\nplot_spins(sys_large; arrowlength=2.5, linewidth=0.75, arrowsize=1.5)","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/#Calculating-the-structure-factor","page":"Case Study: FeI_2","title":"Calculating the structure factor","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Apply the Langevin dynamics to thermalize the system to 0.5K. Note that the number of time-steps required to decorrelate may vary significantly for different systems and thermodynamic conditions.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"kT = 0.5 * meV_per_K     # 0.5K in units of meV\nlangevin.kT = kT\n\nfor _ in 1:10_000\n    step!(sys_large, langevin)\nend","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"With our equilibrated system, we can begin to measure the DynamicStructureFactor. Three keyword parameters are required to determine the œâ information that will be calculated: an integration step size, the number of œâs to resolve, and the maximum œâ to resolve. For the time step, twice the value used for the Langevin integrator is usually a good choice.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sf = DynamicStructureFactor(sys_large; Œît=2Œît, nœâ=120, œâmax=7.5);","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"sf currently contains dynamical structure data generated from a single sample. Additional samples can be added by generating a new spin configuration and calling add_sample!:","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"for _ in 1:2\n    for _ in 1:1000               # Fewer steps needed in equilibrium\n        step!(sys_large, langevin)\n    end\n    add_sample!(sf, sys_large)    # Accumulate the sample into `sf`\nend","category":"page"},{"location":"literate_build/fei2_tutorial/#Accessing-structure-factor-data","page":"Case Study: FeI_2","title":"Accessing structure factor data","text":"","category":"section"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"The basic function for accessing intensity data is intensities, which, in addition to the structure factor data itself, takes a list of wave vectors and a mode parameter. The options for the mode parameter are :trace, :perp and :full which return, respectively, the trace, the unpolarized intensity, and the full set of matrix elements (correlations of spin components) at the specified wave vectors. For example, we can plot two single-q slices as follows.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"qs = [[0, 0, 0], [0.5, 0.5, 0.5]]\nis = intensities(sf, qs, :trace; kT)\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel=\"meV\", ylabel=\"Intensity\")\nl1 = lines!(ax, œâs(sf), is[1,:])\nl2 = lines!(ax, œâs(sf), is[2,:])\nLegend(fig[1,2], [l1, l2], [\"(0,0,0)\", \"(œÄ,œÄ,œÄ)\"])\nfig","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Note that we provided the optional keyword kT to intensities to enable Sunny to apply a classical-to-quantum rescaling of intensities.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Frequently we want to extract energy intensities along lines that connect special wave vectors. Sunny provides a function connected_path to makes this easy. The density of sample points can be tuned with a density argument.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"points = [[0.0, 0.0, 0.0],  # List of wave vectors that define a path\n          [1.0, 0.0, 0.0],\n          [0.0, 1.0, 0.0],\n          [0.5, 0.0, 0.0],\n          [0.0, 1.0, 0.0],\n          [0.0, 0.0, 0.0]]\nformfactors = [FormFactor(1, \"Fe2\"; g_lande=3/2)]  # Ion information for each site to\n                                                   # retrieve form factor correction parameters\ndensity = 40\npath, markers = connected_path(points, density)\n\nis = intensities(sf, path, :perp;\n    interpolation = :linear,       # Interpolate between available wave vectors\n    kT,                            # Temperature for intensity correction\n    formfactors,                   # Form factor information\n)\n\nfig = Figure()\nlabels = [\"($(p[1]),$(p[2]),$(p[3]))\" for p in points]\nax = Axis(fig[1,1];\n    ylabel = \"meV\",\n    xticks = (markers, labels),\n    xticklabelrotation=œÄ/8,\n    xticklabelsize=12,\n)\nheatmap!(ax, 1:size(is,1), œâs(sf), is; colorrange=(0.0, 0.5))\nfig","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Often it is useful to plot cuts across multiple wave vectors but at a single energy.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"npoints = 60\nqvals = range(-2.0, 2.0, length=npoints)\nqs = [[a, b, 0.0] for a in qvals, b in qvals]\nforfactors = [FormFactor(1, \"Fe2\")]\n\nis = intensities(sf, qs, :perp;\n    interpolation = :linear,\n    kT,\n    formfactors,\n);\n\nœâidx = 30\nœâ = œâs(sf)[œâidx]\nfig = Figure()\nax = Axis(fig[1,1]; title=\"œâ=$œâ meV\", aspect=true)\nhidedecorations!(ax); hidespines!(ax)\nhm = heatmap!(ax, is[:,:,œâidx])\nColorbar(fig[1,2], hm)\nfig","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Note that Brillouin zones appear \"skewed\". This is a consequence of the fact that our reciprocal lattice vectors are not orthogonal. It is often useful to express our wave vectors in terms of an orthogonal basis, where each basis element is specified as a linear combination of reciprocal lattice vectors. For our crystal, with reciprocal vectors a^*, b^* and c^*, we can define an orthogonal basis by taking hata^* = 05(a^* + b^*), hatb^*=a^* - b^*, and hatc^*=c^*. Below, we map qs to wavevectors ks in the new coordinate system and get their intensities.","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"A = [0.5  1.0 0.0;\n     0.5 -1.0 0.0;\n     0.0  0.0 1.0]\nks = [A*q for q in qs]\n\nis_ortho = intensities(sf, ks, :perp;\n    interpolation = :linear,\n    kT,\n    formfactors,\n);\n\nfig = Figure()\nax = Axis(fig[1,1]; title=\"œâ=$œâ meV\", aspect=true)\nhidedecorations!(ax); hidespines!(ax)\nhm = heatmap!(ax, is_ortho[:,:,œâidx])\nColorbar(fig[1,2], hm)\nfig","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"Finally, we note that static structure factor data can be obtained from a dynamic structure factor with static_intensities:","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"is_static = static_intensities(sf, ks, :perp;\n    interpolation = :linear,\n    kT,\n    formfactors,\n)\n\nfig = Figure()\nax = Axis(fig[1,1]; title=\"Static Structure Factor\", aspect=true)\nhidedecorations!(ax); hidespines!(ax)\nhm = heatmap!(ax, is_static)\nColorbar(fig[1,2], hm)\nfig","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"(Image: )","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"","category":"page"},{"location":"literate_build/fei2_tutorial/","page":"Case Study: FeI_2","title":"Case Study: FeI_2","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Sunny.jl","page":"Overview","title":"Sunny.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Sunny is a package for simulating classical spin systems, including the Landau-Lifshitz dynamics of spin dipoles and its generalization to multipolar spin components. In the latter case, Sunny resolves the local quantum structure of individual spins, making it particularly suited for modeling magnetic compounds with strong local anisotropy.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Sunny provides the following features:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Generalization of Landau-Lifshitz spin dynamics using the formalism of SU(N) coherent states.\nAbility specify a crystal by a .cif file, or using its spacegroup symmetry.\nSymmetry analysis to classify allowed Hamiltonian terms, and to automatically populate all symmetry equivalent interactions.\nSingle-ion anisotropy at arbitrary order, which can be specified using Stevens operators or as an arbitrary polynomial of spin operators.\nSampling of spin configurations from the classical Boltzmann distribution at finite-T.\nQuasi-linear scaling dipole-dipole interactions via the fast Fourier transform (FFT) (Langevin mode only).\nMeasurement of mathcalS(mathbfq omega) structure factor data.\nInteractive visualizations of the 3D crystal structure and spin states (support for 3D structure factors is planned.)\nDistributed implementation of parallel tempering to increase sampling efficiency.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A current limitation of Sunny is that it requires real-space dynamical simulations to measure the structure factor, and this limits momentum-space resolution. Support for linear spin wave theory and its SU(N) generalization is in progress.","category":"page"},{"location":"quick-start/#Install-Julia-and-Sunny","page":"Quick Start","title":"Install Julia and Sunny","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Download Julia 1.8 or later. Run the Julia executable, which should open a terminal with the prompt: julia>. Load Sunny with the command:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using Sunny","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"If Sunny has not yet been installed, Julia will ask your permission to download and install it within the Julia environment.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One way to interact with Sunny is through a Jupyter notebook,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using IJulia\nnotebook()","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"If you see an error about a missing a Julia kernel, you can usually fix this with ] build IJulia from the Julia terminal.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For more information about Julia, see the Getting Started guide.","category":"page"},{"location":"quick-start/#Browse-a-Sunny-notebook","page":"Quick Start","title":"Browse a Sunny notebook","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To get a feeling for Sunny, a good place to start is the FeI2 case study tutorial notebook. Additional tutorials are available.","category":"page"},{"location":"quick-start/#Example-usage","page":"Quick Start","title":"Example usage","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"At the Julia prompt, create a diamond cubic crystal using the Crystal constructor:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"crystal = Crystal(lattice_vectors(1, 1, 1, 90, 90, 90), [[0,0,0]], 227; setting=\"1\")","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The first argument defines a unit cell via the convenience function lattice_vectors. The second argument is a list of basis atom positions. The third, optional argument specifies an international spacegroup number (if it's missing, Sunny will infer a spacegroup). Arguments appearing after the semicolon ; are named. Here, we are selecting the first (out of two) setting conventions for spacegroup 227.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny outputs:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Crystal\nHM symbol 'F d -3 m' (227)\nLattice params a=1, b=1, c=1, Œ±=90¬∞, Œ≤=90¬∞, Œ≥=90¬∞\nCell volume 1\nWyckoff 8a (point group '-43m'):\n   1. [0, 0, 0]\n   2. [0.5, 0.5, 0]\n   3. [0.25, 0.25, 0.25]\n   4. [0.75, 0.75, 0.25]\n   5. [0.5, 0, 0.5]\n   6. [0, 0.5, 0.5]\n   7. [0.75, 0.25, 0.75]\n   8. [0.25, 0.75, 0.75]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Observe that Sunny filled all eight symmetry-equivalent atom positions for the diamond cubic unit cell. The coordinates are measured in units of the lattice vectors.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Alternatively, Sunny can read the crystal structure from a .cif file. Or, if a complete list of atoms is provided, Sunny can infer the spacegroup symmetry using spglib.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The crystal object can be used as an argument to other Sunny functions. For example, print_symmetry_table lists all symmetry-allowed exchange interactions up to a maximum distance,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"print_symmetry_table(crystal, 0.8)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"which prints,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Site 1\nPosition [0, 0, 0], multiplicity 8\nAllowed g-tensor: | A  0  0 |\n                  | 0  A  0 |\n                  | 0  0  A |\nAllowed anisotropy in Stevens operators ùí™[k,q]:\n    c‚ÇÅ*(ùí™[4,0]+5ùí™[4,4]) +\n    c‚ÇÇ*(ùí™[6,0]-21ùí™[6,4])\n\nBond(1, 3, [0, 0, 0])\nDistance 0.433, coordination 4\nConnects [0, 0, 0] to [0.25, 0.25, 0.25]\nAllowed exchange matrix: | A  B  B |\n                         | B  A  B |\n                         | B  B  A |\n\nBond(1, 2, [0, 0, 0])\nDistance 0.7071, coordination 12\nConnects [0, 0, 0] to [0.5, 0.5, 0]\nAllowed exchange matrix: | A  C -D |\n                         | C  A -D |\n                         | D  D  B |\nAllowed DM vector: [-D D 0]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny reported that a single-ion anisotropy is only allowed at quartic and hexic orders, which is consistent with the cubic point group symmetry. Additionally, Sunny reported the allowed forms of nearest and next-nearest neighbor interaction.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The next steps are typically the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Build a System which contains spins on a finite size lattice of crystal unit cells.\nAdd interactions to the system using functions like set_external_field!, set_exchange!, and set_anisotropy!.\nPerform Monte Carlo simulation to equilibrate the spin configuration. Options include the continuous Langevin dynamics, or single-spin flip updates with LocalSampler. The former can efficiently handle long-range dipole-dipole interactions, while the latter may be better in the presence of strong anisotropy (e.g., the Ising limit).\nMeasure the static or dynamical structure factor. For details, see the page Structure Factor Calculations.","category":"page"}]
}
