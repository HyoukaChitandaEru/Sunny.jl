var documenterSearchIndex = {"docs":
[{"location":"library/#Library-API","page":"Library API","title":"Library API","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter ? at the Julia command prompt).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Typical Sunny usage will involve the following steps:","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Create a Crystal, either by providing explicit geometry information or by loading a .cif file.\nPerform symmetry analysis using print_symmetry_table.\nDefine a list of Interactions, i.e., terms to be included in the Hamiltonian.\nSpecify information for each site through a SiteInfo object that specifies, e.g., local spin magnitude and g-tensor.\nAssemble a SpinSystem using the crystal, the interactions, the dimensions of the simulation box (in unit cells), and the site information.\nPerform some flavor of Monte Carlo simulation, which is used to sample equilibrated spin configurations.\nMeasure the static or dynamical structure factor. For this, Sunny provides high-level helper functions dynamic_structure_factor and static_structure_factor. For more documentation, see Structure factor calculations.","category":"page"},{"location":"library/#Crystal-definition","page":"Library API","title":"Crystal definition","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"Crystal\nCrystal(lat_vecs, positions; types, symprec)\nCrystal(::AbstractString; symprec)\nsubcrystal\nnbasis\ncell_volume\nlattice_vectors\nlattice_params","category":"page"},{"location":"library/#Sunny.Crystal","page":"Library API","title":"Sunny.Crystal","text":"Crystal\n\nA type holding all geometry and symmetry information needed to represent  a three-dimensional crystal.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal-Tuple{Any, Any}","page":"Library API","title":"Sunny.Crystal","text":"Crystal(lat_vecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, representing fractions (between 0 and 1) of the lattice vectors lat_vecs. All symmetry information is automatically inferred.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.Crystal-Tuple{AbstractString}","page":"Library API","title":"Sunny.Crystal","text":"Crystal(filename::AbstractString; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal","page":"Library API","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\n\n\n\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.nbasis","page":"Library API","title":"Sunny.nbasis","text":"nbasis(crystal::Crystal)\n\nNumber of basis positions (sublattices) in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.cell_volume","page":"Library API","title":"Sunny.cell_volume","text":"cell_volume(crystal::Crystal)\n\nVolume of the crystal unit cell.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.lattice_vectors","page":"Library API","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Œ± Œ≤ Œ≥).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.lattice_params","page":"Library API","title":"Sunny.lattice_params","text":"lattice_params(lat_vecs::Mat3)\n\nCompute the lattice parameters (a b c Œ± Œ≤ Œ≥) from a set of lattice vectors,  which form the columns of lat_vecs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Symmetry-analysis","page":"Library API","title":"Symmetry analysis","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"Bond\ndisplacement\ndistance\ncoordination_number\nprint_site\nprint_bond\nprint_symmetry_table\nprint_anisotropy_as_stevens\nreference_bonds\nall_symmetry_related_bonds\nall_symmetry_related_bonds_for_atom\nall_symmetry_related_couplings\nall_symmetry_related_couplings_for_atom","category":"page"},{"location":"library/#Sunny.Bond","page":"Library API","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.displacement","page":"Library API","title":"Sunny.displacement","text":"displacement(cryst::Crystal, b::Bond)\n\nThe displacement vector ùê´_j - ùê´_i in global coordinates between atoms b.i and b.j, accounting for the integer offsets b.n between unit cells.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.distance","page":"Library API","title":"Sunny.distance","text":"distance(cryst::Crystal, b::Bond)\n\nThe global distance between atoms in bond b. Equivalent to norm(displacement(cryst, b)).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.coordination_number","page":"Library API","title":"Sunny.coordination_number","text":"coordination_number(cryst::Crystal, i::Int, b::Bond)\n\nReturns the number times that atom i participates in a bond equivalent to b. In other words, the count of bonds that begin at atom i and that are symmetry-equivalent to b or its reverse.\n\nDefined as length(all_symmetry_related_bonds_for_atom(cryst, i, b)).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_site","page":"Library API","title":"Sunny.print_site","text":"print_site(cryst, i; R=I)\n\nPrint symmetry information for the site i, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix R can be provided to define the reference frame for expression of the anisotropy.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_bond","page":"Library API","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond)\n\nPrints symmetry information for bond bond.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_symmetry_table","page":"Library API","title":"Sunny.print_symmetry_table","text":"print_symmetry_table(cryst::Crystal, max_dist)\n\nPrint symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist), where Bond(i, i, [0,0,0]) refers to a single site i.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_anisotropy_as_stevens","page":"Library API","title":"Sunny.print_anisotropy_as_stevens","text":"function print_anisotropy_as_stevens(p; N)\n\nPrints a quantum operator (e.g. a polynomial of the spin operators ùíÆ) as a linear combination of Stevens operators in the classical limit. The symbol X denotes the spin magnitude squared, |ùíÆ|^2.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.reference_bonds","page":"Library API","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_bonds","page":"Library API","title":"Sunny.all_symmetry_related_bonds","text":"all_symmetry_related_bonds(cryst::Crystal, b::Bond)\n\nReturns a list of all bonds that are symmetry-equivalent to bond b or its reverse.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_bonds_for_atom","page":"Library API","title":"Sunny.all_symmetry_related_bonds_for_atom","text":"all_symmetry_related_bonds_for_atom(cryst::Crystal, i::Int, b::Bond)\n\nReturns a list of all bonds that start at atom i, and that are symmetry equivalent to bond b or its reverse.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_couplings","page":"Library API","title":"Sunny.all_symmetry_related_couplings","text":"all_symmetry_related_couplings(cryst::Crystal, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_couplings_for_atom","page":"Library API","title":"Sunny.all_symmetry_related_couplings_for_atom","text":"all_symmetry_related_couplings_for_atom(cryst::Crystal, i::Int, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds (constrained to start from atom i), and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Interactions","page":"Library API","title":"Interactions","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"anisotropy\nheisenberg\ndm_interaction\nexchange\nexternal_field\ndipole_dipole","category":"page"},{"location":"library/#Sunny.anisotropy","page":"Library API","title":"Sunny.anisotropy","text":"anisotropy(op, site)\n\nCreates a general anisotropy specified as a polynomial of spin operators ùíÆ or Stevens operators ùí™.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.heisenberg","page":"Library API","title":"Sunny.heisenberg","text":"heisenberg(J, bond::Bond, label::String=\"Heisen\")\n\nCreates a Heisenberg interaction\n\n    J _ij ùêí_i  ùêí_j\n\nwhere ij runs over all bonds symmetry equivalent to bond.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dm_interaction","page":"Library API","title":"Sunny.dm_interaction","text":"dm_interaction(DMvec, bond::Bond, label::String=\"DMInt\")\n\nCreates a DM Interaction\n\n    _ij ùêÉ^(ij)  (ùêí_i  ùêí_j)\n\nwhere ij runs over all bonds symmetry equivalent to bond, and ùêÉ^(ij) is the covariant transformation of the DM pseudo-vector DMvec appropriate for the bond ij.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.exchange","page":"Library API","title":"Sunny.exchange","text":"exchange(J, bond::Bond, label=\"Exchange\")\n\nCreates a quadratic interaction,\n\n    _ij ùêí_i^T J^(ij) ùêí_j\n\nwhere ij runs over all bonds (not doubly counted) that are symmetry equivalent to bond. The 3  3 interaction matrix J^(ij) is the covariant transformation of J appropriate for the bond ij.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.external_field","page":"Library API","title":"Sunny.external_field","text":"external_field(B::Vec3)\n\nAdds an external field ùêÅ with Zeeman coupling,\n\n    -_i ùêÅ  ùêå_i\n\nThe magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and the spin magnitude ùêí_i is typically a multiple of 1/2. The Bohr magneton Œº_B is a physical constant, with numerical value determined by the unit system.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dipole_dipole","page":"Library API","title":"Sunny.dipole_dipole","text":"dipole_dipole(; extent::Int=4, Œ∑::Float64=0.5)\n\nIncludes long-range dipole-dipole interactions,\n\n    -(Œº‚ÇÄ4œÄ) _ij  (3 (ùêå_jùê´_ij)(ùêå_iùê´_ij) - ùêå_iùêå_j)  ùê´_ij^3\n\nwhere the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and the spin magnitude ùêí_i is typically a multiple of 1/2. The Bohr magneton Œº_B and vacuum permeability Œº_0 are physical constants, with numerical values determined by the unit system.\n\nextent controls the number of periodic copies of the unit cell summed over in the Ewald summation (higher is more accurate, but higher creation-time cost), while Œ∑ controls the direct/reciprocal-space tradeoff in the Ewald summation.\n\n\n\n\n\n","category":"function"},{"location":"library/#System-definition","page":"Library API","title":"System definition","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"SpinSystem\nSpinSystem(::Crystal, ::Vector{<:Sunny.AbstractInteraction}, latsize, ::Vector{SiteInfo}; ŒºB, Œº0)\nSiteInfo\nrand!(::SpinSystem{N}) where N\nrandflips!\nenergy\nfield\nfield!","category":"page"},{"location":"library/#Sunny.SpinSystem","page":"Library API","title":"Sunny.SpinSystem","text":"Defines a collection of spins, as well as the Hamiltonian they interact under.  This is the main type to interface with most of the package.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinSystem-Tuple{Crystal, Vector{<:Sunny.AbstractInteraction}, Any, Vector{SiteInfo}}","page":"Library API","title":"Sunny.SpinSystem","text":"SpinSystem(crystal::Crystal, ints::Vector{<:AbstractInteraction}, latsize, site_infos::Vector{SiteInfo}=[];\n           ŒºB, Œº0)\n\nConstruct a SpinSystem with spins of magnitude S residing on the lattice sites  of a given crystal, interactions given by ints, and the number of unit cells along  each lattice vector specified by latsize. Initialized to all spins pointing along  the +ùê≥ direction. ŒºB and Œº0 set the Bohr magneton and vacuum permeability. By  default, these are set so that the unit system is (meV, T, ‚Ñ´).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.SiteInfo","page":"Library API","title":"Sunny.SiteInfo","text":"SiteInfo(site::Int; N=0, g=2*I(3), spin_rescaling=1.0, ff_elem=nothing, ff_lande=nothing)\n\nCharacterizes the degree of freedom located at a given site index.  N (as in SU(N)), specifies the complex dimension of the generalized spins (where N=0 corresponds to traditional, three-component, real classical spins). g is the g-tensor. spin_rescaling is an overall scaling factor for the spin magnitude. When provided to a SpinSystem, this information is automatically propagated to all symmetry-equivalent sites. An error will be thrown if multiple SiteInfos are given for symmetry-equivalent sites.\n\nIn order to calculate form factor corrections, ff_elem must be given a valid argument specifying a magnetic ion. A list of valid names is provided in tables available at: https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html . To calculate second-order form factor corrections, it is also necessary to provide a Lande g-factor (as a numerical value) to ff_lande. For example: SiteInfo(1; ff_elem=\"Fe2\", ff_lande=3/2). Note that for the form factor to be calculated, these keywords must be given values for all unique sites in the unit cell. Please see the documentation to compute_form for more information on the form factor calculation.\n\nNOTE: Currently, N must be uniform for all sites. All sites will be upconverted to the largest specified N.\n\n\n\n\n\n","category":"type"},{"location":"library/#Random.rand!-Union{Tuple{SpinSystem{N}}, Tuple{N}} where N","page":"Library API","title":"Random.rand!","text":"rand!(sys::SpinSystem{N}) where N\n\nRandomly sample all spins from CP^N-1, i.e., from the space of normalized N-component complex coherent states. In the special case of N=0, randomly sample spin dipoles.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.randflips!","page":"Library API","title":"Sunny.randflips!","text":"randflips!(sys::SpinSystem{N}) where N\n\nRandomly \"flip\" every spin with probability 1/2. In the dipole case (N=0), a flip corresponds to sign reversal, ùêí_i  -ùêí_i. In the general case (N0), flipping the coherent state means complex conjugation followed by rotation about the y-axis by œÄ/2.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.energy","page":"Library API","title":"Sunny.energy","text":"energy(sys::SpinSystem)\n\nComputes the energy of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.field","page":"Library API","title":"Sunny.field","text":"Calculates the local field, B·µ¢, for a single site, i:\n\nùêÅ_i = -_ùê¨_i ‚Ñã.\n\nThis is useful for some sampling methods.\n\n\n\n\n\nfield(sys::SpinSystem)\n\nCompute the local field B at each site of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.field!","page":"Library API","title":"Sunny.field!","text":"Updates B in-place to hold the local field on spins under ‚Ñã, defined as:\n\nùêÅ_i = -_ùê¨_i ‚Ñã.\n\n\n\n\n\nfield!(B::Array{Vec3}, sys::SpinSystem)\n\nUpdates B in-place to contain the local field at each site in the system under sys.hamiltonian. The \"local field\" is defined as\n\nùêÅ_i = -_ùê¨_i ‚Ñã  S_i\n\nwith ùê¨_i the unit-vector variable at site i, and S_i is the magnitude of the associated spin.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sampling","page":"Library API","title":"Sampling","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"LangevinSampler\nMetropolisSampler\nIsingSampler\nset_temp!\nsample!\nthermalize!\nanneal!","category":"page"},{"location":"library/#Sunny.LangevinSampler","page":"Library API","title":"Sunny.LangevinSampler","text":"LangevinSampler(sys::SpinSystem, kT::Float64, Œ±::Float64, Œît::Float64, nsteps::Int)\n\nCreates a LangevinSampler which samples the spin system's Hamiltonian using Langevin  dynamics at a temperature kT, damping coefficient Œ±, and producing a new sample  by integrating with nsteps timesteps of size Œît.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.MetropolisSampler","page":"Library API","title":"Sunny.MetropolisSampler","text":"MetropolisSampler(sys::SpinSystem, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to sample  a SpinSystem at the requested temperature.\n\nEach single-spin update attempts to completely randomize the spin. One call to  sample! will attempt to flip each spin nsweeps times.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.IsingSampler","page":"Library API","title":"Sunny.IsingSampler","text":"IsingSampler(sys::SpinSystem, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to sample a SpinSystem at the requested temperature.\n\nThis version differs from MetropolisSampler in that each single-spin update only attempts to completely flip the spin. One call to sample! will attempt to flip each spin nsweeps times.\n\nBefore constructing, be sure that your SpinSystem is initialized so that each spin points along its \"Ising-like\" axis.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.set_temp!","page":"Library API","title":"Sunny.set_temp!","text":"set_temp!(sampler, kT)\n\nChanges the temperature of the sampler to kT.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.sample!","page":"Library API","title":"Sunny.sample!","text":"sample!(sampler)\n\nSamples sampler.sys to a new state, under the Boltzmann distribution  as defined by sampler.sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.thermalize!","page":"Library API","title":"Sunny.thermalize!","text":"thermalize!(sampler, num_samples)\n\nsample! a sampler a given number of times.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.anneal!","page":"Library API","title":"Sunny.anneal!","text":"anneal!(sampler, temp_schedule, step_schedule)\n\nsample! a sampler at a series of temperatures, staying at each temperature   for the number of steps in step_schedule.\n\n\n\n\n\nanneal!(sampler, temp_function, num_samples)\n\nsample! a sampler num_samples times, with the sample at timestep n  drawn at a temperature temp_function(n).\n\n\n\n\n\n","category":"function"},{"location":"library/#Structure-factor-calculations","page":"Library API","title":"Structure factor calculations","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"For extended details on what these functions compute, and how they do it, see the page Structure Factor Calculations","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"StructureFactor\nSunny.update!\napply_dipole_factor\ndynamic_structure_factor\nstatic_structure_factor","category":"page"},{"location":"library/#Sunny.StructureFactor","page":"Library API","title":"Sunny.StructureFactor","text":"StructureFactor\n\nType responsible for computing and updating the static/dynamic structure factor averaged across multiple spin configurations. In general, the user should not create a StructureFactor directly, but instead use the interfaces static_structure_factor and dynamic_structure_factor to have Sunny build one for you.\n\nNote that the initial sys provided does not enter the structure factor, it is purely used to determine the size of various results.\n\nThe full dynamic structure factor is ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = M^Œ±_j(ùê™ œâ) M^Œ≤_k(ùê™ œâ)^, which is an array of shape [3, 3, Q1, Q2, Q3, B, B, T] where B = nbasis(sys.lattice), Qi = max(1, bz_size_i * L_i) and T = num_omegas. By default, bz_size=ones(d).\n\nIndexing the .sfactor attribute at (Œ±, Œ≤, q1, q2, q3, j, k, w) gives ùíÆ^Œ±Œ≤_jk(ùê™ œâ) at ùê™ = q1 * ùêõ_1 + q2 * ùêõ_2 + q3 * ùêõ_3, and œâ = œâ_max * w / T, where ùêõ_1, ùêõ_2, ùêõ_3 are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\nmeas_period determines how many steps to skip between measurements of dynamical trajectories and is set to 1 by default. It determines the maximum resolved frequency, which is 2œÄ/(measrate*dt). The total number of resolved frequencies is set with `numomegas(the number of spin snapshots measured during dynamics). By default,numomegas=1, and the static structure factor is computed. Note also that thatmeasrate` has no meaning for a static structure factor and is ignored.\n\nSetting reduce_basis performs the phase-weighted sums over the basis/sublattice indices, resulting in a size [3, 3, Q1, Q2, Q3, T] array.\n\nSetting dipole_factor applies the dipole form factor, further reducing the array to size [Q1, Q2, Q3, T].\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.update!","page":"Library API","title":"Sunny.update!","text":"update!(sf::StructureFactor, sys::SpinSystem)\n\nAccumulates a contribution to the dynamic structure factor from the spin configuration currently in sys.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.apply_dipole_factor","page":"Library API","title":"Sunny.apply_dipole_factor","text":"apply_dipole_factor(sf::StructureFactor) :: StructureFactor\n\nApply the neutron dipole factor to a dynamic structure factor.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dynamic_structure_factor","page":"Library API","title":"Sunny.dynamic_structure_factor","text":"dynamic_structure_factor(sys::SpinSystem, sampler::S;\n    nsamples::Int=10, thermalize::Int=10, dt::Float64=0.01, num_omegas::Int=100, omega_max=nothing, \n    bz_size=(1,1,1), reduce_basis::Bool=true, dipole_factor::Bool=false, verbose::Bool=false)\n\nMeasures the full dynamic structure factor tensor of a spin system, for the requested range of ùê™-space and range of frequencies œâ. Returns ùíÆ^Œ±Œ≤(ùê™ œâ) = S^Œ±(ùê™ œâ) S^Œ≤(ùê™ œâ)^, which is an array of shape [3, 3, Q1, ..., Qd, T] where Qi = max(1, bz_size_i * L_i) and T = num_omegas. By default, bz_size=ones(d).\n\nSetting reduce_basis=false makes it so that the basis/sublattice indices are not phase-weighted and summed over, making the shape of the result [3, 3, B, B, Q1, ..., Qd, T] where B = nbasis(sys) is the number of basis sites in the unit cell.\n\nnsamples sets the number of thermodynamic samples to measure and average  across from sampler. dt sets the integrator timestep during dynamics,  and meas_period sets how often snapshots are recorded during dynamics. num_omegas  sets the total number snapshots taken. The sampler is thermalized by sampling  thermalize times before any measurements are made.\n\nThe maximum frequency sampled is œâmax = 2œÄ / (dt * meas_period), and the frequency resolution  is set by num_omegas (the number of spin snapshots measured during dynamics). num_omegas defaults  to 100. Note that meas_period is determined automatically by Sunny based on what the user  assigns to dt and omega_max. If no value is given to omega_max, meas_period is set to 1.\n\nIndexing the result at (Œ±, Œ≤, q1, ..., qd, w) gives S^Œ±Œ≤(ùê™ œâ) at     ùê™ = q1 * a‚É∞ + q2 * b‚É∞ + q3 * c‚É∞, and œâ = maxœâ * w / T, where a‚É∞, b‚É∞, c‚É∞     are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\nIf you you would like the form factor to be applied to the resulting structure factor, set the parameter ff_elem to the desired element, e.g. ff_elem=\"Fe2\". For a list of the available ions and their names, see https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html .\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.static_structure_factor","page":"Library API","title":"Sunny.static_structure_factor","text":"static_structure_factor(sys, sampler; nsamples, bz_size, thermalize, verbose)\n\nMeasures the static structure factor tensor of a spin system, for the requested range of ùê™-space. Returns ùíÆ^Œ±Œ≤(ùê™) = S^Œ±(ùê™) S^Œ≤(ùê™)^, which is an array of shape [3, 3, Q1, ..., Qd] where Qi = max(1, bz_size_i * L_i). By default, bz_size=ones(d).\n\nnsamples sets the number of thermodynamic samples to measure and average  across from sampler. dt sets the integrator timestep during dynamics.  The sampler is thermalized by sampling thermalize times before any measurements are made.\n\nIndexing the result at (Œ±, Œ≤, q1, ..., qd) gives ùíÆ^Œ±Œ≤(ùê™) at     ùê™ = q1 * a‚É∞ + q2 * b‚É∞ + q3 * c‚É∞, where a‚É∞, b‚É∞, c‚É∞     are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp).\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library API","title":"Library API","text":"<!‚Äì ","category":"page"},{"location":"library/#Plotting","page":"Library API","title":"Plotting","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"To reduce package load times, Sunny plotting functions are initially hidden, and only become available when the user explicitly executes \"using GLMakie\". It is a good idea to check that the GLMakie installation is working correctly (execute \"] test GLMakie\" from the Julia REPL).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"plot_lattice\nplot_spins\nplot_bonds\nplot_all_bonds\nanim_integration\nlive_integration\nlive_langevin_integration","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"‚Äì>","category":"page"},{"location":"library/#Integrators","page":"Library API","title":"Integrators","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"These functions are not intended to be used by typical users, who instead should instead perform dynamics either using LangevinSampler or implicitly in Structure Factor Calculations. However, advanced users and developers may want direct access to an interface to perform dynamics integrations.","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"HeunP\nLangevinHeunP\nSphericalMidpoint\nevolve!","category":"page"},{"location":"library/#Sunny.HeunP","page":"Library API","title":"Sunny.HeunP","text":"HeunP(sys::SpinSystem)\n\nIntegrates Landau-Lifshitz spin dynamics using the Heun method, with a final projection step that exactly constrains |S|=1. The method is locally second order accurate.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LangevinHeunP","page":"Library API","title":"Sunny.LangevinHeunP","text":"LangevinHeunP(sys, kT, Œ±)\n\nImplements Langevin dynamics on sys targeting a temperature kT, with a damping coefficient Œ±. Provided Œ± should not be normalized by the spin magnitude ‚Äì this is done internally.\n\nUses the 2nd-order Heun + projection scheme.\"\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SphericalMidpoint","page":"Library API","title":"Sunny.SphericalMidpoint","text":"SphericalMidpoint(sys::SpinSystem; atol=1e-12)\n\nIntegrates Landau-Lifshitz spin dynamics using the spherical-midpoint integrator, which is symplectic and implicit. Each step is converged to absolute tolerance atol.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.evolve!","page":"Library API","title":"Sunny.evolve!","text":"evolve!(integrator, Œît)\n\nPerforms a single integrator timestep of size Œît.\n\n\n\n\n\n","category":"function"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"(Still under-complete.)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"This page gives information on the static and dynamical spin structure factors, how to use Sunny's high and low-level interfaces for computing it, and what is happening behind the scenes in these functions!","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The central type implementing all of the computation behind the scenes is StructureFactor.","category":"page"},{"location":"structure-factor/#Background","page":"Structure Factor Calculations","title":"Background","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The structure factor is one representation in which to examine how spins are correlated within spin configurations sampled from the thermal spin distribution defined by the system's Hamiltonian. Specifically, we will write our spin degrees of freedom as S^Œ±_j(ùê´ t), where ùê´ = n_a ùêö + n_b ùêõ + n_c ùêú is the coordinate of the unit cell, t is the time during some evolved dynamics, j is the index into the basis/sublattice within the unit cell, and Œ± = xyz is the spin-component index.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Spin-spin correlations in real space and time can be characterized by the two-point correlation function:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"C^Œ±Œ≤_jk(ùê´ t) = S^Œ±_j(ùê´_0 t_0) S^Œ≤_k(ùê´_0 + ùê´ t_0 + t)_ùê´_0 t_0","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where _ùê´_0 t_0 means we are taking a thermal average over different spin configurations, as well as an average over reference positions ùê´_0 in the lattice and times t_0 in the dynamics. Colloquially, this function is telling us \"how much is the S^Œ± component of one spin on sublattice j correlated with the S^Œ≤ component of another spin on sublattice k which is displaced in position and time by (ùê´ t)?\".","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The full dynamic structure factor is the Fourier transform of the two-point correlation function.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = frac1sqrt2œÄ sum_ùê´ int dt e^-i (ùê™  ùê´ + œât) C^Œ±Œ≤_jk(ùê´ t)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"This is the quantity which the structure factor module computes. By explicitly performing the spatial/time averages in our definition of the two-point correlation function, we can obtain an alternate, more easily calculable form for the dynamic structure factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = S^Œ±_j(ùê™ œâ) S^Œ≤_k(ùê™ œâ)^","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where ^ refers to complex conjugation. This provides an easy direct route to calculating the dynamic structure factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Obtain a bunch of thermal spin configurations S^Œ±_j(ùê´)\nUsing these as initial conditions, time evolve them all forward using Landau-Lifshitz  dynamics to obtain S^Œ±_j(ùê´ t).\nDiscrete Fourier transform them all to obtain S^Œ±_j(ùê™ œâ)\nPerform a complex-conjugated outer product to obtain a contribution S^Œ±_j(ùê™ œâ)S^Œ≤_k(ùê™ œâ)^\nAverage across all sampled spin configurations","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Note that in typical presentations, the basis indices are not present as they are included in the sum/integral over position. However, because spin simulations can resolve basis-dependent correlations, we may as well keep them around for now. Neutron scattering experiments, however, cannot resolve basis-dependent correlations, instead seeing only:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = sum_jk=1^B e^-i ùê™  (ùêù_j - ùêù_k) ùíÆ^Œ±Œ≤_jk(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where B is the number of basis sites within the unit cell and ùêù_j are the basis vectors. Within this page, we will refer to going from the full structure factor to this reduced form as performing the \"phase-weighted sum\" over basis sites.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The static structure factor is the spatial Fourier transform of the equal-time correlation function.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™) = sum_ùê´ e^-iùê™  ùê´ C^Œ±Œ≤_jk(ùê´ 0)\n               = frac1sqrt2œÄ int dœâ ùíÆ^Œ±Œ≤_jk(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"For both of these structure factors, neutron scattering experiments also do not resolve individual spin components. Instead, the observed scattering intensity is proportional to the result of applying the neutron dipole factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ(ùê™ œâ) = _Œ±Œ≤ (Œ¥_Œ±Œ≤ - ùê™_Œ± ùê™_Œ≤) ùíÆ^Œ±Œ≤(ùê™ œâ)","category":"page"},{"location":"structure-factor/#High-level-functions","page":"Structure Factor Calculations","title":"High-level functions","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Sunny exposes one main high-level function which performs the entirety of the steps (1)‚Äì(5) outlined above for you: dynamic_structure_factor. The documentation on that function provides a relatively in-depth explanation of all of the arguments.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A helper function static_structure_factor also exists, which computes the static structure factor simply by calling dynamic_structure_factor with num_meas=1.","category":"page"},{"location":"structure-factor/#Manual-incremental-updates","page":"Structure Factor Calculations","title":"Manual incremental updates","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"If you are writing the lower-level simulation loop yourself, or have a stack of spin configurations on-hand that you want to compute the structure factor from, there is also an additional direct interface.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"If you have a stack of snapshots on hand, then you can directly use them to  construct a StructureFactor. A \"stack of snapshots\" can either be represented as a Vector{SpinSystem} (all of which have the same underlying lattice), or a Vector{Array{Vec3, 4}} along with a Crystal defining the geometry.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"sf = StructureFactor(spin_snaps; )","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"All of the Fourier transforms and computation will be performed at construction time ‚Äì this may take considerable memory and time! By default, this will produce the static structure factor. To obtain the dynamic structure factor, set the dyn_meas keyword argument to a non-zero value (the number of time-evolved snapshots to Fourier transform), along with proper settings for dynŒît and meas_rate (the evolution timestep size, and how many timesteps are taken between snapshots). See the documentation of StructureFactor for more details.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Alternatively, you can create a StructureFactor at the beginning of your simulation by passing a single SpinSystem. The spin configuration of this first system does not enter the averaged structure factor, as the system is purely used to obtain information about the geometry.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Then, during the course of your simulation, call the update! function on the StructureFactor along with your SpinSystem ‚Äì the current spin configuration in the SpinSystem will be Fourier transformed and accumulated into the structure factor. A bare-bones loop achieving this (assuming that you've already created a system::SpinSystem and a sampler) would look like:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"sf = StructureFactor(system)\nfor _ in 1:therm_samples\n   sample!(sampler)\n   update!(sf, sys)\nend","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"(In fact, the code for dynamic_structure_factor is not much more complex than this!) At the end of the loop, sf will hold the structure factor, averaged across all of the thermal spin configurations it was provided.","category":"page"},{"location":"#Sunny.jl","page":"Overview","title":"Sunny.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Sunny is a package for simulating classical spin systems, including the Landau-Lifshitz dynamics of spin dipoles and its generalization to multipolar spin components. In the latter case, Sunny resolves the local quantum structure of individual spins, making it particularly suited for modeling magnetic compounds with strong local anisotropy.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Sunny provides the following features:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Generalization of Landau-Lifshitz spin dynamics using the formalism of SU(N) coherent states.\nAbility specify a crystal by a .cif file, or using its spacegroup symmetry.\nSymmetry analysis to classify allowed Hamiltonian terms, and to automatically populate all symmetry equivalent interactions.\nSingle-ion anisotropy at arbitrary order, which can be specified using Stevens operators or as an arbitrary polynomial of spin operators.\nSampling of spin configurations from the classical Boltzmann distribution at finite-T.\nQuasi-linear scaling dipole-dipole interactions via the fast Fourier transform (FFT) (Langevin mode only).\nMeasurement of mathcalS(mathbfq omega) structure factor data.\nInteractive visualizations of the 3D crystal structure and spin states (support for 3D structure factors is planned.)\nDistributed implementation of parallel tempering to increase sampling efficiency.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A current limitation of Sunny is that it requires real-space dynamical simulations to measure the structure factor, and this limits momentum-space resolution. Support for linear spin wave theory and its SU(N) generalization is in progress.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This page documents various components of how Sunny works internally, and how one might be able to extend it with new functionalities. This page is very under-complete, with internals being documented as we go.","category":"page"},{"location":"internals/#Unit-systems","page":"Internals","title":"Unit systems","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"By default, Sunny assumes the following units: energy in millielectronvolts (meV), field in tesla (T), and distance in angstrom (‚Ñ´). Time is measured in 1/meV, such that ƒß = 1. Temperatures should be provided to all samplers as k_B T, in units of meV matching the energy scale. It becomes particularly necessary to conform to this unit system when a Zeeman or dipole-dipole interaction term is included in the Hamiltonian.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To select a different unit system, one may override the dimensionful physical constants used by Sunny. At the moment, these are the Bohr magneton Œº_B and the vacuum permeability Œº_0. The Bohr magneton converts spin angular momentum (dimensionless) to magnetic moment (meV/T). The vacuum permeability sets the energy scale for dipole-dipole coupling (i.e., interaction between pairs of magnetic moments). Regardless of the unit system chosen, temperatures must be provided to samplers as k_B T, in the same energy units as used when specifying Hamiltonian coupling parameters.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The interface for changing units is subject to change. To select kelvin (instead of meV) as the fundamental energy unit, one may use:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"# Units: kelvin, tesla, angstrom\nSpinSystem(...; ŒºB=0.67171381563034223582, Œº0=17.3497470317891588)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"<!‚Äì ","category":"page"},{"location":"internals/#Handling-Interactions","page":"Internals","title":"Handling Interactions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Interactions exist at two levels:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The types that the user creates and interfaces with (subtypes of AbstractInteraction and  living in Interactions.jl).\nThe types that these get converted to behind the scenes upon creating a SpinSystem  (subtypes of AbstractInteractionCPU, and which are scattered throughout the codebase).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To define a new type of interaction which can appear in a Hamiltonian, one must provide both of these types (which may be the same!), a way to convert from the first to the second, and a collection of functionalities on the second needed for various simulation tasks. We provide the list of required steps below, and for explicit examples see the core interactions defined across src/Interactions.jl and src/PairInteractions.jl.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(1) Define a new struct which is a subtype of AbstractInteraction. This is the user-facing          type, which should be the minimal specification needed to specify the          interaction. As much as possible, instances of this type should be agnostic to          the final crystal geometry they'll be placed on. We'll refer to this type          here as MyInt.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(2) Create another struct which will handle how to actually explicitly compute          terms arising from your interaction on a specific lattice. We'll refer to this          type here as MyIntInternal <: AbstractInteractionCPU. This should expose a constructor          MyIntInternal(int::MyInt, crystal::Crystal, latsize).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(3) Provide the following methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.energy(spins::Array{Vec3, 4}, int::MyIntInternal) which computes the total term in the    Hamiltonian given the state of the system.\nSunny._accum_field!(B::Array{Vec3, 4}, spins::Array{Vec3, 4}, int::MyIntInternal) which   accumulates the local \"field\" coming from this interaction into B given the state   of the spins. Specifically, this function call should perform:       ùêÅ·µ¢ = ùêÅ·µ¢ - _ùêí·µ¢ ‚Ñã_I   where ‚Ñã_I is your new interaction term.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(4) Edit the HamiltonianCPU struct (in Hamiltonian.jl) to store a Vector{MyIntInternal},     and to call your defined energy and _accum_field! functions within     the existing energy(spins, ‚Ñã::HamiltonianCPU) and field!(B, spins, ‚Ñã) functions.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(5) (Optional, for Metropolis sampling support) In Metropolis.jl, edit local_energy_change(sys, idx, newspin) to compute the change in energy from your interaction resulting from changing the spin of sys at idx to newspin.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The current design, while slightly unwieldy, is as it is to (1) separate Hamiltonian definition from Hamiltonian implementation and (2) to avoid paying dispatch costs at runtime. For example, it would be extremely clean and simple if HamiltonianCPU simply stored a Vector{<:IntInternal}, and looped over this to call energy and _accum_field! functions. However, we would have to pay at runtime to constantly look up in dispatch tables which version of energy and _accum_field! we're calling at each loop iteration.","category":"page"},{"location":"internals/#Calculating-Structure-Factors","page":"Internals","title":"Calculating Structure Factors","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section details how the lower-level functions perform each step of computing the structure factor.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To begin, we will assume you have on hand a large array storing a single spin trajectory. By \"single spin trajectory\", we mean a single trajectory of a full system's worth of spins. From an initial spin configuration, you can either just get the static structure factor, or you will first need to perform Landau-Lifshitz dynamics using one of the Integrators to construct a trajectory.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We will refer to this array as spin_traj, which can can be a Array{SVector{3, Float64}} of size size(spin_traj) == [B, D1, D2, D3, T] (with B the number of basis sites, [D1, D2, D3] the number of unit cells along each axis, and T the time axis). Alternatively, this can be an Array{ComplexF64} of size(spin_traj) == [3, B, D1, D2, D3, T] with the spins encoded into the real components. The former is more intuitive, but the latter allows for in-place FFTs.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"First, we need to perform a standard Fast Fourier Transform along the spatial and time axes. This is be done with one of the following functions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.fft_spin_traj\nSunny.fft_spin_traj!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"As the documentation for the functions mentions, you will now have an array of ComplexF64 of size [3, B, D1, D2, D3, T]. (The spin component has been unfolded out into the first axis regardless of the input format).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This could now be outer-producted with itself to form a contribution to the basis-resolved structure factor. In particular, if spin_traj_ft is the name of your FFT'd spin trajectory, the following function will perform this for you:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"outerprod_conj(spin_traj_ft, (1, 2))","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Which should result in a ComplexF64 array of size [3, 3, B, B, D1, D2, D3, T]. The documentation for this function can be seen below:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.outerprod_conj\nSunny.outerprod_conj!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Alternatively, if you only care about the post-basis-summation structure factor, you would first want to instead perform the phase-weighted basis sum. This can be done manually, or by using one of the following functions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.phase_weight_basis\nSunny.phase_weight_basis!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"As documented, this will return an array of ComplexF64 of size [3, Q1, ..., Qd, T], where Q1, ..., Qd are the possibly expanded range of ùê™ space requested through bz_size.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"As before, we can outer product this resulting array with itself to get a contribution to the structure factor, now only required in the first axis as:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.outerprod_conj(spin_traj_ft, 1)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"which should result in a ComplexF64 array of size [3, 3, D1, D2, D3, T]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Repeat this entire process for all thermal spin trajectories you have at a given temperature, average the result across all of them, and you have a dynamic structure factor! Note that if you performed this entire process with an array containing a single spin configuration but an extra \"dummy\" axis of length 1 (i.e. a size [B, D1, D2, D3, 1]), you would be left with the static structure factor!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are additional functions which perform these accumulations while simulataneously applying the neutron dipole form factor to reduce the spin components to a single observable scalar. These are a bit of a mess currently, though.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.accum_dipole_factor!\nSunny.accum_dipole_factor_wbasis!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"‚Äì>","category":"page"},{"location":"quick-start/#Install-Julia-and-Sunny","page":"Quick Start","title":"Install Julia and Sunny","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Download Julia 1.8 or later. Run the Julia executable, which should open a terminal with the prompt: julia>. Load Sunny with the command:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using Sunny","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"If Sunny has not yet been installed, Julia will ask your permission to download and install it within the Julia environment.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"A common way to interact with Sunny is through a Jupyter notebook. Enter","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using IJulia\nnotebook()","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"to launch Jupyter in a browser.","category":"page"},{"location":"quick-start/#Try-an-example","page":"Quick Start","title":"Try an example","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"We recommend that new users explore the features of Sunny by browsing the tutorial notebooks. In particular, the FeI2 case study is a good place to start.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To give some feeling for Sunny, we will here provide only a small example. At the Julia prompt, create a diamond cubic crystal using the Crystal constructor:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"crystal = Crystal(lattice_vectors(1, 1, 1, 90, 90, 90), [[0,0,0]], 227; setting=\"1\")","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The first argument defines a unit cell via the convenience function lattice_vectors. The second argument is a list of basis atom positions. The third, optional argument specifies an international spacegroup number (if it's missing, Sunny will infer a spacegroup). Arguments appearing after the semicolon ; are named. Here, we are selecting the first (out of two) \"setting\" conventions for spacegroup 227.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny outputs:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Crystal\nHM symbol 'F d -3 m' (227)\nLattice params a=1, b=1, c=1, Œ±=90¬∞, Œ≤=90¬∞, Œ≥=90¬∞\nCell volume 1\nWyckoff 8a (point group '-43m'):\n   1. [0, 0, 0]\n   2. [0.5, 0.5, 0]\n   3. [0.25, 0.25, 0.25]\n   4. [0.75, 0.75, 0.25]\n   5. [0.5, 0, 0.5]\n   6. [0, 0.5, 0.5]\n   7. [0.75, 0.25, 0.75]\n   8. [0.25, 0.75, 0.75]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Observe that there are eight symmetry-equivalent site positions (all crystal coordinates are measured in fractions of the lattice vectors). This is indeed the diamond cubic crystal.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"This crystal can be used as an argument to other Sunny functions. For example, to print a list of all symmetry-allowed exchange interactions up to a distance of 0.8, use:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"print_symmetry_table(crystal, 0.8)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"which returns:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Site 1\nPosition [0, 0, 0], multiplicity 8\nAllowed g-tensor: | A  0  0 |\n                  | 0  A  0 |\n                  | 0  0  A |\nAllowed anisotropy in Stevens operators ùí™[k,q]:\n    c‚ÇÅ*(ùí™[4,0]+5ùí™[4,4]) +\n    c‚ÇÇ*(ùí™[6,0]-21ùí™[6,4])\n\nBond(1, 3, [0, 0, 0])\nDistance 0.433, coordination 4\nConnects [0, 0, 0] to [0.25, 0.25, 0.25]\nAllowed exchange matrix: | A  B  B |\n                         | B  A  B |\n                         | B  B  A |\n\nBond(1, 2, [0, 0, 0])\nDistance 0.7071, coordination 12\nConnects [0, 0, 0] to [0.5, 0.5, 0]\nAllowed exchange matrix: | A  C -D |\n                         | C  A -D |\n                         | D  D  B |\nAllowed DM vector: [-D D 0]","category":"page"},{"location":"quick-start/#Next-steps","page":"Quick Start","title":"Next steps","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny provides additional functionality to specify spin Hamiltonians and to calculate and analyze simulated structure factor data. We refer the interested reader to our tutorial notebooks.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Advanced users will benefit from learning more Julia. See our Getting Started guide for resources and tips.","category":"page"}]
}
