var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, you will need an installation of Julia.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Our package is not yet uploaded to Julia's central package repository, and so you will need to perform more of a \"manual\" installation of our package.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To do this, open a terminal and navigate to the directory where you'd like the package to reside. This does not need to  be where you want to do development of scripts / code that uses the package. Then, clone our repo using:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/MagSims/Sunny.git","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This will prompt you for your Github username/password to access the code.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"After downloading, open a Julia REPL in the same directory, press ] to access the package manager interface, then add .:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add .","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you'd like to modify/develop the package further, replace the second command with","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(@v1.6) pkg> dev .","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"which will make it so that all modification to the local code will be reflected when the package is loaded.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If no errors appear, you are done! However, to ensure that our plotting dependencies have installed correctly, it is recommended to explicitly add GLMakie to your enviroment and run their tests:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add GLMakie\n(@v1.6) pkg> test GLMakie","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It is also recommended to explicitly add StaticArrays and OffsetArrays to your enviroment, as our package often accepts and returns types from these packages.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add StaticArrays\n(@v1.6) pkg> add OffsetArrays","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, head over to Examples to start performing your first simulations!","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Here, we document all publically exposed types and methods in our Module. Developers may be interested in further documentation of the Internals.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Our package makes extensive usage of StaticArrays.jl. In particular, throughout the documentation we make use of aliases Vec3 = SVector{3, Float64}, Mat3 = SMatrix{3, 3, Float64, 9}. Additionally, some features and internals utilize OffsetArrays.jl for pleasant indexing. In particular, structure factors are often returned as these.","category":"page"},{"location":"library/#Geometry-definition","page":"Library","title":"Geometry definition","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Crystal\nCrystal(lat_vecs, positions; types, symprec)\nCrystal(::AbstractString; symprec)\nsubcrystal\nnbasis\ncell_volume\nlattice_vectors\nlattice_params","category":"page"},{"location":"library/#Sunny.Crystal","page":"Library","title":"Sunny.Crystal","text":"Crystal\n\nA type holding all geometry and symmetry information needed to represent  a three-dimensional crystal.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal-Tuple{Any, Any}","page":"Library","title":"Sunny.Crystal","text":"Crystal(lat_vecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, representing fractions (between 0 and 1) of the lattice vectors lat_vecs. All symmetry information is automatically inferred.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.Crystal-Tuple{AbstractString}","page":"Library","title":"Sunny.Crystal","text":"Crystal(filename::AbstractString; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal","page":"Library","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\n\n\n\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.nbasis","page":"Library","title":"Sunny.nbasis","text":"nbasis(crystal::Crystal)\n\nNumber of basis positions (sublattices) in the unit cell.\n\n\n\n\n\nnbasis(sys::SpinSystem)\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.cell_volume","page":"Library","title":"Sunny.cell_volume","text":"cell_volume(crystal::Crystal)\n\nVolume of the crystal unit cell.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.lattice_vectors","page":"Library","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Œ± Œ≤ Œ≥).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.lattice_params","page":"Library","title":"Sunny.lattice_params","text":"lattice_params(lat_vecs::Mat3)\n\nCompute the lattice parameters (a b c Œ± Œ≤ Œ≥) from a set of lattice vectors,  which form the columns of lat_vecs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Symmetry-analysis","page":"Library","title":"Symmetry analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Bond\ndisplacement\ndistance\nmultiplicity\nprint_bond\nprint_bond_table\nreference_bonds\nbasis_for_symmetry_allowed_couplings\nall_symmetry_related_bonds\nall_symmetry_related_bonds_for_atom\nall_symmetry_related_couplings\nall_symmetry_related_couplings_for_atom","category":"page"},{"location":"library/#Sunny.Bond","page":"Library","title":"Sunny.Bond","text":"Bond\n\nRepresents a bond between atom indices i and j, with integer displacement of n[1] ... n[D] unit cells along each dimension.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.displacement","page":"Library","title":"Sunny.displacement","text":"displacement(cryst::Crystal, b::Bond)\n\nThe displacement vector ùê´_j - ùê´_i in global coordinates between atoms b.i and b.j, accounting for the integer offsets b.n between unit cells.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.distance","page":"Library","title":"Sunny.distance","text":"distance(cryst::Crystal, b::Bond)\n\nThe global distance between atoms in bond b. Equivalent to norm(displacement(cryst, b)).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.multiplicity","page":"Library","title":"Sunny.multiplicity","text":"multiplicity(cryst::Crystal, b::Bond{3})\n\nThe number of bonds starting from atom index b.i that are symmetry equivalent to b.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_bond","page":"Library","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond)\nprint_bond(cryst::Crystal, i::Int)\n\nPretty-prints symmetry information for bond bond or atom index i.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_bond_table","page":"Library","title":"Sunny.print_bond_table","text":"print_bond_table(cryst::Crystal, max_dist)\n\nPretty-prints a table of bonds, one for each symmetry equivalence class, up to a maximum bond length of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.reference_bonds","page":"Library","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.basis_for_symmetry_allowed_couplings","page":"Library","title":"Sunny.basis_for_symmetry_allowed_couplings","text":"basis_for_symmetry_allowed_couplings(cryst::Crystal, b::Bond)\n\nReturns a list of 33 matrices that form a linear basis for the symmetry-allowed coupling matrices associated with bond b.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_bonds","page":"Library","title":"Sunny.all_symmetry_related_bonds","text":"all_symmetry_related_bonds(cryst::Crystal, b::Bond{3}) :: Vector{Bond{3}}\n\nReturn a list of all bonds which are symmetry-equivalent to the reference bond b.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_bonds_for_atom","page":"Library","title":"Sunny.all_symmetry_related_bonds_for_atom","text":"all_symmetry_related_bonds_for_atom(cryst::Crystal, i::Int, b::Bond)\n\nReturns a list of all bonds starting from atom i that are symmetry-equivalent to the reference bond b.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_couplings","page":"Library","title":"Sunny.all_symmetry_related_couplings","text":"all_symmetry_related_couplings(cryst::Crystal, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_couplings_for_atom","page":"Library","title":"Sunny.all_symmetry_related_couplings_for_atom","text":"all_symmetry_related_couplings_for_atom(cryst::Crystal, i::Int, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds (constrained to start from atom i), and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Interactions","page":"Library","title":"Interactions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"easy_axis\neasy_plane\nsingle_ion_anisotropy\nheisenberg\ndm_interaction\nexchange\nexternal_field\ndipole_dipole","category":"page"},{"location":"library/#Sunny.easy_axis","page":"Library","title":"Sunny.easy_axis","text":"easy_axis(D, n, site, label=\"EasyAxis\")\n\nCreates an easy axis anisotropy,\n\n    - D _i (ùêß^(i)ùêí_i)^2\n\nwhere i runs over all sublattices that are symmetry equivalent to site, ùêß^(i) is the covariant transformation of the unit vector n, and D  0 is the interaction strength.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.easy_plane","page":"Library","title":"Sunny.easy_plane","text":"easy_plane(D, n, site, label=\"EasyPlane\")\n\nCreates an easy plane anisotropy,\n\n    + D _i (ùêß^(i)ùêí_i)^2\n\nwhere i runs over all sublattices that are symmetry equivalent to site, ùêß^(i) is the covariant transformation of the unit vector n, and D  0 is the interaction strength.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.single_ion_anisotropy","page":"Library","title":"Sunny.single_ion_anisotropy","text":"single_ion_anisotropy(J, site, label=\"Anisotropy\")\n\nCreates a quadratic single-ion anisotropy,\n\n    _i ùêí_i^T J^(i) ùêí_i\n\nwhere i runs over all sublattices that are symmetry equivalent to site, and J^(i) is the covariant transformation of the 3  3 anisotropy matrix J appropriate for i. Without loss of generality, we require that J is symmetric.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.heisenberg","page":"Library","title":"Sunny.heisenberg","text":"heisenberg(J, bond::Bond, label::String=\"Heisen\")\n\nCreates a Heisenberg interaction\n\n    J _ij ùêí_i  ùêí_j\n\nwhere ij runs over all bonds symmetry equivalent to bond.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dm_interaction","page":"Library","title":"Sunny.dm_interaction","text":"dm_interaction(DMvec, bond::Bond, label::String=\"DMInt\")\n\nCreates a DM Interaction\n\n    _ij ùêÉ^(ij)  (ùêí_i  ùêí_j)\n\nwhere ij runs over all bonds symmetry equivalent to bond, and ùêÉ^(ij) is the covariant transformation of the DM pseudo-vector DMvec appropriate for the bond ij.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.exchange","page":"Library","title":"Sunny.exchange","text":"exchange(J, bond::Bond, label=\"Exchange\")\n\nCreates a quadratic interaction,\n\n    _ij ùêí_i^T J^(ij) ùêí_j\n\nwhere ij runs over all bonds (not doubly counted) that are symmetry equivalent to bond. The 3  3 interaction matrix J^(ij) is the covariant transformation of J appropriate for the bond ij.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.external_field","page":"Library","title":"Sunny.external_field","text":"external_field(B::Vec3)\n\nAdds an external field ùêÅ and the energy term\n\n    -_i ùêÅ  ùê¶_i\n\nThe magnetic moments are ùê¶_i = g ùê¨_i where g is in general a tensor and the spin magnitude ùê¨_i is typically a multiple of 1/2.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dipole_dipole","page":"Library","title":"Sunny.dipole_dipole","text":"dipole_dipole(; extent::Int=4, Œ∑::Float64=0.5)\n\nAdds long-range dipole-dipole interactions,\n\n    -(Œº‚ÇÄ4œÄ) _ineq j  (3 (ùê¶_jùê´_ij)(ùê¶_iùê´_ij) - ùê¶_iùê¶_j)  ùê´_ij^3\n\nwhere the sum is over all pairs (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ùê¶_i = g ùê¨_i where g is in general a tensor and the spin magnitude ùê¨_i is typically a multiple of 1/2.\n\nA three-dimensional system is required.\n\nextent controls the number of periodic copies of the unit cell summed over in the Ewald summation (higher is more accurate, but higher creation-time cost), while Œ∑ controls the direct/reciprocal-space tradeoff in the Ewald summation.\n\n\n\n\n\n","category":"function"},{"location":"library/#System-definition","page":"Library","title":"System definition","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"SpinSystem\nSpinSystem(::Crystal, ::Vector{<:Sunny.Interaction}, latsize, ::Rational{Int})\nrand!(::SpinSystem)\nenergy\nfield\nfield!","category":"page"},{"location":"library/#Sunny.SpinSystem","page":"Library","title":"Sunny.SpinSystem","text":"Defines a collection of spins, as well as the Hamiltonian they interact under.  This is the main type to interface with most of the package.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinSystem-Tuple{Crystal, Vector{var\"#s25\"} where var\"#s25\"<:Sunny.Interaction, Any, Rational{Int64}}","page":"Library","title":"Sunny.SpinSystem","text":"SpinSystem(crystal::Crystal, ints::Vector{<:Interaction}, latsize, S=1)\n\nConstruct a SpinSystem with spins of magnitude S residing on the lattice sites  of a given crystal, interactions given by ints, and the number of unit cells along  each lattice vector specified by latsize. Initialized to all spins pointing along  the +ùê≥ direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Random.rand!-Tuple{SpinSystem}","page":"Library","title":"Random.rand!","text":"rand!(sys::SpinSystem)\n\nSets spins randomly sampled on the unit sphere.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.energy","page":"Library","title":"Sunny.energy","text":"energy(sys::SpinSystem)\n\nComputes the energy of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.field","page":"Library","title":"Sunny.field","text":"field(sys::SpinSystem)\n\nCompute the local field B at each site of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.field!","page":"Library","title":"Sunny.field!","text":"field!(B::Array{Vec3}, sys::SpinSystem)\n\nUpdates B in-place to contain the local field at each site in the system under sys.hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"library/#Sampling","page":"Library","title":"Sampling","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"LangevinSampler(::SpinSystem, ::Float64, ::Float64, ::Float64, ::Int)\nMetropolisSampler\nset_temp!\nsample!\nthermalize!\nanneal!","category":"page"},{"location":"library/#Sunny.LangevinSampler-Tuple{SpinSystem, Float64, Float64, Float64, Int64}","page":"Library","title":"Sunny.LangevinSampler","text":"LangevinSampler(sys, kT, Œ±, Œît, nsteps)\n\nCreates a LangevinSampler which samples the spin system's Hamiltonian using Langevin  dynamics at a temperature kT, damping coefficient Œ±, and producing a new sample  by integrating with nsteps timesteps of size Œît.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.MetropolisSampler","page":"Library","title":"Sunny.MetropolisSampler","text":"MetropolisSampler(sys::SpinSystem, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to  sample a SpinSystem at the requested temperature.\n\nEach single-spin update attempts to move the spin to a random position on  the unit sphere. One call to sample! will attempt to flip each spin  nsweeps times.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.set_temp!","page":"Library","title":"Sunny.set_temp!","text":"set_temp!(sampler, kT)\n\nChanges the temperature of the sampler to kT.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.sample!","page":"Library","title":"Sunny.sample!","text":"sample!(sampler)\n\nSamples sampler.system to a new state, under the Boltzmann distribution  as defined by sampler.system.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.thermalize!","page":"Library","title":"Sunny.thermalize!","text":"thermalize!(sampler, num_samples)\n\nsample! a sampler a given number of times.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.anneal!","page":"Library","title":"Sunny.anneal!","text":"anneal!(sampler, temp_schedule, step_schedule)\n\nsample! a sampler at a series of temperatures, staying at each temperature   for the number of steps in step_schedule.\n\n\n\n\n\nanneal!(sampler, temp_function, num_samples)\n\nsample! a sampler num_samples times, with the sample at timestep n  drawn at a temperature temp_function(n).\n\n\n\n\n\n","category":"function"},{"location":"library/#Structure-factor-calculations","page":"Library","title":"Structure factor calculations","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"For extended details on what these functions compute, and how they do it, see the page Structure Factor Calculations","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"StructureFactor\nupdate!\napply_dipole_factor\ndynamic_structure_factor\nstatic_structure_factor","category":"page"},{"location":"library/#Sunny.StructureFactor","page":"Library","title":"Sunny.StructureFactor","text":"StructureFactor\n\nType responsible for computing and updating the static/dynamic structure factor averaged across multiple spin configurations. Currently specialized to 3D. (The only thing prohibiting arbitrary dimension is the ugly   typing that would be necessary.)\n\nNote that the initial sys provided does not enter the structure factor, it is purely used to determine the size of various results.\n\nThe full dynamic structure factor is ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = S^Œ±_j(ùê™ œâ) S^Œ≤_k(ùê™ œâ)^, which is an array of shape [3, 3, B, B, Q1, Q2, Q3, T] where B = nbasis(sys.lattice), Qi = max(1, bz_size_i * L_i) and T = dyn_meas. By default, bz_size=ones(d).\n\nIndexing the sfactor attribute at (Œ±, Œ≤, j, k, q1, q2, q3, w) gives ùíÆ^Œ±Œ≤_jk(ùê™ œâ) at ùê™ = q1 * ùêõ_1 + q2 * ùêõ_2 + q3 * ùêõ_3, and œâ = maxœâ * w / T, where ùêõ_1, ùêõ_2, ùêõ_3 are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\nThe maximum frequency sampled is œâmax = 2œÄ / (dynŒît * meas_rate), and the frequency resolution is set by dyn_meas (the number of spin snapshots measured during dynamics). By default, dyn_meas=1, and the static structure factor is computed. However, beyond increasing the frequency resolution, increasing dyn_meas will also make frequencies become more accurate.\n\nSetting reduce_basis performs the phase-weighted sums over the basis/sublattice indices, resulting in a size [3, 3, Q1, Q2, Q3, T] array.\n\nSetting dipole_factor applies the dipole form factor, further reducing the array to size [Q1, Q2, Q3, T].\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.update!","page":"Library","title":"Sunny.update!","text":"update!(sf::StructureFactor, sys::SpinSystem{3})\n\nAccumulates a contribution to the dynamic structure factor from the spin configuration currently in sys.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.apply_dipole_factor","page":"Library","title":"Sunny.apply_dipole_factor","text":"apply_dipole_factor(sf::StructureFactor) :: StructureFactor\n\nApply the neutron dipole factor to a dynamic structure factor.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dynamic_structure_factor","page":"Library","title":"Sunny.dynamic_structure_factor","text":"dynamic_structure_factor(sys, sampler; therm_samples=10, dynŒît=0.01, meas_rate=10,\n                         dyn_meas=100, bz_size, thermalize=10, reduce_basis=true,\n                         verbose=false)\n\nMeasures the full dynamic structure factor tensor of a spin system, for the requested range of ùê™-space and range of frequencies œâ. Returns ùíÆ^Œ±Œ≤(ùê™ œâ) = S^Œ±(ùê™ œâ) S^Œ≤(ùê™ œâ)^, which is an array of shape [3, 3, Q1, ..., Qd, T] where Qi = max(1, bz_size_i * L_i) and T = dyn_meas. By default, bz_size=ones(d).\n\nSetting reduce_basis=false makes it so that the basis/sublattice indices are not phase-weighted and summed over, making the shape of the result [3, 3, B, B, Q1, ..., Qd, T] where B = nbasis(sys) is the number of basis sites in the unit cell. (Not actually implemented yet).\n\ntherm_samples sets the number of thermodynamic samples to measure and average  across from sampler. dynŒît sets the integrator timestep during dynamics,  and meas_rate sets how often snapshots are recorded during dynamics. dyn_meas  sets the total number snapshots taken. The sampler is thermalized by sampling  thermalize times before any measurements are made.\n\nThe maximum frequency sampled is œâmax = 2œÄ / (dynŒît * meas_rate), and the frequency resolution  is set by dyn_meas (the number of spin snapshots measured during dynamics). However, beyond  increasing the resolution, dyn_meas will also make all frequencies become more accurate.\n\nIndexing the result at (Œ±, Œ≤, q1, ..., qd, w) gives S^Œ±Œ≤(ùê™ œâ) at     ùê™ = q1 * a‚É∞ + q2 * b‚É∞ + q3 * c‚É∞, and œâ = maxœâ * w / T, where a‚É∞, b‚É∞, c‚É∞     are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.static_structure_factor","page":"Library","title":"Sunny.static_structure_factor","text":"static_structure_factor(sys, sampler; therm_samples, dynŒît, meas_rate, dyn_meas\n                                      bz_size, thermalize, verbose)\n\nMeasures the static structure factor tensor of a spin system, for the requested range of ùê™-space. Returns ùíÆ^Œ±Œ≤(ùê™) = S^Œ±(ùê™) S^Œ≤(ùê™)^, which is an array of shape [3, 3, Q1, ..., Qd] where Qi = max(1, bz_size_i * L_i). By default, bz_size=ones(d).\n\ntherm_samples sets the number of thermodynamic samples to measure and average  across from sampler. dynŒît sets the integrator timestep during dynamics,  and meas_rate sets how many timesteps are performed between recording snapshots.  dyn_meas sets the total number snapshots taken. The sampler is thermalized by sampling  thermalize times before any measurements are made.\n\nIndexing the result at (Œ±, Œ≤, q1, ..., qd) gives ùíÆ^Œ±Œ≤(ùê™) at     ùê™ = q1 * a‚É∞ + q2 * b‚É∞ + q3 * c‚É∞, where a‚É∞, b‚É∞, c‚É∞     are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp).\n\n\n\n\n\n","category":"function"},{"location":"library/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"All plotting functions rely on a successful user installation of GLMakie, which is dependent on the correct video drivers being installed on your system. To ensure your installation is working correctly, please press ] in a Julia REPL to access the package manager, then execute test GLMakie.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"plot_lattice\nplot_spins\nplot_bonds\nplot_all_bonds\nanim_integration\nlive_integration\nlive_langevin_integration","category":"page"},{"location":"library/#Sunny.plot_lattice","page":"Library","title":"Sunny.plot_lattice","text":"plot_lattice(crystal; ncells=(3,3,3), kwargs...)\n\nPlots a crystal lattice with ncells unit cells along each lattice vector. Other keyword arguments are:\n\ncolors=:Set1_9, markersize=20, linecolor=:grey, linewidth=1.0, kwargs...\n\nArguments\n\nlinecolor=:grey: Sets the colors on the unit cell guide lines\nlinewidth=1.0  : Sets the width of the unit cell guide lines\nmarkersize=20  : Sets the size of the atomic sites\ncolors=:Set1_9 : Sets the colors used for the atomic sites\n\nAdditional keyword arguments are given to GLMakie.scatter! which draws the points.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.plot_spins","page":"Library","title":"Sunny.plot_spins","text":"plot_spins(sys::SpinSystem; linecolor=:grey, arrowcolor=:red, linewidth=0.1,\n                            arrowsize=0.3, arrowlength=1.0, kwargs...)\n\nPlot the spin configuration defined by sys. kwargs are passed to GLMakie.arrows.        \n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.plot_bonds","page":"Library","title":"Sunny.plot_bonds","text":"plot_bonds(cryst::Crystal, ints; kwargs...)\n\nPlot a list of pair interactions defined on a Crystal. kwargs are passed to to plot_lattice!.\n\n\n\n\n\nplot_bonds(sys::SpinSystem; kwargs...)\n\nPlot all pair interactions appearing in sys.hamiltonian, on the underlying crystal lattice. kwargs are passed to plot_lattice!.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.plot_all_bonds","page":"Library","title":"Sunny.plot_all_bonds","text":"plot_all_bonds(crystal::Crystal, max_dist; ncells=(3,3,3), kwargs...)\n\nPlot all bond equivalency classes present in crystal up to a maximum bond length of max_dist. ncells controls how many unit cells are plotted along each axis. kwargs are passed to plot_bonds. \n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.anim_integration","page":"Library","title":"Sunny.anim_integration","text":"anim_integration(sys, fname, steps_per_frame, Œît, nframes; kwargs...)\n\nProduce an animation of constant-energy Landau-Lifshitz dynamics of the given sys.\n\nArguments:\n\nsys::SpinSystem: The spin system to integrate.\nfname::String: The path to save the animation to.\nsteps_per_frame::Int: The number of integration steps to take per frame.\nŒît::Float64: The integration timestep size.\nnframes::Int: The number of frames to produce in the animation.\n\nOther keyword arguments are passed to GLMakie.arrows.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.live_integration","page":"Library","title":"Sunny.live_integration","text":"live_integration(sys, steps_per_frame, Œît; kwargs...)\n\nPerforms endless live constant-energy Landau-Lifshitz integration in an interactive window.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.live_langevin_integration","page":"Library","title":"Sunny.live_langevin_integration","text":"live_langevin_integration(sys, steps_per_frame, Œît, kT; Œ±=0.1, kwargs...)\n\nPerforms endless live Langevin Landau-Lifshitz integration in an interactive window.\n\n\n\n\n\n","category":"function"},{"location":"library/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"These functions are not intended to be used by typical users, who instead should instead perform dynamics either using LangevinSampler or implicitly in Structure factor calculations. However, advanced users and developers may want direct access to an interface to perform dynamics integrations.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"HeunP\nLangevinHeunP\nevolve!","category":"page"},{"location":"library/#Sunny.HeunP","page":"Library","title":"Sunny.HeunP","text":"Integrator for a 2nd-order energy-conserving Heun + projection scheme\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LangevinHeunP","page":"Library","title":"Sunny.LangevinHeunP","text":"Integrator implementing Langevin dynamics using a 2nd-order Heun + projection scheme\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.evolve!","page":"Library","title":"Sunny.evolve!","text":"evolve!(integrator, Œît)\n\nPerforms a single integrator timestep of size Œît.\n\n\n\n\n\n","category":"function"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"(Still under-complete.)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"This page gives information on the static and dynamical spin structure factors, how to use Sunny's high and low-level interfaces for computing it, and what is happening behind the scenes in these functions!","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The central type implementing all of the computation behind the scenes is StructureFactor.","category":"page"},{"location":"structure-factor/#Background","page":"Structure Factor Calculations","title":"Background","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The structure factor is one representation in which to examine how spins are correlated within spin configurations sampled from the thermal spin distribution defined by the system's Hamiltonian. Specifically, we will write our spin degrees of freedom as S^Œ±_j(ùê´ t), where ùê´ = n_a ùêö + n_b ùêõ + n_c ùêú is the coordinate of the unit cell, t is the time during some evolved dynamics, j is the index into the basis/sublattice within the unit cell, and Œ± = xyz is the spin-component index.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Spin-spin correlations in real space and time can be characterized by the two-point correlation function:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"C^Œ±Œ≤_jk(ùê´ t) = S^Œ±_j(ùê´_0 t_0) S^Œ≤_k(ùê´_0 + ùê´ t_0 + t)_ùê´_0 t_0","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where _ùê´_0 t_0 means we are taking a thermal average over different spin configurations, as well as an average over reference positions ùê´_0 in the lattice and times t_0 in the dynamics. Colloquially, this function is telling us \"how much is the S^Œ± component of one spin on sublattice j correlated with the S^Œ≤ component of another spin on sublattice k which is displaced in position and time by (ùê´ t)?\".","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The full dynamic structure factor is the Fourier transform of the two-point correlation function.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = frac1sqrt2œÄ sum_ùê´ int dt e^-i (ùê™  ùê´ + œât) C^Œ±Œ≤_jk(ùê´ t)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"This is the quantity which the structure factor module computes. By explicitly performing the spatial/time averages in our definition of the two-point correlation function, we can obtain an alternate, more easily calculable form for the dynamic structure factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = S^Œ±_j(ùê™ œâ) S^Œ≤_k(ùê™ œâ)^","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where ^ refers to complex conjugation. This provides an easy direct route to calculating the dynamic structure factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Obtain a bunch of thermal spin configurations S^Œ±_j(ùê´)\nUsing these as initial conditions, time evolve them all forward using Landau-Lifshitz  dynamics to obtain S^Œ±_j(ùê´ t).\nDiscrete Fourier transform them all to obtain S^Œ±_j(ùê™ œâ)\nPerform a complex-conjugated outer product to obtain a contribution S^Œ±_j(ùê™ œâ)S^Œ≤_k(ùê™ œâ)^\nAverage across all sampled spin configurations","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Note that in typical presentations, the basis indices are not present as they are included in the sum/integral over position. However, because spin simulations can resolve basis-dependent correlations, we may as well keep them around for now. Neutron scattering experiments, however, cannot resolve basis-dependent correlations, instead seeing only:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = sum_jk=1^B e^-i ùê™  (ùêù_j - ùêù_k) ùíÆ^Œ±Œ≤_jk(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where B is the number of basis sites within the unit cell and ùêù_j are the basis vectors. Within this page, we will refer to going from the full structure factor to this reduced form as performing the \"phase-weighted sum\" over basis sites.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The static structure factor is the spatial Fourier transform of the equal-time correlation function.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™) = sum_ùê´ e^-iùê™  ùê´ C^Œ±Œ≤_jk(ùê´ 0)\n               = frac1sqrt2œÄ int dœâ ùíÆ^Œ±Œ≤_jk(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"For both of these structure factors, neutron scattering experiments also do not resolve individual spin components. Instead, the observed scattering intensity is proportional to the result of applying the neutron dipole factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ(ùê™ œâ) = _Œ±Œ≤ (Œ¥_Œ±Œ≤ - ùê™_Œ± ùê™_Œ≤) ùíÆ^Œ±Œ≤(ùê™ œâ)","category":"page"},{"location":"structure-factor/#High-level-functions","page":"Structure Factor Calculations","title":"High-level functions","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Sunny exposes one main high-level function which performs the entirety of the steps (1)‚Äì(5) outlined above for you: dynamic_structure_factor. The documentation on that function provides a relatively in-depth explanation of all of the arguments.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A helper function static_structure_factor also exists, which computes the static structure factor simply by calling dynamic_structure_factor with num_meas=1.","category":"page"},{"location":"structure-factor/#Manual-incremental-updates","page":"Structure Factor Calculations","title":"Manual incremental updates","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"If you are writing the lower-level simulation loop yourself, or have a stack of spin configurations on-hand that you want to compute the structure factor from, there is also an additional direct interface.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"If you have a stack of snapshots on hand, then you can directly use them to  construct a StructureFactor. A \"stack of snapshots\" can either be represented as a Vector{SpinSystem} (all of which have the same underlying lattice), or a Vector{Array{Vec3, 4}} along with a Crystal defining the geometry.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"sf = StructureFactor(spin_snaps; )","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"All of the Fourier transforms and computation will be performed at construction time ‚Äì this may take considerable memory and time! By default, this will produce the static structure factor. To obtain the dynamic structure factor, set the dyn_meas keyword argument to a non-zero value (the number of time-evolved snapshots to Fourier transform), along with proper settings for dynŒît and meas_rate (the evolution timestep size, and how many timesteps are taken between snapshots). See the documentation of StructureFactor for more details.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Alternatively, you can create a StructureFactor at the beginning of your simulation by passing a single SpinSystem. The spin configuration of this first system does not enter the averaged structure factor, as the system is purely used to obtain information about the geometry.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Then, during the course of your simulation, call the update! function on the StructureFactor along with your SpinSystem ‚Äì the current spin configuration in the SpinSystem will be Fourier transformed and accumulated into the structure factor. A bare-bones loop achieving this (assuming that you've already created a system::SpinSystem and a sampler) would look like:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"sf = StructureFactor(system)\nfor _ in 1:therm_samples\n   sample!(sampler)\n   update!(sf, sys)\nend","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"(In fact, the code for dynamic_structure_factor is not much more complex than this!) At the end of the loop, sf will hold the structure factor, averaged across all of the thermal spin configurations it was provided.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples stepped through here are available in examples/ as full loadable files containing executable functions. Specifically, we work through here the simulations performed in examples/reproduce_testcases.jl. All of the plotting code in here currently depends on an installation of Plots.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The high-level outline of performing a simulation is:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Create a Crystal, either by providing explicit geometry information  (Example 1), or by loading a .cif file (Example 2).\nUsing the Crystal, construct a collection of Interactions.\nAssemble a SpinSystem using the newly created Crystal and Interactions, and the size of the simulation box.\nConstruct a sampler, either a LangevinSampler (Example 1), or a   MetropolisSampler (Example 2).\nUse the sampler directly to sample new states, or use it to perform Structure factor calculations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Defining interactions in step (2) can be aided by our utilities for symmetry analysis, demonstrated at the bottom of this page.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In all examples, we will assume that Sunny and LinearAlgebra have been loaded:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Sunny\nusing LinearAlgebra","category":"page"},{"location":"examples/#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions","page":"Examples","title":"Example 1: Diamond lattice with antiferromagnetic Heisenberg interactions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will step through the basic steps needed to set up and run a spin dynamics simulation, with finite-T statistics obtained by using Langevin dynamics. The full example is contained in the function test_diamond_heisenberg_sf() within examples/reproduce_testcases.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(1) We construct a diamond crystal by explicitly defining the eight atom positions in the conventional cubic unit cell,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"a = 1.0\nlat_vecs = lattice_vectors(a, a, a, 90, 90, 90)\nbasis_vecs = [\n    [0, 0, 0],\n    [2, 2, 0],\n    [3, 1, 1],\n    [1, 3, 1],\n    [2, 0, 2],\n    [0, 2, 2],\n    [1, 1, 3],\n    [3, 3, 3],\n] / 4\ncrystal = Crystal(lat_vecs, basis_vecs)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The terminal will display information about the automatically-inferred symmetry information for the cell.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"One can optionally enter atom types, which affects the inferred spacegroup. For example, Crystal(lat_vecs, basis_vecs; types=[\"A\", \"A\", \"B\", \"B\", \"A\", \"A\", \"B\", \"B\"]) would produce a crystal with reduced symmetry.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A more concise way to create the diamond crystal is using the space group number, which automatically fills in all symmetry equivalent positions,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"crystal = Crystal(lat_vecs, [[0, 0, 0]], 227; setting=\"1\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For spacegroup 227 (symbol \"F d -3 m\"), there are two possible conventions for the unit cell origin. Leaving off the setting option returns all possible crystals.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(2) Next, we need to define our Heisenberg interactions. We want to set up nearest-neighbor antiferromagnetic interactions with a strength of J = 2828mathrmK. One nearest-neighbor bond is the one connecting basis index 1 with basis index 3 within a single unit cell. (We can figure this out using our tools for symmetry analysis, at the bottom of this page).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"J = 28.28           # Units of K\ninteractions = [\n    heisenberg(J, Bond(1, 3, [0,0,0])),\n]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(3) Assembling a SpinSystem is straightforward ‚Äì provide the Crystal, the Interactions, along with the dimensions of the simulation box in units of the lattice vectors. Then, we will randomize the system so that all spins are randomly placed on the unit sphere.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sys = SpinSystem(crystal, interactions, (8, 8, 8))\nrand!(sys)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The SpinSystem type is the central type used throughout our simulations. Internally, it contains the spin degrees of freedom which evolve during the simulation as well as the Hamiltonian defining how this evolution should occur. This type can be indexed into as an array of size B√óLx√óLy√óLz, with the first index selecting the sublattice and the remaining three selecting the unit cell, and the spin located at the  will given. For example, sys[2, 5, 5, 5] gives the spin variable located on the second sublattice in the unit cell, which is fifth along each axis.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(4) We will simulate this system using Langevin dynamics, so we need to create a LangevinSampler. Note that the units of integration time and temperature are relative to the units implicitly used when setting up the interactions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Œît = 0.02 / J       # Units of 1/K\nkT = 4.             # Units of K\nŒ±  = 0.1\nkB = 8.61733e-5     # Units of eV/K\nnsteps = 20000\nsampler = LangevinSampler(sys, kT, Œ±, Œît, nsteps)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"At this point we can call sample!(sampler) to produce new samples of the system, which will be reflected in the state of sysc. Instead, we will proceed to calculate the finite-T structure factor using our built-in routines.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(5) The full process of calculating a structure factor is handled by dynamic_structure_factor. Internally, this function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Thermalizes the system for a while\nSamples a new thermal spin configuration\nPerforms constant-energy LL dynamics to obtain a Fourier-transformed  dynamics trajectory. Use this trajectory to calculate a structure  factor contribution S^Œ±Œ≤(ùê™ œâ).\nRepeat steps (2,3), averaging structure factors across samples.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"See the documentation of dynamic_structure_factor for details of how this process is controlled by the function arguments, and how to properly index into the resulting type StructureFactor. Currently, the main way to interact with this type is to index into its sfactor attribute, which is a large array storing S^Œ±Œ≤(ùê™ œâ) on a grid of ùê™ points and frequencies.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will just look at the diagonal elements of this matrix along some cuts in reciprocal space. To improve statistics, we average these elements across the x y z spin directions since they are all symmetry equivalent in this model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"meas_rate = 10\ndynsf = dynamic_structure_factor(\n    sys, sampler; therm_samples=5, dynŒît=Œît, meas_rate,\n    dyn_meas=1600, bz_size=(1,1,2), thermalize=10, verbose=true,\n    reduce_basis=true, dipole_factor=false\n)\n\n# Retain just the diagonal elements, which we will average across the\n#  symmetry-equivalent directions.\nS = dynsf.sfactor\navgS = zeros(Float64, axes(S)[3:end])\nfor Œ± in 1:3\n    @. avgS += real(S[Œ±, Œ±, :, :, :, :])\nend\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then plot some cuts using a function plot_many_cuts defined within the example script. (I.e. this code block will not successfully execute unless you include(\"examples/reproduce_testcases.jl)). We omit this code here as it's just a large amount of indexing and plotting code, but for details see the script.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the maximum œâ present in our FFT\n# Need to scale by (S+1) with S=3/2 to match the reference,\n#  and then convert to meV.\nmaxœâ = 1000 * 2œÄ / ((meas_rate * Œît) / kB) / (5/2)\np = plot_many_cuts(avgS; maxœâ=maxœâ, chopœâ=5.0)\ndisplay(p)","category":"page"},{"location":"examples/#Example-2:-FeI-with-a-complex-collection-of-interactions","page":"Examples","title":"Example 2: FeI‚ÇÇ with a complex collection of interactions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we work through performing a more complicated and realistic simulation of FeI‚ÇÇ. While the number of interactions is much larger, the general process will be remarkably similar. We will also see how to perform sampling using Metropolis Monte Carlo through the MetropolisSampler type. The full example is contained in the function test_FeI2_MC() within examples/reproduce_testcases.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(1) As before, the first step is to make a Crystal. However, this time we will load the crystal directly from a common crystallographic file format called a .cif. You can download the structure file from this link. Then, we can load it as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"crystal = Crystal(\"./FeI2.cif\")\ncrystal = subcrystal(crystal, \"Fe2+\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Be sure to change \"./FeI2.cif\" to whatever filename you've locally saved the file as.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As only the Fe atoms are spinful, the second line here is selecting out just them. However, the subcrystal function critically retains information about the symmetry of the crystal structure with the I atoms present, which is important for symmetry-constraining allowed interactions between atoms.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(2) We proceed to define our Hamiltonian similarly as before, however this time many more interactions are present. See the documentation on the Interactions for extended descriptions of each. Note that the diagm function from the LinearAlgebra package just makes a diagonal matrix from the vector giving the diagonal.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# All units in meV\nJ1mat = [-0.397  0      0    \n          0     -0.075 -0.261\n          0     -0.261 -0.236]\nJ1 = exchange(J1mat, Bond(1, 1, [1, 0, 0]), \"J1\")\nJ2 = exchange(diagm([0.026, 0.026, 0.113]), Bond(1, 1, [1, -1, 0]), \"J2\")\nJ3 = exchange(diagm([0.166, 0.166, 0.211]), Bond(1, 1, [2, 0, 0]), \"J3\")\nJ0‚Ä≤ = exchange(diagm([0.037, 0.037, -0.036]), Bond(1, 1, [0, 0, 1]), \"J0‚Ä≤\")\nJ1‚Ä≤ = exchange(diagm([0.013, 0.013, 0.051]), Bond(1, 1, [1, 0, 1]), \"J1‚Ä≤\")\nJ2a‚Ä≤ = exchange(diagm([0.068, 0.068, 0.073]), Bond(1, 1, [1, -1, 1]), \"J2a‚Ä≤\")\n\nD = easy_axis(2.165/2, [0, 0, 1], 1, \"D\")\ninteractions = [J1, J2, J3, J0‚Ä≤, J1‚Ä≤, J2a‚Ä≤, D]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To get better insight into the geometry and the long set of pair interactions we've defined above, we can take a look at both using the following plotting function: (you may want to adjust markersize to make the atoms easier to see):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot_bonds(crystal, interactions; ncells=(4,4,4), markersize=500)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(3) As with the previous example, the next step is to make a SpinSystem and randomize it. We'll simulate a fairly large box of size 16times 20times 4.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"system = SpinSystem(crystal, interactions, (16, 20, 4))\nrand!(system)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(4) In this example, we'll choose to work with Metropolis Monte Carlo rather than Langevin sampling. This is necessary in this system due to a very strong single-ion anisotropy (the easy_axis term) making the spins nearly Ising-like. Continuous Langevin dyanmics can have ergodicity issues in these situations, so we have to turn back to the standard Metropolis randomized spin flip proposals.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"kB = 8.61733e-2  # Boltzmann constant, units of meV/K\nkT = 1.0 * kB    # Target simulation temp, in units of meV\n\nsampler = MetropolisSampler(system, kT, 1000)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"MetropolisSampler provides a very similar interface to LangevinSampler. Calling sample!(sampler) will perform some number of spin-flip proposals, then return with system updated to a new set of spin values. The 1000 in our constructor is asking the sampler to perform 1000 sweeps through the system before the sample! function should return.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(5) As in the previous example, we are going to end with computing a dynamic structure factor tensor using the dynamic_structure_factor function. A heuristic for choosing a reasonable value of Œît using in the Landau-Lifshitz dynamics is 0.01 divided by the largest energy scale present in the system. Here, that is the single-ion anisotropy with a strength of 2.165/2 meV.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To make sure we don't do more work than really necessary, we set how often dynamic_structure_factor internally stores snapshots (meas_rate) to target a maximum frequency of target_max_œâ. We also will only collect the structure factor along two Brillouin zones along the first reciprocal axis, by passing bz_size=(2,0,0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following block of code takes about five minutes on a test desktop, but if it's taking too long you can reduce the time either by reducing the number of sweeps MetropolisSampler does, or the num_samples or num_meas in the structure factor computation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Œît = 0.01 / (2.165/2)       # Units of 1/meV\n# Highest energy/frequency we actually care about resolving\ntarget_max_œâ = 10.          # Units of meV\n# Interval number of steps of dynamics before collecting a snapshot for FFTs\nmeas_rate = convert(Int, div(2œÄ, (2 * target_max_œâ * Œît)))\n\nsampler = MetropolisSampler(system, kT, 500)\nprintln(\"Starting structure factor measurement...\")\nS = dynamic_structure_factor(\n    system, sampler; therm_samples=15, thermalize=15,\n    bz_size=(2,0,0), reduce_basis=true, dipole_factor=true,\n    dynŒît=Œît, meas_rate=meas_rate, dyn_meas=1000, verbose=true, \n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, given the full complex-valued mathcalS^alpha beta(boldsymbolq omega), we are asking with dipole_factor=true to have this reduced to a single real-value  by projecting each \\mathcal{S}^{\\alpha \\beta} using the neutron dipole factor. (See Structure factor calculations. To be truly comparable to experiment, a few more steps of processing need to be done which are currently unimplemented.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Will add info here about plotting when better structure factor plotting functions are implemented.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following example, we'll take a closer look at how to make some more manual measurements of the system.","category":"page"},{"location":"examples/#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation","page":"Examples","title":"Example 3: Making manual measurements within a Monte Carlo simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will perform an extended Monte Carlo simulation of the same system as in the previous example, but will perform a careful thermal annealing down to low temperatures and measure an E(T) curve along the way. To do so, we will need to use the sampling tools a bit more manually.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As we're using the same system as before, the setup will be identical. The lines are copied below for convenience, but see the previous example for an explanation of each step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"crystal = Crystal(\"./FeI2.cif\")\ncrystal = subcrystal(crystal, \"Fe2+\")\n\n# All units in meV\nJ1mat = [-0.397  0      0    \n          0     -0.075 -0.261\n          0     -0.261 -0.236]\nJ1 = exchange(J1mat, Bond(1, 1, [1, 0, 0]), \"J1\")\nJ2 = exchange(diagm([0.026, 0.026, 0.113]), Bond(1, 1, [1, -1, 0]), \"J2\")\nJ3 = exchange(diagm([0.166, 0.166, 0.211]), Bond(1, 1, [2, 0, 0]), \"J3\")\nJ0‚Ä≤ = exchange(diagm([0.037, 0.037, -0.036]), Bond(1, 1, [0, 0, 1]), \"J0‚Ä≤\")\nJ1‚Ä≤ = exchange(diagm([0.013, 0.013, 0.051]), Bond(1, 1, [1, 0, 1]), \"J1‚Ä≤\")\nJ2a‚Ä≤ = exchange(diagm([0.068, 0.068, 0.073]), Bond(1, 1, [1, -1, 1]), \"J2a‚Ä≤\")\n\nD = easy_axis(2.165/2, [0, 0, 1], 1, \"D\")\ninteractions = [J1, J2, J3, J0‚Ä≤, J1‚Ä≤, J2a‚Ä≤, D]\n\nsystem = SpinSystem(crystal, interactions, (16, 20, 4))\nrand!(system)\n\nsampler = MetropolisSampler(system, 1.0, 10)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, our goal in the following is to measure an entire E(T) curve, down to relatively low temperatures. To help the system find the ground state correctly at low temperatures, we will use the same system throughout and slowly \"anneal\" the temperature from the highest value down to the lowest.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These next few lines are pure Julia which simply sets up the temperatures we want to measure along, and initializes some Vector's to store some data during the simulations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"kB = 8.61733e-2             # Boltzmann constant, units of meV/K\n\n# Units of Kelvin, matching Xiaojian's range\ntemps = 10 .^ (range(log10(50), stop=0, length=50))\ntemps_meV = kB .* temps\nenergies = Float64[]\nenergy_errors = Float64[]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We've chosen to measure along a logarithmic temperature grid spanning T in 1 50, so that we pack the grid points tighter at lower temperatures where interesting things occur. energies and energy_errors are going to hold our measurements  of the mean energy and the errors at each temperature.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we're going to loop over these temperatures (moving from higher to lower temperatures). At each temperature, we're going to:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Set the temperature of the sampler to the new temperature using set_temp!.\nThermalize at the new temperature for a while before collecting  measurements using thermalize!.\nSample the system 1000 times, and measure the energy of each spin  configuration. We'll record all of these energies in temp_energies.\nCompute the mean energy and its standard error from our 1000 measurements\nPush this mean energy and standard error to our energies and   energy_errors vectors.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For simplicity, here we're just going to use the standard error across all energy measurements as the error. See the binned_statistics function in examples/reproduce_testcases.jl to see how to measure the error more carefully.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following block of code takes a few minutes to execute. Feel free to sample a sparser temperature grid, play around with some of the thermalization parameters, or perform fewer measurements to try to get it to execute faster.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Statistics\n\nfor (i, temp) in enumerate(temps_meV)\n    println(\"Temperature $i = $(temp)\")\n\n    temp_energies = Float64[]\n    set_temp!(sampler, temp)\n    thermalize!(sampler, 100)\n    for _ in 1:1000\n        sample!(sampler) \n        push!(temp_energies, energy(sampler))\n    end\n    meanE = mean(temp_energies)\n    errE  = std(temp_energies) / sqrt(length(temp_energies))\n    push!(energies, meanE)\n    push!(energy_errors, errE)\nend\n\n# Convert energies into energy / spin, in units of K\nenergies ./= (length(system) * kB)\nenergy_errors ./= (length(system) * kB)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we can plot what we've gotten! If you have the Plots.jl library installed you can do this as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\n\np = plot(temps, energies, yerror=energy_errors, marker=:true, ms=3, label=\"Monte Carlo Results\")\nxlabel!(L\"$T$ [K]\")\nylabel!(L\"$E$ [K]\")\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If all has gone well, you should get a plot that looks something like the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: FeI‚ÇÇ Energy Curve)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can take a look at the final low-energy spin configuration by:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot_spins(system; arrowsize=1.5, arrowlength=3, linewidth=0.5)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You should see antiferromagnetic stripes within each c-plane, which shift by one  as you move up each plane!","category":"page"},{"location":"examples/#Symmetry-analysis","page":"Examples","title":"Symmetry analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"When defining pair interactions, we are always defining the interactions on entire symmetry classes at the same time. To do this, we need to provide the exchange matrix J for a specific Bond, which is then automatically propagated to all symmetry-equivalent bonds. Any given bond has symmetry constraints that restrict the allowed space of 3 times 3 coupling matrices.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discover the symmetry allowed couplings for all bonds up to a certain distance, we can use the function print_bond_table.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)\ncrystal = Crystal(lat_vecs, [[0, 0, 0]], 227; setting=\"1\")\nprint_bond_table(crystal, 1.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"which prints","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Atom index 1\nCoordinates [0, 0, 0]\nAllowed single-ion anisotropy or g-tensor: | A  0  0 |\n                                           | 0  A  0 |\n                                           | 0  0  A |\n\nBond(1, 3, [0, 0, 0])\nDistance 0.433, multiplicity 4\nConnects [0, 0, 0] to [0.25, 0.25, 0.25]\nAllowed exchange matrix: | A  B  B |\n                         | B  A  B |\n                         | B  B  A |\n\nBond(1, 2, [0, 0, 0])\nDistance 0.7071, multiplicity 12\nConnects [0, 0, 0] to [0.5, 0.5, 0]\nAllowed exchange matrix: | A  C -D |\n                         | C  A -D |\n                         | D  D  B |\nAllowed DM vector: [-D D 0]\n\nBond(2, 7, [0, 0, 0])\nDistance 0.8292, multiplicity 12\nConnects [0.5, 0.5, 0] to [0.75, 0.25, 0.75]\nAllowed exchange matrix: | A  D  C |\n                         | D  A -C |\n                         | C -C  B |\n\nBond(1, 1, [1, 0, 0])\nDistance 1, multiplicity 6\nConnects [0, 0, 0] to [1, 0, 0]\nAllowed exchange matrix: | A  0  0 |\n                         | 0  B  0 |\n                         | 0  0  B |","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Each entry above makes reference to a specific Bond, but implicitly refers to an entire class of symmetry equivalent bonds. For example, there are 4 symmetry equivalent nearest neighbors in the diamond lattice. To find the ones starting from atom 2 we can use,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> all_symmetry_related_bonds_for_atom(crystal, 2, Bond(1, 3, [0, 0, 0]))\n\n4-element Vector{Bond{3}}:\n Bond(2, 7, [0, 0, -1])\n Bond(2, 8, [0, 0, -1])\n Bond(2, 3, [0, 0, 0])\n Bond(2, 4, [0, 0, 0])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can query properties of a specific bond using print_bond.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> print_bond(crystal, Bond(1, 6, [1,-1,0]))\n\nBond(1, 6, [1, -1, 0])\nDistance 1.225, multiplicity 24\nConnects [0, 0, 0] to [1, -0.5, 0.5]\nAllowed exchange matrix: |   A  D+E -D-E |\n                         | D-E    B    C |\n                         |-D+E    C    B |\nAllowed DM vector: [0 E E]","category":"page"},{"location":"#Sunny.jl","page":"Sunny.jl","title":"Sunny.jl","text":"","category":"section"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"This is the documentation for Sunny.jl. This package aims to be a general-purpose library for simulating and analyzing classical spin systems obtained as the mathrmSU(N) classical limit of quantum spin Hamiltonians.","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"Current Features","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"mathrmSU(2) Landau-Lifshitz spin dynamics\nDefine arbitrary spin Hamiltonians involving supported interactions:\nExternal fields\nArbitrary generalized pair interactions\nOn-site anisotropies\nLong-range dipole-dipole interactions\nAccelerated dipole-dipole interactions using Ewald summation and Fourier-space evaluation\nFinite-T sampling using either Langevin dynamics or Metropolis Monte Carlo\nStructure factor calculations\nAutomated symmetry analysis and bond equivalency class discovery\nInteractive plotting using Makie.jl","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"Planned Features","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"CPU parallelization of dynamics and Monte Carlo simulations\nParallel tempering\nGeneralized mathrmSU(N) models\nGPU acceleration\nAccelerated local MC updates in the presence of long-rage dipole interactions","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"To start running your first simulations, head over to Getting Started to install the package. Then, see Examples for a set of examples demonstrating various features.","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"Or, take a look at the full Library documentation.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This page documents various components of how Sunny works internally, and how one might be able to extend it with new functionalities. This page is very under-complete. Documenting internals as I go.","category":"page"},{"location":"internals/#Handling-Interactions","page":"Internals","title":"Handling Interactions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Interactions exist at two levels:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The types that the user create and interface with (living in Interactions.jl)\nThe types that this gets converted behind the scenes upon creating a SpinSystem  (which are scattered throughout the codebase).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To define a new type of Interaction which can appear in a Hamiltonian, one must provide both of these types (which may be the same!), a way to convert from the first to the second, and a collection of functionalities on the second needed for various simulation tasks. We provide the list of required steps below, and for explicit examples see the core interactions defined across src/Interactions.jl and src/PairInteractions.jl.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(1) Define a new struct which is a subtype of Interaction. This is the user-facing          type, which should be the minimal specification needed to specify the          interaction. As much as possible, instances of this type should be agnostic to          the final crystal geometry they'll be placed on. We'll refer to this type          here as MyInt.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(2) Create another struct which will handle how to actually explicitly compute          terms arising from your interaction on a specific lattice. We'll refer to this          type here as MyIntInternal <: InteractionCPU. This should expose a constructor          MyIntInternal(int::MyInt, crystal::Crystal, latsize).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(3) Provide the following methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.energy(sys::SpinSystem, int::MyIntInternal) which computes the total term in the    Hamiltonian given the state of the system.\nSunny._accum_field!(B::Array{Vec3}, spins::Array{Vec3}, int::MyIntInternal) which   accumulates the local \"field\" coming from this interaction into B given the state   of the spins. Specifically, this function call should perform:       ùêÅ·µ¢ = ùêÅ·µ¢ - _ùêí·µ¢ ‚Ñã_I   where ‚Ñã_I is your new interaction term.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(4) Edit the HamiltonianCPU struct (in Hamiltonian.jl) to store a Vector{MyIntInternal},     and to call your defined energy and _accum_field! functions within     the existing energy(spins, ‚Ñã::HamiltonianCPU) and field!(B, spins, ‚Ñã) functions.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(5) (Optional, for Metropolis sampling support) In Metropolis.jl, edit local_energy_change(sys, idx, newspin) to compute the change in energy from your interaction resulting from changing the spin of sys at idx to newspin.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The current design, while slightly unwieldy, is as it is to (1) separate Hamiltonian definition from Hamiltonian implementation and (2) to avoid paying dispatch costs at runtime. For example, it would be extremely clean and simple if HamiltonianCPU simply stored a Vector{<:IntInternal}, and looped over this to call energy and _accum_field! functions. However, we would have to pay at runtime to constantly look up in dispatch tables which version of energy and _accum_field! we're calling at each loop iteration.","category":"page"},{"location":"internals/#Calculating-Structure-Factors","page":"Internals","title":"Calculating Structure Factors","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section details how the lower-level functions perform each step of computing the structure factor.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To begin, we will assume you have on hand a large array storing a single spin trajectory. By \"single spin trajectory\", we mean a single trajectory of a full system's worth of spins. From an initial spin configuration, you can either just get the static structure factor, or you will first need to perform Landau-Lifshitz dynamics using one of the Integrators to construct a trajectory.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We will refer to this array as spin_traj, which can can be a Array{SVector{3, Float64}} of size size(spin_traj) == [B, D1, D2, D3, T] (with B the number of basis sites, [D1, D2, D3] the number of unit cells along each axis, and T the time axis). Alternatively, this can be an Array{ComplexF64} of size(spin_traj) == [3, B, D1, D2, D3, T] with the spins encoded into the real components. The former is more intuitive, but the latter allows for in-place FFTs.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"First, we need to perform a standard Fast Fourier Transform along the spatial and time axes. This is be done with one of the following functions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.fft_spin_traj\nSunny.fft_spin_traj!","category":"page"},{"location":"internals/#Sunny.fft_spin_traj","page":"Internals","title":"Sunny.fft_spin_traj","text":"fft_spin_traj(spin_traj; bz_size, plan=nothing)\n\nTakes in a spin_traj array of spins (Vec3) of shape [B, D1, ..., Dd, T],  with D1 ... Dd being the spatial dimensions, B the sublattice index,  and T the time axis. Computes and returns an array of the shape [3, B, D1, ..., Dd, T],  holding spatial and temporal fourier transforms S^Œ±(ùê™ œâ). The spatial  fourier transforms are done periodically, but the temporal axis is  internally zero-padded to avoid periodic contributions. (Avoiding  periodic artifacts not implemented yet)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.fft_spin_traj!","page":"Internals","title":"Sunny.fft_spin_traj!","text":"fft_spin_traj!(res, spin_traj; plan=nothing)\n\nIn-place version of fft_spin_traj. res should be an Array{ComplexF64} of size [3, B, D1, ..., Dd, T] to hold the result, matching the size [B, D1, ..., Dd, T] of spin_traj.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"As the documentation for the functions mentions, you will now have an array of ComplexF64 of size [3, B, D1, D2, D3, T]. (The spin component has been unfolded out into the first axis regardless of the input format).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This could now be outer-producted with itself to form a contribution to the basis-resolved structure factor. In particular, if spin_traj_ft is the name of your FFT'd spin trajectory, the following function will perform this for you:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"outerprod_conj(spin_traj_ft, (1, 2))","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Which should result in a ComplexF64 array of size [3, 3, B, B, D1, D2, D3, T]. The documentation for this function can be seen below:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.outerprod_conj\nSunny.outerprod_conj!","category":"page"},{"location":"internals/#Sunny.outerprod_conj","page":"Internals","title":"Sunny.outerprod_conj","text":"outerprod_conj(S, [dims=1])\n\nComputes the outer product along the selected dimensions, with a complex conjugation on the second copy in the product.\n\nI.e. given a complex array of size [D1, ..., Di, ..., Dd], for each dimension i in dims this will create a new axis of the same size to make an array of size [D1, ..., Di, Di, ..., Dd] where the new axes are formed by an outer product of the vectors of the original axes with a complex conjugation on one copy.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.outerprod_conj!","page":"Internals","title":"Sunny.outerprod_conj!","text":"outerprod_conj!(res, S, [dims=1])\n\nLike outerprod_conj, but accumulates the result in-place into res.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"Alternatively, if you only care about the post-basis-summation structure factor, you would first want to instead perform the phase-weighted basis sum. This can be done manually, or by using one of the following functions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.phase_weight_basis\nSunny.phase_weight_basis!","category":"page"},{"location":"internals/#Sunny.phase_weight_basis","page":"Internals","title":"Sunny.phase_weight_basis","text":"phase_weight_basis(spin_traj_ft, bz_size, lattice)\n\nCombines the sublattices of spin_traj_ft with the appropriate phase factors, producing  the quantity S^Œ±(q œâ) within the number of Brillouin zones requested by bz_size.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.phase_weight_basis!","page":"Internals","title":"Sunny.phase_weight_basis!","text":"phase_weight_basis!(res, spin_traj_ft, lattice)\n\nLike phase_weight_basis, but in-place. Infers bz_size from size(res).\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"As documented, this will return an array of ComplexF64 of size [3, Q1, ..., Qd, T], where Q1, ..., Qd are the possibly expanded range of ùê™ space requested through bz_size.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"As before, we can outer product this resulting array with itself to get a contribution to the structure factor, now only required in the first axis as:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.outerprod_conj(spin_traj_ft, 1)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"which should result in a ComplexF64 array of size [3, 3, D1, D2, D3, T]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Repeat this entire process for all thermal spin trajectories you have at a given temperature, average the result across all of them, and you have a dynamic structure factor! Note that if you performed this entire process with an array containing a single spin configuration but an extra \"dummy\" axis of length 1 (i.e. a size [B, D1, D2, D3, 1]), you would be left with the static structure factor!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are additional functions which perform these accumulations while simulataneously applying the neutron dipole form factor to reduce the spin components to a single observable scalar. These are a bit of a mess currently, though.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.accum_dipole_factor!\nSunny.accum_dipole_factor_wbasis!","category":"page"},{"location":"internals/#Sunny.accum_dipole_factor!","page":"Internals","title":"Sunny.accum_dipole_factor!","text":"accum_dipole_factor!(res, S, lattice)\n\nGiven complex S of size [3, Q1, ..., QD, T] and res of size [Q1, ..., QD, T], accumulates the structure factor from S with the dipole factor applied into res.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.accum_dipole_factor_wbasis!","page":"Internals","title":"Sunny.accum_dipole_factor_wbasis!","text":"accum_dipole_factor_wbasis!(res, S, lattice)\n\nGiven complex S of size [3, B, Q1, ..., QD, T] and real res of size [B, B, Q1, ..., QD, T], accumulates the structure factor from S with the dipole factor applied into res.\n\n\n\n\n\n","category":"function"}]
}
