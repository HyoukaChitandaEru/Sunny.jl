var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, download Julia.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"As Sunny.jl is registered with Julia's central package repository, you can easily install it using Julia's package manager. We recommend the following command:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\npkg> add Sunny#main","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The additional #main will cause the the update command of the package manager to update Sunny any time new commits are pushed onto #main (rather than only when new releases are made).","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Alternatively, for early adoptors and developers, we would encourage installing Sunny for development,","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\npkg> dev Sunny#main","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This command will effectively git clone the package into the local directory ~/.julia/dev/Sunny, and then configure the Julia environment to find it. With this dev command, you are free to make changes to the source code, and they will be picked up by Julia. If you additionally install Revise.jl, then source code changes will be take effect while a Julia process is running.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The drawback of this installation method is that the update command of the package manager will no longer touch this package. All updating will have to be manually handled, by using git in the local repo at ~/.julia/dev/Sunny.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To enable plotting, you should explicitly install GLMakie.jl. As of this writing, GLMakie has some rough edges, so it doesn't hurt to also run the tests,","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\npkg> add GLMakie\npkg> test GLMakie","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, head over to Examples to start performing your first simulations!","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Here, we document all publically exposed types and methods in our Module. Developers may be interested in further documentation of the Internals.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Our package makes extensive usage of StaticArrays.jl. In particular, throughout the documentation we make use of aliases Vec3 = SVector{3, Float64}, Mat3 = SMatrix{3, 3, Float64, 9}. Additionally, some features and internals utilize OffsetArrays.jl for pleasant indexing. In particular, structure factors are often returned as these.","category":"page"},{"location":"library/#Geometry-definition","page":"Library","title":"Geometry definition","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Crystal\nCrystal(lat_vecs, positions; types, symprec)\nCrystal(::AbstractString; symprec)\nsubcrystal\nnbasis\ncell_volume\nlattice_vectors\nlattice_params","category":"page"},{"location":"library/#Sunny.Crystal","page":"Library","title":"Sunny.Crystal","text":"Crystal\n\nA type holding all geometry and symmetry information needed to represent  a three-dimensional crystal.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal-Tuple{Any, Any}","page":"Library","title":"Sunny.Crystal","text":"Crystal(lat_vecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, representing fractions (between 0 and 1) of the lattice vectors lat_vecs. All symmetry information is automatically inferred.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.Crystal-Tuple{AbstractString}","page":"Library","title":"Sunny.Crystal","text":"Crystal(filename::AbstractString; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal","page":"Library","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\n\n\n\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.nbasis","page":"Library","title":"Sunny.nbasis","text":"nbasis(crystal::Crystal)\n\nNumber of basis positions (sublattices) in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.cell_volume","page":"Library","title":"Sunny.cell_volume","text":"cell_volume(crystal::Crystal)\n\nVolume of the crystal unit cell.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.lattice_vectors","page":"Library","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Œ± Œ≤ Œ≥).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.lattice_params","page":"Library","title":"Sunny.lattice_params","text":"lattice_params(lat_vecs::Mat3)\n\nCompute the lattice parameters (a b c Œ± Œ≤ Œ≥) from a set of lattice vectors,  which form the columns of lat_vecs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Symmetry-analysis","page":"Library","title":"Symmetry analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Bond\ndisplacement\ndistance\ncoordination_number\nprint_bond\nprint_bond_table\nreference_bonds\nbasis_for_symmetry_allowed_couplings\nall_symmetry_related_bonds\nall_symmetry_related_bonds_for_atom\nall_symmetry_related_couplings\nall_symmetry_related_couplings_for_atom","category":"page"},{"location":"library/#Sunny.Bond","page":"Library","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.displacement","page":"Library","title":"Sunny.displacement","text":"displacement(cryst::Crystal, b::Bond)\n\nThe displacement vector ùê´_j - ùê´_i in global coordinates between atoms b.i and b.j, accounting for the integer offsets b.n between unit cells.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.distance","page":"Library","title":"Sunny.distance","text":"distance(cryst::Crystal, b::Bond)\n\nThe global distance between atoms in bond b. Equivalent to norm(displacement(cryst, b)).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.coordination_number","page":"Library","title":"Sunny.coordination_number","text":"coordination_number(cryst::Crystal, i::Int, b::Bond)\n\nReturns the number times that atom i participates in a bond equivalent to b. In other words, the count of bonds that begin at atom i and that are symmetry-equivalent to b or its reverse.\n\nDefined as length(all_symmetry_related_bonds_for_atom(cryst, i, b)).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_bond","page":"Library","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond)\nprint_bond(cryst::Crystal, i::Int)\n\nPretty-prints symmetry information for bond bond or atom index i.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.print_bond_table","page":"Library","title":"Sunny.print_bond_table","text":"print_bond_table(cryst::Crystal, max_dist)\n\nPretty-prints a table of bonds, one for each symmetry equivalence class, up to a maximum bond length of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.reference_bonds","page":"Library","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.basis_for_symmetry_allowed_couplings","page":"Library","title":"Sunny.basis_for_symmetry_allowed_couplings","text":"basis_for_symmetry_allowed_couplings(cryst::Crystal, b::Bond)\n\nReturns a list of 33 matrices that form a linear basis for the symmetry-allowed coupling matrices associated with bond b.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_bonds","page":"Library","title":"Sunny.all_symmetry_related_bonds","text":"all_symmetry_related_bonds(cryst::Crystal, b::Bond)\n\nReturns a list of all bonds that are symmetry-equivalent to bond b or its reverse.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_bonds_for_atom","page":"Library","title":"Sunny.all_symmetry_related_bonds_for_atom","text":"all_symmetry_related_bonds_for_atom(cryst::Crystal, i::Int, b::Bond)\n\nReturns a list of all bonds that start at atom i, and that are symmetry equivalent to bond b or its reverse.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_couplings","page":"Library","title":"Sunny.all_symmetry_related_couplings","text":"all_symmetry_related_couplings(cryst::Crystal, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.all_symmetry_related_couplings_for_atom","page":"Library","title":"Sunny.all_symmetry_related_couplings_for_atom","text":"all_symmetry_related_couplings_for_atom(cryst::Crystal, i::Int, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds (constrained to start from atom i), and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Interactions","page":"Library","title":"Interactions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"easy_axis\neasy_plane\nquadratic_anisotropy\nheisenberg\ndm_interaction\nexchange\nexternal_field\ndipole_dipole","category":"page"},{"location":"library/#Sunny.easy_axis","page":"Library","title":"Sunny.easy_axis","text":"easy_axis(D, n, site, label=\"EasyAxis\")\n\nCreates an easy axis anisotropy,\n\n    - D _i (ùêß^(i)ùêí_i)^2\n\nwhere i runs over all sublattices that are symmetry equivalent to site, ùêß^(i) is the covariant transformation of the unit vector n, and D  0 is the interaction strength.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.easy_plane","page":"Library","title":"Sunny.easy_plane","text":"easy_plane(D, n, site, label=\"EasyPlane\")\n\nCreates an easy plane anisotropy,\n\n    + D _i (ùêß^(i)ùêí_i)^2\n\nwhere i runs over all sublattices that are symmetry equivalent to site, ùêß^(i) is the covariant transformation of the unit vector n, and D  0 is the interaction strength.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.quadratic_anisotropy","page":"Library","title":"Sunny.quadratic_anisotropy","text":"quadratic_anisotropy(J, site, label=\"Anisotropy\")\n\nCreates a quadratic single-ion anisotropy,\n\n    _i ùêí_i^T J^(i) ùêí_i\n\nwhere i runs over all sublattices that are symmetry equivalent to site, and J^(i) is the covariant transformation of the 3  3 anisotropy matrix J appropriate for i. Without loss of generality, we require that J is symmetric.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.heisenberg","page":"Library","title":"Sunny.heisenberg","text":"heisenberg(J, bond::Bond, label::String=\"Heisen\")\n\nCreates a Heisenberg interaction\n\n    J _ij ùêí_i  ùêí_j\n\nwhere ij runs over all bonds symmetry equivalent to bond.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dm_interaction","page":"Library","title":"Sunny.dm_interaction","text":"dm_interaction(DMvec, bond::Bond, label::String=\"DMInt\")\n\nCreates a DM Interaction\n\n    _ij ùêÉ^(ij)  (ùêí_i  ùêí_j)\n\nwhere ij runs over all bonds symmetry equivalent to bond, and ùêÉ^(ij) is the covariant transformation of the DM pseudo-vector DMvec appropriate for the bond ij.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.exchange","page":"Library","title":"Sunny.exchange","text":"exchange(J, bond::Bond, label=\"Exchange\")\n\nCreates a quadratic interaction,\n\n    _ij ùêí_i^T J^(ij) ùêí_j\n\nwhere ij runs over all bonds (not doubly counted) that are symmetry equivalent to bond. The 3  3 interaction matrix J^(ij) is the covariant transformation of J appropriate for the bond ij.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.external_field","page":"Library","title":"Sunny.external_field","text":"external_field(B::Vec3)\n\nAdds an external field ùêÅ with Zeeman coupling,\n\n    -_i ùêÅ  ùêå_i\n\nThe magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and the spin magnitude ùêí_i is typically a multiple of 1/2. The Bohr magneton Œº_B is a physical constant, with numerical value determined by the unit system.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dipole_dipole","page":"Library","title":"Sunny.dipole_dipole","text":"dipole_dipole(; extent::Int=4, Œ∑::Float64=0.5)\n\nIncludes long-range dipole-dipole interactions,\n\n    -(Œº‚ÇÄ4œÄ) _ij  (3 (ùêå_jùê´_ij)(ùêå_iùê´_ij) - ùêå_iùêå_j)  ùê´_ij^3\n\nwhere the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ùêå_i = Œº_B g ùêí_i where g is the g-factor or g-tensor, and the spin magnitude ùêí_i is typically a multiple of 1/2. The Bohr magneton Œº_B and vacuum permeability Œº_0 are physical constants, with numerical values determined by the unit system.\n\nextent controls the number of periodic copies of the unit cell summed over in the Ewald summation (higher is more accurate, but higher creation-time cost), while Œ∑ controls the direct/reciprocal-space tradeoff in the Ewald summation.\n\n\n\n\n\n","category":"function"},{"location":"library/#System-definition","page":"Library","title":"System definition","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"SpinSystem\nSpinSystem(::Crystal, ::Vector{<:Sunny.AbstractInteraction}, latsize, ::Vector{SiteInfo}; ŒºB, Œº0)\nrand!(::SpinSystem{N}) where N\nrandflips!\nenergy\nfield\nfield!","category":"page"},{"location":"library/#Sunny.SpinSystem","page":"Library","title":"Sunny.SpinSystem","text":"Defines a collection of spins, as well as the Hamiltonian they interact under.  This is the main type to interface with most of the package.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinSystem-Tuple{Crystal, Vector{<:Sunny.AbstractInteraction}, Any, Vector{SiteInfo}}","page":"Library","title":"Sunny.SpinSystem","text":"SpinSystem(crystal::Crystal, ints::Vector{<:AbstractInteraction}, latsize, site_infos::Vector{SiteInfo}=[];\n           ŒºB, Œº0)\n\nConstruct a SpinSystem with spins of magnitude S residing on the lattice sites  of a given crystal, interactions given by ints, and the number of unit cells along  each lattice vector specified by latsize. Initialized to all spins pointing along  the +ùê≥ direction. ŒºB and Œº0 set the Bohr magneton and vacuum permeability. By  default, these are set so that the unit system is (meV, T, ‚Ñ´).\n\n\n\n\n\n","category":"method"},{"location":"library/#Random.rand!-Union{Tuple{SpinSystem{N}}, Tuple{N}} where N","page":"Library","title":"Random.rand!","text":"rand!(sys::SpinSystem{N}) where N\n\nRandomly sample all spins from CP^N-1, i.e., from the space of normalized N-component complex coherent states. In the special case of N=0, randomly sample spin dipoles.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.randflips!","page":"Library","title":"Sunny.randflips!","text":"randflips!(sys::SpinSystem{N}) where N\n\nRandomly \"flip\" every spin with probability 1/2. In the dipole case (N=0), a flip corresponds to sign reversal, ùêí_i  -ùêí_i. In the general case (N0), flipping the coherent state means complex conjugation followed by rotation about the y-axis by œÄ/2.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.energy","page":"Library","title":"Sunny.energy","text":"energy(sys::SpinSystem)\n\nComputes the energy of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.field","page":"Library","title":"Sunny.field","text":"Calculates the local field, B·µ¢, for a single site, i:\n\nùêÅ_i = -_ùê¨_i ‚Ñã.\n\nThis is useful for some sampling methods.\n\n\n\n\n\nfield(sys::SpinSystem)\n\nCompute the local field B at each site of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.field!","page":"Library","title":"Sunny.field!","text":"Updates B in-place to hold the local field on spins under ‚Ñã, defined as:\n\nùêÅ_i = -_ùê¨_i ‚Ñã.\n\n\n\n\n\nfield!(B::Array{Vec3}, sys::SpinSystem)\n\nUpdates B in-place to contain the local field at each site in the system under sys.hamiltonian. The \"local field\" is defined as\n\nùêÅ_i = -_ùê¨_i ‚Ñã  S_i\n\nwith ùê¨_i the unit-vector variable at site i, and S_i is the magnitude of the associated spin.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sampling","page":"Library","title":"Sampling","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"LangevinSampler\nMetropolisSampler\nIsingSampler\nset_temp!\nsample!\nthermalize!\nanneal!","category":"page"},{"location":"library/#Sunny.LangevinSampler","page":"Library","title":"Sunny.LangevinSampler","text":"LangevinSampler(sys::SpinSystem, kT::Float64, Œ±::Float64, Œît::Float64, nsteps::Int)\n\nCreates a LangevinSampler which samples the spin system's Hamiltonian using Langevin  dynamics at a temperature kT, damping coefficient Œ±, and producing a new sample  by integrating with nsteps timesteps of size Œît.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.MetropolisSampler","page":"Library","title":"Sunny.MetropolisSampler","text":"MetropolisSampler(sys::SpinSystem, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to sample  a SpinSystem at the requested temperature.\n\nEach single-spin update attempts to completely randomize the spin. One call to  sample! will attempt to flip each spin nsweeps times.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.IsingSampler","page":"Library","title":"Sunny.IsingSampler","text":"IsingSampler(sys::SpinSystem, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to sample a SpinSystem at the requested temperature.\n\nThis version differs from MetropolisSampler in that each single-spin update only attempts to completely flip the spin. One call to sample! will attempt to flip each spin nsweeps times.\n\nBefore constructing, be sure that your SpinSystem is initialized so that each spin points along its \"Ising-like\" axis.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.set_temp!","page":"Library","title":"Sunny.set_temp!","text":"set_temp!(sampler, kT)\n\nChanges the temperature of the sampler to kT.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.sample!","page":"Library","title":"Sunny.sample!","text":"sample!(sampler)\n\nSamples sampler.sys to a new state, under the Boltzmann distribution  as defined by sampler.sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.thermalize!","page":"Library","title":"Sunny.thermalize!","text":"thermalize!(sampler, num_samples)\n\nsample! a sampler a given number of times.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.anneal!","page":"Library","title":"Sunny.anneal!","text":"anneal!(sampler, temp_schedule, step_schedule)\n\nsample! a sampler at a series of temperatures, staying at each temperature   for the number of steps in step_schedule.\n\n\n\n\n\nanneal!(sampler, temp_function, num_samples)\n\nsample! a sampler num_samples times, with the sample at timestep n  drawn at a temperature temp_function(n).\n\n\n\n\n\n","category":"function"},{"location":"library/#Structure-factor-calculations","page":"Library","title":"Structure factor calculations","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"For extended details on what these functions compute, and how they do it, see the page Structure Factor Calculations","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"StructureFactor\nSunny.update!\napply_dipole_factor\ndynamic_structure_factor\nstatic_structure_factor","category":"page"},{"location":"library/#Sunny.StructureFactor","page":"Library","title":"Sunny.StructureFactor","text":"StructureFactor\n\nType responsible for computing and updating the static/dynamic structure factor averaged across multiple spin configurations. In general, the user should not create a StructureFactor directly, but instead use the interfaces static_structure_factor and dynamic_structure_factor to have Sunny build one for you.\n\nNote that the initial sys provided does not enter the structure factor, it is purely used to determine the size of various results.\n\nThe full dynamic structure factor is ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = M^Œ±_j(ùê™ œâ) M^Œ≤_k(ùê™ œâ)^, which is an array of shape [3, 3, Q1, Q2, Q3, B, B, T] where B = nbasis(sys.lattice), Qi = max(1, bz_size_i * L_i) and T = num_omegas. By default, bz_size=ones(d).\n\nIndexing the .sfactor attribute at (Œ±, Œ≤, q1, q2, q3, j, k, w) gives ùíÆ^Œ±Œ≤_jk(ùê™ œâ) at ùê™ = q1 * ùêõ_1 + q2 * ùêõ_2 + q3 * ùêõ_3, and œâ = œâ_max * w / T, where ùêõ_1, ùêõ_2, ùêõ_3 are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\nmeas_period determines how many steps to skip between measurements of dynamical trajectories and is set to 1 by default. It determines the maximum resolved frequency, which is 2œÄ/(measrate*dt). The total number of resolved frequencies is set with `numomegas(the number of spin snapshots measured during dynamics). By default,numomegas=1, and the static structure factor is computed. Note also that thatmeasrate` has no meaning for a static structure factor and is ignored.\n\nSetting reduce_basis performs the phase-weighted sums over the basis/sublattice indices, resulting in a size [3, 3, Q1, Q2, Q3, T] array.\n\nSetting dipole_factor applies the dipole form factor, further reducing the array to size [Q1, Q2, Q3, T].\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.update!","page":"Library","title":"Sunny.update!","text":"update!(sf::StructureFactor, sys::SpinSystem)\n\nAccumulates a contribution to the dynamic structure factor from the spin configuration currently in sys.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.apply_dipole_factor","page":"Library","title":"Sunny.apply_dipole_factor","text":"apply_dipole_factor(sf::StructureFactor) :: StructureFactor\n\nApply the neutron dipole factor to a dynamic structure factor.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.dynamic_structure_factor","page":"Library","title":"Sunny.dynamic_structure_factor","text":"dynamic_structure_factor(sys::SpinSystem, sampler::S;\n    nsamples::Int=10, thermalize::Int=10, dt::Float64=0.01, num_omegas::Int=100, omega_max=nothing, \n    bz_size=(1,1,1), reduce_basis::Bool=true, dipole_factor::Bool=false, verbose::Bool=false)\n\nMeasures the full dynamic structure factor tensor of a spin system, for the requested range of ùê™-space and range of frequencies œâ. Returns ùíÆ^Œ±Œ≤(ùê™ œâ) = S^Œ±(ùê™ œâ) S^Œ≤(ùê™ œâ)^, which is an array of shape [3, 3, Q1, ..., Qd, T] where Qi = max(1, bz_size_i * L_i) and T = num_omegas. By default, bz_size=ones(d).\n\nSetting reduce_basis=false makes it so that the basis/sublattice indices are not phase-weighted and summed over, making the shape of the result [3, 3, B, B, Q1, ..., Qd, T] where B = nbasis(sys) is the number of basis sites in the unit cell.\n\nnsamples sets the number of thermodynamic samples to measure and average  across from sampler. dt sets the integrator timestep during dynamics,  and meas_period sets how often snapshots are recorded during dynamics. num_omegas  sets the total number snapshots taken. The sampler is thermalized by sampling  thermalize times before any measurements are made.\n\nThe maximum frequency sampled is œâmax = 2œÄ / (dt * meas_period), and the frequency resolution  is set by num_omegas (the number of spin snapshots measured during dynamics). num_omegas defaults  to 100. Note that meas_period is determined automatically by Sunny based on what the user  assigns to dt and omega_max. If no value is given to omega_max, meas_period is set to 1.\n\nIndexing the result at (Œ±, Œ≤, q1, ..., qd, w) gives S^Œ±Œ≤(ùê™ œâ) at     ùê™ = q1 * a‚É∞ + q2 * b‚É∞ + q3 * c‚É∞, and œâ = maxœâ * w / T, where a‚É∞, b‚É∞, c‚É∞     are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\nIf you you would like the form factor to be applied to the resulting structure factor, set the parameter ff_elem to the desired element, e.g. ff_elem=\"Fe2\". For a list of the available ions and their names, see https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html .\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.static_structure_factor","page":"Library","title":"Sunny.static_structure_factor","text":"static_structure_factor(sys, sampler; nsamples, bz_size, thermalize, verbose)\n\nMeasures the static structure factor tensor of a spin system, for the requested range of ùê™-space. Returns ùíÆ^Œ±Œ≤(ùê™) = S^Œ±(ùê™) S^Œ≤(ùê™)^, which is an array of shape [3, 3, Q1, ..., Qd] where Qi = max(1, bz_size_i * L_i). By default, bz_size=ones(d).\n\nnsamples sets the number of thermodynamic samples to measure and average  across from sampler. dt sets the integrator timestep during dynamics.  The sampler is thermalized by sampling thermalize times before any measurements are made.\n\nIndexing the result at (Œ±, Œ≤, q1, ..., qd) gives ùíÆ^Œ±Œ≤(ùê™) at     ùê™ = q1 * a‚É∞ + q2 * b‚É∞ + q3 * c‚É∞, where a‚É∞, b‚É∞, c‚É∞     are the reciprocal lattice vectors of the system supercell.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp).\n\n\n\n\n\n","category":"function"},{"location":"library/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"To reduce package load times, Sunny plotting functions are initially hidden, and only become available when the user explicitly executes \"using GLMakie\". It is a good idea to check that the GLMakie installation is working correctly (execute \"] test GLMakie\" from the Julia REPL).","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"plot_lattice\nplot_spins\nplot_bonds\nplot_all_bonds\nanim_integration\nlive_integration\nlive_langevin_integration","category":"page"},{"location":"library/#Sunny.plot_lattice","page":"Library","title":"Sunny.plot_lattice","text":"plot_lattice(crystal, latsize=(3,3,3); kwargs...)\n\nPlots a crystal lattice with latsize unit cells along each lattice vector. Other keyword arguments are:\n\ncolors=:Set1_9, markersize=20, linecolor=:grey, linewidth=1.0, kwargs...\n\nArguments\n\nlinecolor=:grey: Sets the colors on the unit cell guide lines\nlinewidth=1.0  : Sets the width of the unit cell guide lines\nmarkersize=20  : Sets the size of the atomic sites\ncolors=:Set1_9 : Sets the colors used for the atomic sites\n\nAdditional keyword arguments are given to GLMakie.scatter! which draws the points.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.plot_spins","page":"Library","title":"Sunny.plot_spins","text":"plot_spins(sys::SpinSystem; linecolor=:grey, arrowcolor=:red, linewidth=0.1,\n                            arrowsize=0.3, arrowlength=1.0, kwargs...)\n\nPlot the spin configuration defined by sys. kwargs are passed to GLMakie.arrows.        \n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.plot_bonds","page":"Library","title":"Sunny.plot_bonds","text":"plot_bonds(cryst::Crystal, ints, latsize=(3,3,3), site_infos=SiteInfo[]; kwargs...)\n\nPlot a list of pair interactions defined on a Crystal. latsize sets how many unit cells are plotted, and kwargs are passed to to plot_lattice!.\n\n\n\n\n\nplot_bonds(sys::SpinSystem; kwargs...)\n\nPlot all pair interactions appearing in sys.hamiltonian, on the underlying crystal lattice. kwargs are passed to plot_lattice!.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.plot_all_bonds","page":"Library","title":"Sunny.plot_all_bonds","text":"plot_all_bonds(crystal::Crystal, max_dist, latsize=(3,3,3); kwargs...)\n\nPlot all bond equivalency classes present in crystal up to a maximum bond length of max_dist. latsize controls how many unit cells are plotted along each axis. kwargs are passed to plot_bonds. \n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.anim_integration","page":"Library","title":"Sunny.anim_integration","text":"anim_integration(sys, fname, steps_per_frame, Œît, nframes; kwargs...)\n\nProduce an animation of constant-energy Landau-Lifshitz dynamics of the given sys.\n\nArguments:\n\nsys::SpinSystem: The spin system to integrate.\nfname::String: The path to save the animation to.\nsteps_per_frame::Int: The number of integration steps to take per frame.\nŒît::Float64: The integration timestep size.\nnframes::Int: The number of frames to produce in the animation.\n\nOther keyword arguments are passed to GLMakie.arrows.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.live_integration","page":"Library","title":"Sunny.live_integration","text":"live_integration(sys, steps_per_frame, Œît; kwargs...)\n\nPerforms endless live constant-energy Landau-Lifshitz integration in an interactive window.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sunny.live_langevin_integration","page":"Library","title":"Sunny.live_langevin_integration","text":"live_langevin_integration(sys, steps_per_frame, Œît, kT; Œ±=0.1, kwargs...)\n\nPerforms endless live Langevin Landau-Lifshitz integration in an interactive window.\n\n\n\n\n\n","category":"function"},{"location":"library/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"These functions are not intended to be used by typical users, who instead should instead perform dynamics either using LangevinSampler or implicitly in Structure factor calculations. However, advanced users and developers may want direct access to an interface to perform dynamics integrations.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"HeunP\nLangevinHeunP\nSphericalMidpoint\nevolve!","category":"page"},{"location":"library/#Sunny.HeunP","page":"Library","title":"Sunny.HeunP","text":"HeunP(sys::SpinSystem)\n\nIntegrates Landau-Lifshitz spin dynamics using the Heun method, with a final projection step that exactly constrains |S|=1. The method is locally second order accurate.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LangevinHeunP","page":"Library","title":"Sunny.LangevinHeunP","text":"LangevinHeunP(sys, kT, Œ±)\n\nImplements Langevin dynamics on sys targeting a temperature kT, with a damping coefficient Œ±. Provided Œ± should not be normalized by the spin magnitude ‚Äì this is done internally.\n\nUses the 2nd-order Heun + projection scheme.\"\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SphericalMidpoint","page":"Library","title":"Sunny.SphericalMidpoint","text":"SphericalMidpoint(sys::SpinSystem; atol=1e-12)\n\nIntegrates Landau-Lifshitz spin dynamics using the spherical-midpoint integrator, which is symplectic and implicit. Each step is converged to absolute tolerance atol.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.evolve!","page":"Library","title":"Sunny.evolve!","text":"evolve!(integrator, Œît)\n\nPerforms a single integrator timestep of size Œît.\n\n\n\n\n\n","category":"function"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"(Still under-complete.)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"This page gives information on the static and dynamical spin structure factors, how to use Sunny's high and low-level interfaces for computing it, and what is happening behind the scenes in these functions!","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The central type implementing all of the computation behind the scenes is StructureFactor.","category":"page"},{"location":"structure-factor/#Background","page":"Structure Factor Calculations","title":"Background","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The structure factor is one representation in which to examine how spins are correlated within spin configurations sampled from the thermal spin distribution defined by the system's Hamiltonian. Specifically, we will write our spin degrees of freedom as S^Œ±_j(ùê´ t), where ùê´ = n_a ùêö + n_b ùêõ + n_c ùêú is the coordinate of the unit cell, t is the time during some evolved dynamics, j is the index into the basis/sublattice within the unit cell, and Œ± = xyz is the spin-component index.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Spin-spin correlations in real space and time can be characterized by the two-point correlation function:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"C^Œ±Œ≤_jk(ùê´ t) = S^Œ±_j(ùê´_0 t_0) S^Œ≤_k(ùê´_0 + ùê´ t_0 + t)_ùê´_0 t_0","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where _ùê´_0 t_0 means we are taking a thermal average over different spin configurations, as well as an average over reference positions ùê´_0 in the lattice and times t_0 in the dynamics. Colloquially, this function is telling us \"how much is the S^Œ± component of one spin on sublattice j correlated with the S^Œ≤ component of another spin on sublattice k which is displaced in position and time by (ùê´ t)?\".","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The full dynamic structure factor is the Fourier transform of the two-point correlation function.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = frac1sqrt2œÄ sum_ùê´ int dt e^-i (ùê™  ùê´ + œât) C^Œ±Œ≤_jk(ùê´ t)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"This is the quantity which the structure factor module computes. By explicitly performing the spatial/time averages in our definition of the two-point correlation function, we can obtain an alternate, more easily calculable form for the dynamic structure factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™ œâ) = S^Œ±_j(ùê™ œâ) S^Œ≤_k(ùê™ œâ)^","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where ^ refers to complex conjugation. This provides an easy direct route to calculating the dynamic structure factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Obtain a bunch of thermal spin configurations S^Œ±_j(ùê´)\nUsing these as initial conditions, time evolve them all forward using Landau-Lifshitz  dynamics to obtain S^Œ±_j(ùê´ t).\nDiscrete Fourier transform them all to obtain S^Œ±_j(ùê™ œâ)\nPerform a complex-conjugated outer product to obtain a contribution S^Œ±_j(ùê™ œâ)S^Œ≤_k(ùê™ œâ)^\nAverage across all sampled spin configurations","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Note that in typical presentations, the basis indices are not present as they are included in the sum/integral over position. However, because spin simulations can resolve basis-dependent correlations, we may as well keep them around for now. Neutron scattering experiments, however, cannot resolve basis-dependent correlations, instead seeing only:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤(ùê™ œâ) = sum_jk=1^B e^-i ùê™  (ùêù_j - ùêù_k) ùíÆ^Œ±Œ≤_jk(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"where B is the number of basis sites within the unit cell and ùêù_j are the basis vectors. Within this page, we will refer to going from the full structure factor to this reduced form as performing the \"phase-weighted sum\" over basis sites.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The static structure factor is the spatial Fourier transform of the equal-time correlation function.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ^Œ±Œ≤_jk(ùê™) = sum_ùê´ e^-iùê™  ùê´ C^Œ±Œ≤_jk(ùê´ 0)\n               = frac1sqrt2œÄ int dœâ ùíÆ^Œ±Œ≤_jk(ùê™ œâ)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"For both of these structure factors, neutron scattering experiments also do not resolve individual spin components. Instead, the observed scattering intensity is proportional to the result of applying the neutron dipole factor:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ùíÆ(ùê™ œâ) = _Œ±Œ≤ (Œ¥_Œ±Œ≤ - ùê™_Œ± ùê™_Œ≤) ùíÆ^Œ±Œ≤(ùê™ œâ)","category":"page"},{"location":"structure-factor/#High-level-functions","page":"Structure Factor Calculations","title":"High-level functions","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Sunny exposes one main high-level function which performs the entirety of the steps (1)‚Äì(5) outlined above for you: dynamic_structure_factor. The documentation on that function provides a relatively in-depth explanation of all of the arguments.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A helper function static_structure_factor also exists, which computes the static structure factor simply by calling dynamic_structure_factor with num_meas=1.","category":"page"},{"location":"structure-factor/#Manual-incremental-updates","page":"Structure Factor Calculations","title":"Manual incremental updates","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"If you are writing the lower-level simulation loop yourself, or have a stack of spin configurations on-hand that you want to compute the structure factor from, there is also an additional direct interface.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"If you have a stack of snapshots on hand, then you can directly use them to  construct a StructureFactor. A \"stack of snapshots\" can either be represented as a Vector{SpinSystem} (all of which have the same underlying lattice), or a Vector{Array{Vec3, 4}} along with a Crystal defining the geometry.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"sf = StructureFactor(spin_snaps; )","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"All of the Fourier transforms and computation will be performed at construction time ‚Äì this may take considerable memory and time! By default, this will produce the static structure factor. To obtain the dynamic structure factor, set the dyn_meas keyword argument to a non-zero value (the number of time-evolved snapshots to Fourier transform), along with proper settings for dynŒît and meas_rate (the evolution timestep size, and how many timesteps are taken between snapshots). See the documentation of StructureFactor for more details.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Alternatively, you can create a StructureFactor at the beginning of your simulation by passing a single SpinSystem. The spin configuration of this first system does not enter the averaged structure factor, as the system is purely used to obtain information about the geometry.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Then, during the course of your simulation, call the update! function on the StructureFactor along with your SpinSystem ‚Äì the current spin configuration in the SpinSystem will be Fourier transformed and accumulated into the structure factor. A bare-bones loop achieving this (assuming that you've already created a system::SpinSystem and a sampler) would look like:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"sf = StructureFactor(system)\nfor _ in 1:therm_samples\n   sample!(sampler)\n   update!(sf, sys)\nend","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"(In fact, the code for dynamic_structure_factor is not much more complex than this!) At the end of the loop, sf will hold the structure factor, averaged across all of the thermal spin configurations it was provided.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Please take a look at our Jupyter notebook tutorials.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Additional working examples are available in examples/ as fully loadable files containing executable functions. We will soon update this page with additional information that will walk you through these examples. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The high-level outline of performing a simulation is:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Create a Crystal, either by providing explicit geometry information  (Example 1), or by loading a .cif file (Example 2).\nUsing the Crystal, construct a collection of Interactions.\nAssemble a SpinSystem using the newly created Crystal and interactions, the size of the simulation box, and optionally information on the spin magnitude and g-tensors of each site by passing a list of SiteInfo.\nConstruct a sampler, either a LangevinSampler (Example 1), or a   MetropolisSampler (Example 2).\nUse the sampler directly to sample new states, or use it to perform Structure factor calculations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Sunny provides a full suite of symmetry analysis tools to ensure that the interactions specified in step 2 are valid for the specified crystal.","category":"page"},{"location":"#Sunny.jl","page":"Sunny.jl","title":"Sunny.jl","text":"","category":"section"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"This is the documentation for Sunny.jl. This package aims to be a general-purpose library for simulating and analyzing classical spin systems obtained as the mathrmSU(N) classical limit of quantum spin Hamiltonians.","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"Current Features","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"mathrmSU(2) Landau-Lifshitz spin dynamics\nDefine arbitrary spin Hamiltonians involving supported interactions:\nExternal fields\nArbitrary generalized pair interactions\nOn-site anisotropies\nLong-range dipole-dipole interactions\nAccelerated dipole-dipole interactions using Ewald summation and Fourier-space evaluation\nFinite-T sampling using either Langevin dynamics or Metropolis Monte Carlo\nStructure factor calculations\nAutomated symmetry analysis and bond equivalency class discovery\nInteractive plotting using Makie.jl\nParallel tempering","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"Planned Features","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"CPU parallelization of dynamics and Monte Carlo simulations\nGeneralized mathrmSU(N) models\nGPU acceleration\nAccelerated local MC updates in the presence of long-range dipole interactions","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"To start running your first simulations, head over to Getting Started to install the package. Then, see Examples for a set of examples demonstrating various features.","category":"page"},{"location":"","page":"Sunny.jl","title":"Sunny.jl","text":"Or, take a look at the full Library documentation.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This page documents various components of how Sunny works internally, and how one might be able to extend it with new functionalities. This page is very under-complete, with internals being documented as we go.","category":"page"},{"location":"internals/#Unit-systems","page":"Internals","title":"Unit systems","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"By default, Sunny assumes the following units: energy in millielectronvolts (meV), field in tesla (T), and distance in angstrom (‚Ñ´). Time is measured in 1/meV, such that ƒß = 1. Temperatures should be provided to all samplers as k_B T, in units of meV matching the energy scale. It becomes particularly necessary to conform to this unit system when a Zeeman or dipole-dipole interaction term is included in the Hamiltonian.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To select a different unit system, one may override the dimensionful physical constants used by Sunny. At the moment, these are the Bohr magneton Œº_B and the vacuum permeability Œº_0. The Bohr magneton converts spin angular momentum (dimensionless) to magnetic moment (meV/T). The vacuum permeability sets the energy scale for dipole-dipole coupling (i.e., interaction between pairs of magnetic moments). Regardless of the unit system chosen, temperatures must be provided to samplers as k_B T, in the same energy units as used when specifying Hamiltonian coupling parameters.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The interface for changing units is subject to change. To select kelvin (instead of meV) as the fundamental energy unit, one may use:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"# Units: kelvin, tesla, angstrom\nSpinSystem(...; ŒºB=0.67171381563034223582, Œº0=17.3497470317891588)","category":"page"},{"location":"internals/#Handling-Interactions","page":"Internals","title":"Handling Interactions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Interactions exist at two levels:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The types that the user creates and interfaces with (subtypes of AbstractInteraction and  living in Interactions.jl).\nThe types that these get converted to behind the scenes upon creating a SpinSystem  (subtypes of AbstractInteractionCPU, and which are scattered throughout the codebase).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To define a new type of interaction which can appear in a Hamiltonian, one must provide both of these types (which may be the same!), a way to convert from the first to the second, and a collection of functionalities on the second needed for various simulation tasks. We provide the list of required steps below, and for explicit examples see the core interactions defined across src/Interactions.jl and src/PairInteractions.jl.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(1) Define a new struct which is a subtype of AbstractInteraction. This is the user-facing          type, which should be the minimal specification needed to specify the          interaction. As much as possible, instances of this type should be agnostic to          the final crystal geometry they'll be placed on. We'll refer to this type          here as MyInt.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(2) Create another struct which will handle how to actually explicitly compute          terms arising from your interaction on a specific lattice. We'll refer to this          type here as MyIntInternal <: AbstractInteractionCPU. This should expose a constructor          MyIntInternal(int::MyInt, crystal::Crystal, latsize).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(3) Provide the following methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.energy(spins::Array{Vec3, 4}, int::MyIntInternal) which computes the total term in the    Hamiltonian given the state of the system.\nSunny._accum_field!(B::Array{Vec3, 4}, spins::Array{Vec3, 4}, int::MyIntInternal) which   accumulates the local \"field\" coming from this interaction into B given the state   of the spins. Specifically, this function call should perform:       ùêÅ·µ¢ = ùêÅ·µ¢ - _ùêí·µ¢ ‚Ñã_I   where ‚Ñã_I is your new interaction term.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(4) Edit the HamiltonianCPU struct (in Hamiltonian.jl) to store a Vector{MyIntInternal},     and to call your defined energy and _accum_field! functions within     the existing energy(spins, ‚Ñã::HamiltonianCPU) and field!(B, spins, ‚Ñã) functions.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(5) (Optional, for Metropolis sampling support) In Metropolis.jl, edit local_energy_change(sys, idx, newspin) to compute the change in energy from your interaction resulting from changing the spin of sys at idx to newspin.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The current design, while slightly unwieldy, is as it is to (1) separate Hamiltonian definition from Hamiltonian implementation and (2) to avoid paying dispatch costs at runtime. For example, it would be extremely clean and simple if HamiltonianCPU simply stored a Vector{<:IntInternal}, and looped over this to call energy and _accum_field! functions. However, we would have to pay at runtime to constantly look up in dispatch tables which version of energy and _accum_field! we're calling at each loop iteration.","category":"page"},{"location":"internals/#Calculating-Structure-Factors","page":"Internals","title":"Calculating Structure Factors","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section details how the lower-level functions perform each step of computing the structure factor.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To begin, we will assume you have on hand a large array storing a single spin trajectory. By \"single spin trajectory\", we mean a single trajectory of a full system's worth of spins. From an initial spin configuration, you can either just get the static structure factor, or you will first need to perform Landau-Lifshitz dynamics using one of the Integrators to construct a trajectory.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We will refer to this array as spin_traj, which can can be a Array{SVector{3, Float64}} of size size(spin_traj) == [B, D1, D2, D3, T] (with B the number of basis sites, [D1, D2, D3] the number of unit cells along each axis, and T the time axis). Alternatively, this can be an Array{ComplexF64} of size(spin_traj) == [3, B, D1, D2, D3, T] with the spins encoded into the real components. The former is more intuitive, but the latter allows for in-place FFTs.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"First, we need to perform a standard Fast Fourier Transform along the spatial and time axes. This is be done with one of the following functions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.fft_spin_traj\nSunny.fft_spin_traj!","category":"page"},{"location":"internals/#Sunny.fft_spin_traj","page":"Internals","title":"Sunny.fft_spin_traj","text":"fft_spin_traj(spin_traj; bz_size, plan=nothing)\n\nTakes in a spin_traj array of spins (Vec3) of shape [D1, ..., Dd, B, T],    with D1 ... Dd being the spatial dimensions, B the sublattice index,  and T the time axis. Computes and returns an array of the shape [3, D1, ..., Dd, B, T],  holding spatial and temporal fourier transforms S^Œ±_b(ùê™ œâ). The spatial  fourier transforms are done periodically, but the temporal axis is  internally zero-padded to avoid periodic contributions. (Avoiding  periodic artifacts not implemented yet)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.fft_spin_traj!","page":"Internals","title":"Sunny.fft_spin_traj!","text":"fft_spin_traj!(res, spin_traj; plan=nothing)\n\nIn-place version of fft_spin_traj. res should be an Array{ComplexF64} of size [3, D1, ..., Dd, B, T] to hold the result, matching the size [D1, ..., Dd, B, T] of spin_traj.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"As the documentation for the functions mentions, you will now have an array of ComplexF64 of size [3, B, D1, D2, D3, T]. (The spin component has been unfolded out into the first axis regardless of the input format).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This could now be outer-producted with itself to form a contribution to the basis-resolved structure factor. In particular, if spin_traj_ft is the name of your FFT'd spin trajectory, the following function will perform this for you:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"outerprod_conj(spin_traj_ft, (1, 2))","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Which should result in a ComplexF64 array of size [3, 3, B, B, D1, D2, D3, T]. The documentation for this function can be seen below:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.outerprod_conj\nSunny.outerprod_conj!","category":"page"},{"location":"internals/#Sunny.outerprod_conj","page":"Internals","title":"Sunny.outerprod_conj","text":"outerprod_conj(S, [dims=1])\n\nComputes the outer product along the selected dimensions, with a complex conjugation on the second copy in the product.\n\nI.e. given a complex array of size [D1, ..., Di, ..., Dd], for each dimension i in dims this will create a new axis of the same size to make an array of size [D1, ..., Di, Di, ..., Dd] where the new axes are formed by an outer product of the vectors of the original axes with a complex conjugation on one copy.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.outerprod_conj!","page":"Internals","title":"Sunny.outerprod_conj!","text":"outerprod_conj!(res, S, [dims=1])\n\nLike outerprod_conj, but accumulates the result in-place into res.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"Alternatively, if you only care about the post-basis-summation structure factor, you would first want to instead perform the phase-weighted basis sum. This can be done manually, or by using one of the following functions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.phase_weight_basis\nSunny.phase_weight_basis!","category":"page"},{"location":"internals/#Sunny.phase_weight_basis","page":"Internals","title":"Sunny.phase_weight_basis","text":"phase_weight_basis(spin_traj_ft, bz_size, lattice)\n\nCombines the sublattices of spin_traj_ft with the appropriate phase factors, producing  the quantity S^Œ±(ùê™ œâ) within the number of Brillouin zones requested by bz_size. Specifically, computes:\n\nS^Œ±(ùê™ œâ) = _b e^-iùê´_b  ùê™ S^Œ±_b(ùê™ œâ)\n\nwhere b is the basis index and ùê´_b is the associated basis vector. S^Œ±_b(ùê™ œâ) is periodically repeated past the first Brillouin zone, but the resulting S^Œ±(ùê™ œâ) will not necessarily be periodic.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.phase_weight_basis!","page":"Internals","title":"Sunny.phase_weight_basis!","text":"phase_weight_basis!(res, spin_traj_ft, lattice)\n\nLike phase_weight_basis, but in-place. Infers bz_size from size(res).\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"As documented, this will return an array of ComplexF64 of size [3, Q1, ..., Qd, T], where Q1, ..., Qd are the possibly expanded range of ùê™ space requested through bz_size.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"As before, we can outer product this resulting array with itself to get a contribution to the structure factor, now only required in the first axis as:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.outerprod_conj(spin_traj_ft, 1)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"which should result in a ComplexF64 array of size [3, 3, D1, D2, D3, T]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Repeat this entire process for all thermal spin trajectories you have at a given temperature, average the result across all of them, and you have a dynamic structure factor! Note that if you performed this entire process with an array containing a single spin configuration but an extra \"dummy\" axis of length 1 (i.e. a size [B, D1, D2, D3, 1]), you would be left with the static structure factor!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are additional functions which perform these accumulations while simulataneously applying the neutron dipole form factor to reduce the spin components to a single observable scalar. These are a bit of a mess currently, though.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Sunny.accum_dipole_factor!\nSunny.accum_dipole_factor_wbasis!","category":"page"},{"location":"internals/#Sunny.accum_dipole_factor!","page":"Internals","title":"Sunny.accum_dipole_factor!","text":"accum_dipole_factor!(res, S, lattice)\n\nGiven complex S of size [3, Q1, ..., QD, T] and res of size [Q1, ..., QD, T], accumulates the structure factor from S with the dipole factor applied into res.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sunny.accum_dipole_factor_wbasis!","page":"Internals","title":"Sunny.accum_dipole_factor_wbasis!","text":"accum_dipole_factor_wbasis!(res, S, lattice)\n\nGiven complex S of size [3, Q1, ..., QD, B, T] and real res of size [Q1, ..., QD, B, B, T], accumulates the structure factor from S with the dipole factor applied into res.\n\n\n\n\n\n","category":"function"}]
}
